<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SerialDriver.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
<head><title>Serial and Virtual Drivers</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="SerialManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="SerialLinkManager.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924904"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>59 Serial and Virtual Drivers</h1><dl><a name="924905"> </a><p></p><dt>This chapter provides reference material for the new serial manager device driver API:<ul type="SQUARE"><a name="924909"> </a><br><li><a href="SerialDriver.html#924937">Driver Data Structures</a><br><a name="924913"> </a><br><li><a href="SerialDriver.html#925445">Driver Constants</a><br><a name="924917"> </a><br><li><a href="SerialDriver.html#925485">Serial Driver-Defined Functions</a><br><a name="924921"> </a><br><li><a href="SerialDriver.html#925768">Virtual Driver-Defined Functions</a><br><a name="924925"> </a><br><li><a href="SerialDriver.html#925993">Serial Manager Queue Functions</a><br></ul><a name="924927"> </a><p></p><dt>The header file <code>SerialSdrv.h</code> declares the serial driver API and the file <code>SerialVdrv.h</code> declares the virtual driver API. Both types of drivers also use the <code>SerialDrvr.h</code> header file. For more information on writing device drivers for the new serial manager, see section <a href="SerialCommunication.html#925510">Writing a Serial or Virtual Device Driver</a> in the chapter <a href="SerialCommunication.html#928031">Serial Communication</a> in the <em>Palm OS Programmer's Companion</em>. </dl><a name="924937"> </a><h2> Driver Data Structures</h2><a name="924939"> </a><h3> DrvrInfoType</h3><dl><a name="924941"> </a><p></p><dt>The <code>DrvrInfoType</code> structure defines information about the serial hardware. It is passed to and filled in by the <code><a href="SerialDriver.html#925490"></code>DrvEntryPoint<code></a></code> function for a serial driver and the <code><a href="SerialDriver.html#925773"></code>DrvEntryPoint<code></a></code> for a virtual driver.</dl><a name="924948"> </a><hr><code>typedef struct {</code><br><a name="924949"> </a><code>UInt32 drvrID;</code><br><a name="924950"> </a><code>UInt32 drvrVersion;</code><br><a name="924951"> </a><code>UInt32 maxBaudRate;</code><br><a name="924952"> </a><code>UInt32 handshakeThreshold;</code><br><a name="924953"> </a><code>UInt32 portFlags;</code><br><a name="924954"> </a><code>Char&nbsp;* portDesc;</code><br><a name="924955"> </a><code>DrvrIRQEnum irqType;</code><br><a name="929333"> </a><code>UInt8 reserved;</code><br><a name="924956"> </a><code>} DrvrInfoType;</code><br><hr><br><a name="924957"> </a><h4> Value Descriptions</h4><p><a name="924990"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="924960"> </a><code>drvrID</code> </td><td><a name="924962"> </a>4-character creator type, such as 'u328'</td></tr><tr><td><a name="924964"> </a><code>drvrVersion</code> </td><td><a name="924966"> </a>Version of code that works for this hardware. For this release, all serial drivers should return version <code>kDrvrVersion</code> here.</td></tr><tr><td><a name="924968"> </a><code>maxBaudRate</code> </td><td><a name="924970"> </a>Maximum baud rate supported by this hardware</td></tr><tr><td><a name="924972"> </a><code>handshakeThreshold</code> </td><td><a name="924974"> </a>Baud rate at which hardware handshaking is necessary to be used</td></tr><tr><td><a name="924976"> </a><code>portFlags</code> </td><td><a name="924978"> </a>Bit flags denoting features of this hardware. The flags are described in <a href="SerialDriver.html#925448">Port Feature Constants</a>.</td></tr><tr><td><a name="924983"> </a><code>portDesc</code> </td><td><a name="924985"> </a>Pointer to null-terminated string describing this hardware. This string appears in the Connection panel to describe the port to the user (only if the <code>portCncMgrVisible</code> bit in <code>portFlags</code> is set). Can be <code>NULL</code> if the driver contains a resource (of type 'tSTR' and id <code>kPortDescStrID</code>) that supplies this string.</td></tr><tr><td><a name="924987"> </a><code>irqType</code> </td><td><a name="924989"> </a>IRQ line being used for this hardware. Specify one of the <code>DrvrIRQEnum</code> values. For a virtual driver, specify <code>drvrIRQNone</code>.</td></tr><tr><td><a name="929340"> </a><code>reserved</code> </td><td><a name="929342"> </a>Reserved for future use. </td></tr></table><table><tr><td></table></div></p><a name="924992"> </a><h3> DrvrRcvQType</h3><dl><a name="924994"> </a><p></p><dt>The <code>DrvrRcvQType</code> structure defines the virtual driver receive buffer and function pointers to functions that access and save data to the buffer. A pointer to this structure is passed to the <code><a href="SerialDriver.html#925926"></code>VdrvOpen<code></a></code> function. The <code>DrvrHWRcvQPtr</code> type defines a pointer to a <code>DrvrRcvQType</code> structure.</dl><a name="924998"> </a><hr><code>typedef struct DrvrRcvQType {</code><br><a name="924999"> </a><code>void&nbsp;*rcvQ;</code><br><a name="925000"> </a><code>WriteByteProcPtr qWriteByte;</code><br><a name="925001"> </a><code>WriteBlockProcPtr qWriteBlock;</code><br><a name="925002"> </a><code>GetSizeProcPtr qGetSize;</code><br><a name="925003"> </a><code>GetSpaceProcPtr qGetSpace;</code><br><a name="925004"> </a><code>} DrvrRcvQType;</code><br><a name="925005"> </a><code></code><br><a name="925006"> </a><code>typedef DrvrRcvQType *DrvrHWRcvQPtr;</code><br><hr><br><a name="925007"> </a><h4> Value Descriptions</h4><p><a name="925041"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925010"> </a><code>rcvQ</code> </td><td><a name="925012"> </a>Pointer to the receive buffer.</td></tr><tr><td><a name="925014"> </a><code>qWriteByte</code> </td><td><a name="925016"> </a>Function pointer to a function that the virtual driver can use to write one byte to the new serial manager's receive queue. See the <code><a href="SerialDriver.html#926068"></code>WriteByte<code></a></code> function.</td></tr><tr><td><a name="925021"> </a><code>qWriteBlock</code> </td><td><a name="925023"> </a>Function pointer to a function that the virtual driver can use to write a block of bytes to the new serial manager's receive queue. See the <code><a href="SerialDriver.html#926040"></code>WriteBlock<code></a></code> function.</td></tr><tr><td><a name="925028"> </a><code>qGetSize</code> </td><td><a name="925030"> </a>Function pointer to a function that the virtual driver can use to get the total size of the new serial manager's receive queue. See the <code><a href="SerialDriver.html#926004"></code>GetSize<code></a></code> function.</td></tr><tr><td><a name="925035"> </a><code>qGetSpace</code> </td><td><a name="925037"> </a>Function pointer to a function that the virtual driver can use to get the available space in the new serial manager's receive queue. See the <code><a href="SerialDriver.html#926022"></code>GetSpace<code></a></code> function.</td></tr></table><table><tr><td></table></div></p><a name="925043"> </a><h3> DrvrStatusEnum</h3><dl><a name="925045"> </a><p></p><dt>The <code>DdrvStatusEnum</code> enumerated type specifies serial status bit flags. Return these enumerated types from the <code><a href="SerialDriver.html#925726"></code>SdrvStatus<code></a></code> and <code><a href="SerialDriver.html#925954"></code>VdrvStatus<code></a></code> calls.</dl><a name="925052"> </a><hr><code>typedef enum DrvrStatusEnum {</code><br><a name="925053"> </a><code>drvrStatusCtsOn = 0x0001,</code><br><a name="925054"> </a><code>drvrStatusRtsOn = 0x0002,</code><br><a name="925055"> </a><code>drvrStatusDsrOn = 0x0004,</code><br><a name="925056"> </a><code>drvrStatusTxFifoFull = 0x0008,</code><br><a name="925057"> </a><code>drvrStatusTxFifoEmpty = 0x0010,</code><br><a name="925058"> </a><code>drvrStatusBreakAsserted = 0x0020,</code><br><a name="925059"> </a><code>drvrStatusDataReady = 0x0040, // For polling mode debugger only</code><br><a name="925060"> </a><code>drvrStatusLineErr = 0x0080 // For polling mode debugger only</code><br><a name="925061"> </a><code>} DrvrStatusEnum;	 </code><br><hr><br><a name="925062"> </a><h4> Value Descriptions</h4><p><a name="925096"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925065"> </a><code>drvrStatusCtsOn</code> </td><td><a name="925067"> </a>Set if CTS line is active.</td></tr><tr><td><a name="925069"> </a><code>drvrStatusRtsOn</code> </td><td><a name="925071"> </a>Set if RTS line is active.</td></tr><tr><td><a name="925073"> </a><code>drvrStatusDsrOn</code> </td><td><a name="925075"> </a>Set if DSR is on.</td></tr><tr><td><a name="925077"> </a><code>drvrStatusTxFifoFull</code> </td><td><a name="925079"> </a>Set if transmit FIFO is full; cleared if FIFO has space.</td></tr><tr><td><a name="925081"> </a><code>drvrStatusTxFifoEmpty</code> </td><td><a name="925083"> </a>Set if transmit FIFO is empty.</td></tr><tr><td><a name="925085"> </a><code>drvrStatusBreakAsserted</code> </td><td><a name="925087"> </a>Set if sending break characters is enabled.</td></tr><tr><td><a name="925089"> </a><code>drvrStatusDataReady</code> </td><td><a name="925091"> </a>Used by debugger only.</td></tr><tr><td><a name="925093"> </a><code>drvrStatusLineErr</code> </td><td><a name="925095"> </a>Used by debugger only.</td></tr></table><table><tr><td></table></div></p><a name="925098"> </a><h3> SdrvAPIType</h3><dl><a name="925100"> </a><p></p><dt>The <code>SdrvAPIType</code> structure defines the function pointers to the required serial driver functions. When passed a pointer to this structure in the <code><a href="SerialDriver.html#925490"></code>DrvEntryPoint<code></a></code> function, that function must fill in the pointers to the serial driver functions appropriately.</dl><a name="925104"> </a><hr><code>typedef struct {</code><br><a name="925105"> </a><code>SdrvOpenProcPtr drvOpen;</code><br><a name="925106"> </a><code>SdrvCloseProcPtr drvClose;</code><br><a name="925107"> </a><code>SdrvControlProcPtr drvControl;</code><br><a name="925108"> </a><code>SdrvStatusProcPtr drvStatus;</code><br><a name="925109"> </a><code>SdrvReadCharProcPtr drvReadChar;</code><br><a name="925110"> </a><code>SdrvWriteCharProcPtr drvWriteChar;</code><br><a name="925111"> </a><code>} SdrvAPIType;</code><br><hr><br><a name="925112"> </a><h4> Value Descriptions</h4><p><a name="925138"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925115"> </a><code>drvOpen</code> </td><td><a name="925117"> </a>Pointer to the driver open function.</td></tr><tr><td><a name="925119"> </a><code>drvClose</code> </td><td><a name="925121"> </a>Pointer to the driver close function.</td></tr><tr><td><a name="925123"> </a><code>drvControl</code> </td><td><a name="925125"> </a>Pointer to the driver control function.</td></tr><tr><td><a name="925127"> </a><code>drvStatus</code> </td><td><a name="925129"> </a>Pointer to the driver status function.</td></tr><tr><td><a name="925131"> </a><code>drvReadChar</code> </td><td><a name="925133"> </a>Pointer to the driver read character function.</td></tr><tr><td><a name="925135"> </a><code>drvWriteChar</code> </td><td><a name="925137"> </a>Pointer to the driver write character function.</td></tr></table><table><tr><td></table></div></p><a name="925140"> </a><h3> SdrvCtlOpCodeEnum</h3><dl><a name="925142"> </a><p></p><dt>The <code>SdrvCtlOpCodeEnum</code> enumerated type specifies a serial control operation. You should handle each of these enumerated types when passed for the <code>controlCode</code> parameter to the <code><a href="SerialDriver.html#925554"></code>SdrvControl<code></a></code> call.</dl><a name="925146"> </a><hr><code>typedef enum SdrvCtlOpCodeEnum {</code><br><a name="925147"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeNoOp = 0, </code><br><a name="925148"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeSetBaudRate = 0x1000,</code><br><a name="925149"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeSetSettingsFlags,</code><br><a name="925150"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeClearErr,</code><br><a name="925151"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeEnableUART,</code><br><a name="925152"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeDisableUART,</code><br><a name="925153"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeEnableUARTInterrupts,</code><br><a name="925154"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeDisableUARTInterrupts,</code><br><a name="925155"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeSetSleepMode,</code><br><a name="925156"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeSetWakeupMode,</code><br><a name="925157"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeRxEnable,</code><br><a name="925158"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeRxDisable,</code><br><a name="925159"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeLineEnable,</code><br><a name="925160"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeFIFOCount,</code><br><a name="925161"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeEnableIRDA,</code><br><a name="925162"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeDisableIRDA,</code><br><a name="925163"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeStartBreak,</code><br><a name="925164"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeStopBreak,</code><br><a name="925165"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeStartLoopback,</code><br><a name="925166"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeStopLoopback,</code><br><a name="925167"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeFlushTxFIFO,</code><br><a name="925168"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeFlushRxFIFO,</code><br><a name="925169"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeGetOptTransmitSize,</code><br><a name="925170"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeEnableRTS,</code><br><a name="925171"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeDisableRTS,</code><br><a name="925172"> </a><code>&nbsp&nbsp&nbsp sdrvOpCodeUserDef = 0x2000</code><br><a name="925173"> </a><code>} SdrvCtlOpCodeEnum;</code><br><hr><br><a name="925174"> </a><h4> Value Descriptions</h4><p><a name="925282"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925177"> </a><code>sdvrOpCodeSetBaudRate</code> </td><td><a name="925179"> </a>Sets the baud rate for the UART.</td></tr><tr><td><a name="925181"> </a><code>sdvrOpCodeSetSettingsFlags</code> </td><td><a name="925183"> </a>Sets the data transmission options. The bit flags are described in <a href="NewSerialManager.html#925130">Serial Settings Constants</a>.</td></tr><tr><td><a name="925188"> </a><code>sdvrOpCodeClearError</code> </td><td><a name="925190"> </a>Clears the hardware error state.</td></tr><tr><td><a name="925192"> </a><code>sdvrOpCodeEnableUart</code> </td><td><a name="925194"> </a>Powers-up the UART and the line-drivers.</td></tr><tr><td><a name="925196"> </a><code>sdvrOpCodeDisableUART</code> </td><td><a name="925198"> </a>Powers-down the UART and the line drivers.</td></tr><tr><td><a name="925200"> </a><code>sdvrOpCodeEnableUARTInterrupts</code> </td><td><a name="925202"> </a>Enables the appropriate UART receive interrupts.</td></tr><tr><td><a name="925204"> </a><code>sdvrOpCodeDisableUARTInterrupt</code> s</td><td><a name="925206"> </a>Disables all UART interrupts.</td></tr><tr><td><a name="925208"> </a><code>sdvrOpCodeSetSleepMode</code> </td><td><a name="925210"> </a>Puts the UART in sleep mode.</td></tr><tr><td><a name="925212"> </a><code>sdvrOpCodeSetWakeupMode</code> </td><td><a name="925214"> </a>Wakes up the UART from sleep mode.</td></tr><tr><td><a name="925216"> </a><code>sdvrOpCodeRxEnable</code> </td><td><a name="925218"> </a>Enables the receive FIFO, enables UART interrupts, and does whatever else is necessary to allow the UART to receive data.</td></tr><tr><td><a name="925220"> </a><code>sdvrOpCodeRxDisable</code> </td><td><a name="925222"> </a>Disables the receive FIFO and UART interrupts and does whatever is needed to prevent the UART from receiving data.</td></tr><tr><td><a name="925224"> </a><code>sdvrOpCodeLineEnable</code> </td><td><a name="925226"> </a>Enables the main serial line driver for the UART.</td></tr><tr><td><a name="925228"> </a><code>sdvrOpCodeFIFOCount</code> </td><td><a name="925230"> </a>Returns the number of bytes currently in the FIFO (or best estimate). </td></tr><tr><td><a name="925232"> </a><code>sdvrOpCodeEnableIRDA</code> </td><td><a name="925234"> </a>Enable the IRDA mode and power up the IR line drivers.</td></tr><tr><td><a name="925236"> </a><code>sdvrOpCodeDisableIRDA</code> </td><td><a name="925238"> </a>Disable the IRDA mode and disable the IR line drivers.</td></tr><tr><td><a name="925240"> </a><code>sdvrOpCodeStartBreak</code> </td><td><a name="925242"> </a>Sends a break character or enables the sending of break characters.</td></tr><tr><td><a name="925244"> </a><code>sdvrOpCodeStopBreak</code> </td><td><a name="925246"> </a>Stops sending break characters.</td></tr><tr><td><a name="925248"> </a><code>sdvrOpCodeStartLoopback</code> </td><td><a name="925250"> </a>Places the UART in loopback mode.</td></tr><tr><td><a name="925252"> </a><code>sdvrOpCodeStopLoopback</code> </td><td><a name="925254"> </a>Stops loopback mode.</td></tr><tr><td><a name="925256"> </a><code>SdrvOpCodeFlushTxFIFO</code> </td><td><a name="925258"> </a>Flushes the contents of the transmit FIFO.</td></tr><tr><td><a name="925260"> </a><code>sdrvOpCodeFlushRxFIFO</code> </td><td><a name="925262"> </a>Flushes the contents of the receive FIFO.</td></tr><tr><td><a name="925264"> </a><code>sdrvOpCodeGetOptTransmitSize</code> </td><td><a name="925266"> </a>Returns the optimum buffer size for sending data or returns 0 to specify any buffer size is acceptable.</td></tr><tr><td><a name="925268"> </a><code>sdrvOpCodeEnableRTS</code> </td><td><a name="925270"> </a>Asserts the RTS line.</td></tr><tr><td><a name="925272"> </a><code>sdrvOpCodeDisableRTS</code> </td><td><a name="925274"> </a>Deasserts the RTS line.</td></tr><tr><td><a name="925276"> </a><code>sdvrOpCodeUserDef</code> </td><td><a name="925278"> </a>User defined function invoked via <code><a href="NewSerialManager.html#925280"></code>SrmControl<code></a></code>.</td></tr></table><table><tr><td></table></div></p><a name="925284"> </a><h3> VdrvAPIType</h3><dl><a name="925286"> </a><p></p><dt>The <code>VdrvAPIType</code> structure defines function pointers to the required virtual driver functions. When passed a pointer to this structure in the <code><a href="SerialDriver.html#925773"></code>DrvEntryPoint<code></a></code> function, that function must fill in the pointers to the virtual driver functions appropriately.</dl><a name="925290"> </a><hr><code>typedef struct {</code><br><a name="925291"> </a><code>VdrvOpenProcPtr drvOpen;</code><br><a name="925292"> </a><code>VdrvCloseProcPtr drvClose;</code><br><a name="925293"> </a><code>VdrvControlProcPtr drvControl;</code><br><a name="925294"> </a><code>VdrvStatusProcPtr drvStatus;</code><br><a name="925295"> </a><code>VdrvReadProcPtr drvRead;</code><br><a name="925296"> </a><code>VdrvWriteProcPtr drvWrite;</code><br><a name="925297"> </a><code>} VdrvAPIType;</code><br><hr><br><a name="925298"> </a><h4> Value Descriptions</h4><p><a name="925324"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925301"> </a><code>drvOpen</code> </td><td><a name="925303"> </a>Pointer to the driver open function.</td></tr><tr><td><a name="925305"> </a><code>drvClose</code> </td><td><a name="925307"> </a>Pointer to the driver close function.</td></tr><tr><td><a name="925309"> </a><code>drvControl</code> </td><td><a name="925311"> </a>Pointer to the driver control function.</td></tr><tr><td><a name="925313"> </a><code>drvStatus</code> </td><td><a name="925315"> </a>Pointer to the driver status function.</td></tr><tr><td><a name="925317"> </a><code>drvRead</code> </td><td><a name="925319"> </a>Pointer to the driver read function.</td></tr><tr><td><a name="925321"> </a><code>drvWrite</code> </td><td><a name="925323"> </a>Pointer to the driver write function.</td></tr></table><table><tr><td></table></div></p><a name="925326"> </a><h3> VdrvCtlOpCodeEnum</h3><dl><a name="925328"> </a><p></p><dt>The <code>VdrvCtlOpCodeEnum</code> enumerated type specifies a serial control operation. You should handle each of these enumerated types when passed for the <code>controlCode</code> parameter to the <code><a href="SerialDriver.html#925835"></code>VdrvControl<code></a></code> call.</dl><a name="925332"> </a><hr><code>typedef enum VdrvCtlOpCodeEnum {</code><br><a name="925333"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeNoOp = 0, </code><br><a name="925334"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeSetBaudRate = 0x1000,</code><br><a name="925335"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeSetSettingsFlags,</code><br><a name="925336"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeSetCtsTimeout,</code><br><a name="925337"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeClearErr,</code><br><a name="925338"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeSetSleepMode,</code><br><a name="925339"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeSetWakeupMode,</code><br><a name="925340"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeFIFOCount,</code><br><a name="925341"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeStartBreak,</code><br><a name="925342"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeStopBreak,</code><br><a name="925343"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeStartLoopback,</code><br><a name="925344"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeStopLoopback,</code><br><a name="925345"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeFlushTxFIFO,</code><br><a name="925346"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeFlushRxFIFO,</code><br><a name="925347"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeSendBufferedData,</code><br><a name="925348"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeRcvCheckIdle,</code><br><a name="925349"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeEmuSetBlockingHook,</code><br><a name="925350"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeGetOptTransmitSize,</code><br><a name="925351"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeGetMaxRcvBlockSize,</code><br><a name="925352"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeNotifyBytesReadFromQ,</code><br><a name="925353"> </a><code>&nbsp&nbsp&nbsp vdrvOpCodeUserDef = 0x2000</code><br><a name="925354"> </a><code>} VdrvCtlOpCodeEnum;</code><br><hr><br><a name="925355"> </a><h4> Value Descriptions</h4><p><a name="925443"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925358"> </a><code>vdvrOpCodeSetBaudRate</code> </td><td><a name="925360"> </a>Sets the baud rate.</td></tr><tr><td><a name="925362"> </a><code>vdvrOpCodeSetSettingsFlags</code> </td><td><a name="925364"> </a>Sets the data transmission options. The bit flags are described in <a href="NewSerialManager.html#925130">Serial Settings Constants</a>.</td></tr><tr><td><a name="925369"> </a><code>vdrvOpCodeSetCtsTimeout</code> </td><td><a name="925371"> </a>Hardware handshake timeout.</td></tr><tr><td><a name="925373"> </a><code>vdvrOpCodeClearError</code> </td><td><a name="925375"> </a>Clears the hardware error state.</td></tr><tr><td><a name="925377"> </a><code>vdvrOpCodeSetSleepMode</code> </td><td><a name="925379"> </a>Puts the port in sleep mode (not typically used for virtual drivers).</td></tr><tr><td><a name="925381"> </a><code>vdvrOpCodeSetWakeupMode</code> </td><td><a name="925383"> </a>Wakes up the port from sleep mode (not typically used for virtual drivers).</td></tr><tr><td><a name="925385"> </a><code>vdvrOpCodeFIFOCount</code> </td><td><a name="925387"> </a>Returns the number of bytes currently in the FIFO (or best estimate). </td></tr><tr><td><a name="925389"> </a><code>vdvrOpCodeStartBreak</code> </td><td><a name="925391"> </a>Sends a break character or enables the sending of break characters.</td></tr><tr><td><a name="925393"> </a><code>vdvrOpCodeStopBreak</code> </td><td><a name="925395"> </a>Stops sending break characters.</td></tr><tr><td><a name="925397"> </a><code>vdvrOpCodeStartLoopback</code> </td><td><a name="925399"> </a>Starts loopback mode (not typically used for virtual drivers).</td></tr><tr><td><a name="925401"> </a><code>vdvrOpCodeStopLoopback</code> </td><td><a name="925403"> </a>Stops loopback mode (not typically used for virtual drivers).</td></tr><tr><td><a name="925405"> </a><code>vdrvOpCodeFlushTxFIFO</code> </td><td><a name="925407"> </a>Flushes the contents of the transmit FIFO.</td></tr><tr><td><a name="925409"> </a><code>vdrvOpCodeFlushRxFIFO</code> </td><td><a name="925411"> </a>Flushes the contents of the receive FIFO.</td></tr><tr><td><a name="925413"> </a><code>vdrvOpCodeSendBufferedData</code> </td><td><a name="925415"> </a>Notifies virtual device to send any buffered data it has not emptied from its internal buffers.</td></tr><tr><td><a name="925417"> </a><code>vdrvOpCodeRcvCheckIdle</code> </td><td><a name="925419"> </a>Called periodically to allow virtual device time to check if there is data to be received. Because virtual devices execute in the same thread as applications, they can be prevented from handling notifications of received data.</td></tr><tr><td><a name="925421"> </a><code>vdrvOpCodeEmuSetBlockingHook</code> </td><td><a name="925423"> </a>Special opCode for the Simulator.</td></tr><tr><td><a name="925425"> </a><code>vdrvOpCodeGetOptTransmitSize</code> </td><td><a name="925427"> </a>Returns the optimum buffer size for sending data or returns 0 to specify any buffer size is acceptable.</td></tr><tr><td><a name="925429"> </a><code>vdrvOpCodeGetMaxRcvBlockSize</code> </td><td><a name="925431"> </a>Returns the maximum receive block size that the serial manager should request from the virtual device. Can be used to implement flow control.</td></tr><tr><td><a name="925433"> </a><code>vdrvOpCodeNotifyBytesReadFromQ</code> </td><td><a name="925435"> </a>Tells the virtual device that some number of bytes have been read from the receive queue by the client application. Can be used to implement flow control.</td></tr><tr><td><a name="925437"> </a><code>vdvrOpCodeUserDef</code> </td><td><a name="925439"> </a>User defined function invoked via <code><a href="NewSerialManager.html#925280"></code>SrmControl<code></a></code>.</td></tr></table><table><tr><td></table></div></p><a name="925445"> </a><h2> Driver Constants</h2><a name="925448"> </a><h3> Port Feature Constants</h3><dl><a name="925449"> </a><p></p><dt>These flag constants describe serial hardware capabilities.<p><a name="925483"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925452"> </a><code>portPhysicalPort</code> </td><td><a name="925454"> </a>Should be set for a physical port, unset for a virtual port</td></tr><tr><td><a name="925456"> </a><code>portRS232Capable</code> </td><td><a name="925458"> </a>Set if this hardware has a RS-232 port</td></tr><tr><td><a name="925460"> </a><code>portIRDACapable</code> </td><td><a name="925462"> </a>Set if this hardware has an IR port and supports IRDA mode</td></tr><tr><td><a name="925464"> </a><code>portCradlePort</code> </td><td><a name="925466"> </a>Set if this hardware controls the cradle port</td></tr><tr><td><a name="925468"> </a><code>portExternalPort</code> </td><td><a name="925470"> </a>Set if this hardware port is external or on a memory card</td></tr><tr><td><a name="925472"> </a><code>portModemPort</code> </td><td><a name="925474"> </a>Set if this hardware communicates with a modem</td></tr><tr><td><a name="925476"> </a><code>portCncMgrVisible</code> </td><td><a name="925478"> </a>Set if this serial port's name is to be displayed in the Connection panel</td></tr><tr><td><a name="925480"> </a><code>portPrivateUse</code> </td><td><a name="925482"> </a>Set if this driver is for special software and not general applications.</td></tr></table><table><tr><td></table></div></p></dl><a name="925485"> </a><h2> Serial Driver-Defined Functions</h2><dl><a name="925487"> </a><p></p><dt>The functions in this section must be defined by your serial driver.</dl><a name="925490"> </a><br> <br> <br><h3> DrvEntryPoint</h3><dl><dl><a name="925491"> </a><h4>Purpose </h4><dl><a name="925492"> </a><p></p><dt>Entry point for the serial driver.</dl><a name="925493"> </a><h4>Prototype </h4><dl><a name="925494"> </a><dt><code>Err DrvEntryPoint(DrvrEntryOpCodeEnum&nbsp;opCode, void&nbsp;*&nbsp;uartData)</code></dl></dl><dl><a name="925495"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925496"> </a><CODE>-&gt; <code>opCode</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Entry function code.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925497"> </a><CODE>&lt;-&gt; <code>uartData</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to data specific to the opCode.<br></TD></TR></TABLE></dl><dl><a name="925498"> </a><h4>Result </h4><p><a name="925508"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925501"> </a>0</td><td><a name="925503"> </a>No error.</td></tr><tr><td><a name="925505"> </a>-1</td><td><a name="925507"> </a>The opCode is invalid or the hardware could not be found.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925509"> </a><h4>Comments </h4><dl><a name="925510"> </a><p></p><dt>This functions serves a dual purpose based on the value of the <code>opCode</code> parameter. The two possible codes are <code>drvrEntryGetUartFeatures</code> and <code>drvrEntryGetDrvrFuncts</code>.<a name="925511"> </a><p></p><dt><code>DrvEntryPoint</code> is called with the <code>drvrEntryGetUartFeatures</code> code when the new serial manager is installed into the system at boot time and is looking for all UART hardware currently connected to the device. When this opCode is set, the <code>uartData</code> pointer points to a <code><a href="SerialDriver.html#924939"></code>DrvrInfoType<code></a></code> structure. This function does not allocate the structure, it just fills in the fields with information.<a name="925515"> </a><p></p><dt>This function should check to make sure the hardware exists in the current system. If the hardware cannot be found, the function should leave the <code>DrvrInfoType</code> struct untouched and return a -1 error.<a name="925516"> </a><p></p><dt>The driver needs to supply a string that describes the port it manages. This string is displayed to the user in the Connection panel and is returned by the <code><a href="NewSerialManager.html#925447"></code>SrmGetDeviceInfo<code></a></code> function. To set this string, copy it into the <code>portDesc</code> field of the <code>DrvrInfoType</code> structure. Alternatively, you can supply this string in a driver resource of type 'tSTR' and id <code>kPortDescStrID</code>.<a name="925520"> </a><p></p><dt><code>DrvEntryPoint</code> is called with the <code>drvrEntryGetDrvrFuncts</code> code when a serial port is opened. The <code>uartData</code> pointer points to a <code><a href="SerialDriver.html#925098"></code>SdrvAPIType<code></a></code> structure and <code>DrvEntryPoint</code> must fill in the fields of this structure with appropriate function pointers.</dl><a name="925524"> </a><h4>Compatibility </h4><dl><a name="925528"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925531"> </a><br> <br> <br><h3> SdrvClose</h3><dl><dl><a name="925532"> </a><h4>Purpose </h4><dl><a name="925533"> </a><p></p><dt>Handles all activities needed to power-down the UART.</dl><a name="925534"> </a><h4>Prototype </h4><dl><a name="925535"> </a><dt><code>Err SdrvClose(SdrvDataPtr&nbsp;drvrDataP)</code></dl></dl><dl><a name="925536"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925537"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE></dl><dl><a name="925538"> </a><h4>Result </h4><p><a name="925544"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925541"> </a>0</td><td><a name="925543"> </a>No error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925545"> </a><h4>Comments </h4><dl><a name="925546"> </a><p></p><dt>This function should disable all UART interrupts for the Dragonball processor as well as for the UART, place the UART in sleep mode, power down the transceiver, and do whatever other necessary tasks there may be. Additionally, this function should remove the interrupt handler installed by <code>SdrvOpen</code>.</dl><a name="925547"> </a><h4>Compatibility </h4><dl><a name="925551"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925554"> </a><br> <br> <br><h3> SdrvControl</h3><dl><dl><a name="925555"> </a><h4>Purpose </h4><dl><a name="925556"> </a><p></p><dt>Extends the <code>SrmControl</code> function to the level of the hardware.</dl><a name="925557"> </a><h4>Prototype </h4><dl><a name="925558"> </a><dt><code>Err *SdrvControl(SdrvDataPtr&nbsp;drvrDataP, SdrvCtlOpCodeEnum&nbsp;controlCode, void&nbsp;*&nbsp;controlDataP, UInt16&nbsp;*&nbsp;controlDataLenP)</code></dl></dl><dl><a name="925559"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925560"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925561"> </a><CODE>-&gt; <code>controlCode</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Control function opCode. One of the opCodes listed in the <code><a href="SerialDriver.html#925140"></code>SdrvCtlOpCodeEnum<code></a></code> type.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925565"> </a><CODE>&lt;-&gt; <code>controlDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to data for the specified control function.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925566"> </a><CODE>&lt;-&gt; <code>controlDataLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to length of control data being passed in or out.<br></TD></TR></TABLE></dl><dl><a name="925567"> </a><h4>Result </h4><p><a name="925581"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925570"> </a>0</td><td><a name="925572"> </a>No error.</td></tr><tr><td><a name="925574"> </a><code>serErrNotSupported</code></td><td><a name="925576"> </a><code>controlCode</code> not supported.</td></tr><tr><td><a name="925578"> </a><code>serErrBadParam</code></td><td><a name="925580"> </a><code>controlDataP</code> or <code>controlDataLenP</code> is bad.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925582"> </a><h4>Comments </h4><dl><a name="925583"> </a><p></p><dt>This function should support the opCodes listed in the <code><a href="SerialDriver.html#925140"></code>SdrvCtlOpCodeEnum<code></a></code> type. If this function does not support an opCode, it must return the <code>serErrNotSupported</code> error code for that opCode.<a name="925590"> </a><p></p><dt><a href="SerialDriver.html#926787">Table 59.1</a> shows what is passed for the <code>controlDataP</code> and <code>controlDataLenP</code> parameters for each of the control codes that use them. Control codes not listed do not use these parameters.<p><a name="925626"> </a> </p><p><div> <table border="3"><caption><B><a name="926787"> </a><h4>Table 59.1	 SdrvControl Parameters&nbsp;</h4></B></caption><tr><td><a name="925595"> </a><code>sdvrOpCodeSetBaudRate</code> </td><td><a name="925597"> </a>-&gt; <code>controlDataP</code> = Pointer to <code>Int32</code> (baud rate), <a name="925598"> </a>-&gt; <code>controlDataLenP</code> = Pointer to <code>sizeof(Int32)</code>.</td></tr><tr><td><a name="925600"> </a><code>sdvrOpCodeSetSettingsFlags</code> </td><td><a name="925602"> </a>-&gt; controlDataP = Pointer to <code>UInt32</code> (bitfield; see <a href="NewSerialManager.html#925130">Serial Settings Constants</a>)<a name="925606"> </a>-&gt; controlDataLenP = Pointer to <code>sizeof(UInt32)</code> </td></tr><tr><td><a name="925608"> </a><code>sdvrOpCodeFIFOCount</code> </td><td><a name="925610"> </a>-&gt; controlDataP = Pointer to <code>Int16</code>, which contains the number of bytes in the FIFO. <a name="925611"> </a>-&gt; controlDataLenP = Pointer to <code>sizeof(Int16)</code>.</td></tr><tr><td><a name="925613"> </a><code>sdrvOpCodeGetOptTransmitSize</code> </td><td><a name="925615"> </a>&lt;- controlDataP = Pointer to <code>Int32</code>, <a name="925616"> </a>&lt;- controlDataLenP = Pointer to <code>sizeof(Int32)</code>.<a name="925617"> </a>Return the optimum buffer size for sending data, or 0 to specify any buffer size is acceptable.</td></tr><tr><td><a name="925619"> </a><code>sdvrOpCodeUserDef</code> </td><td><a name="925621"> </a>&lt;-&gt; <code>controlDataP</code> = Pointer from <code><a href="NewSerialManager.html#925280"></code>SrmControl<code></a></code> (user-defined data), <a name="925625"> </a>&lt;-&gt; <code>controlDataLenP</code> = Pointer to <code>sizeof(Int32)</code>.</td></tr></table><table><tr><td></table></div></p></dl><a name="925627"> </a><h4>Compatibility </h4><dl><a name="925631"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925634"> </a><br> <br> <br><h3> SdrvISP</h3><dl><dl><a name="925635"> </a><h4>Purpose </h4><dl><a name="925636"> </a><p></p><dt>An interrupt service routine called when a hardware interrupt is generated on the IRQ line associated with the serial hardware.</dl><a name="925637"> </a><h4>Prototype </h4><dl><a name="925638"> </a><dt><code>asm Boolean SdrvISP(UInt32 param: __A0):__D0</code></dl></dl><dl><a name="925639"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925640"> </a><CODE>A0 = <code>param</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE></dl><dl><a name="925641"> </a><h4>Result </h4><dl><a name="925642"> </a><p></p><dt>D0 returns a Boolean value. Return <code>true</code> if this UART has data that needs to be read; return <code>false</code> if no other interrupt service is needed.</dl></dl><dl><a name="925643"> </a><h4>Comments </h4><dl><a name="925644"> </a><p></p><dt>This function can retrieve its globals from the low-memory global they were saved in (via the pointer in A0) and then must determine if the interrupt is for this particular serial hardware. If so, it must call the <code>saveDataProc</code> function (passed into <code><a href="SerialDriver.html#925664"></code>SdrvOpen<code></a></code>) with the portP pointer as the parameter. The <code>saveDataProc</code> function, supplied by the new serial manager, handles reading the data from the UART by calling the <code><a href="SerialDriver.html#925706"></code>SdrvReadChar<code></a></code> function.<a name="925651"> </a><p></p><dt>The <code>SdrvISP</code> function must be installed in the appropriate IRQ handler by the <code>SdrvOpen</code> routine.</dl><a name="925652"> </a><h4>Compatibility </h4><dl><a name="925656"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925657"> </a><h4>See Also </h4><dl><a name="925661"> </a><p></p><dt><code><a href="SerialDriver.html#925664"></code>SdrvOpen<code></a></code></dl></dl></dl><a name="925664"> </a><br> <br> <br><h3> SdrvOpen</h3><dl><dl><a name="925665"> </a><h4>Purpose </h4><dl><a name="925666"> </a><p></p><dt>Initializes the serial hardware to send and receive data.</dl><a name="925667"> </a><h4>Prototype </h4><dl><a name="925668"> </a><dt><code>Err SdrvOpen(SdrvDataPtr*&nbsp;drvrDataP, UInt32&nbsp;baudRate, void&nbsp;*&nbsp;portP, SerialMgrISPProcPtr&nbsp;saveDataProc)</code></dl></dl><dl><a name="925669"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925670"> </a><CODE>&lt;-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a pointer to the driver's private global area (allocated by this function).<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925671"> </a><CODE>-&gt; <code>baudRate</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Initial baud rate setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925672"> </a><CODE>-&gt; <code>portP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the open port data.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925673"> </a><CODE>-&gt; <code>saveDataProc</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the function where data received by interrupt is to be saved. The typedef for this function is shown in the Comments section.<br></TD></TR></TABLE></dl><dl><a name="925674"> </a><h4>Result </h4><p><a name="925680"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925677"> </a>0</td><td><a name="925679"> </a>No error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925681"> </a><h4>Comments </h4><dl><a name="925682"> </a><p></p><dt>Here is the typedef for the <code>saveDataProc</code> function:</dl></dl><dl><a name="925683"> </a><br><code><code>typedef void (*SerialMgrISPProcPtr)(void&nbsp;* portP:__A0)</code></code><br><dl><a name="925684"> </a><p></p><dt>To accomplish serial hardware initialization, <code>SdrvOpen</code> must perform the following tasks:<ul type="SQUARE"><a name="925685"> </a><br><li>Allocate global data needed by the driver. There is a low memory global (<code>GIrq</code><em>N</em><code>GlobalsP</code>) for every IRQ line in the system. At open time, a serial driver must save its global data in this low memory global because when the interrupt is called there is no way to get the globals through the driver data parameter that the serial manager normally supplies.<br><a name="925686"> </a><br><li>Save the <code>portP</code> and <code>saveDataProc</code> parameters passed to <code>SdrvOpen</code> in the global variable structure, because they are needed when the <code>SdrvISP</code> function is called. When the interrupt routine subsequently gets called, the driver gets access to the low memory globals which contain the <code>saveDataProc</code> function and the <code>portP</code> pointer. This pointer is passed into the new serial manager, which then calls the driver <code>SdrvReadChar</code> function in order to read all the bytes and fill its queue.<br><a name="925687"> </a><br><li>Save the pointer to the globals in the appropriate low memory global variable for the IRQ line the device is using (for example, a device which uses IRQ3 would use the <code>GIrq3GlobalsP</code>). You can find the IRQ global variables defined in the header file <code>globals.h</code>.<br><a name="925688"> </a><br><li>Save the pointer to the globals in the <code>drvrDataP</code> parameter passed into the <code>SdrvOpen</code> function. This private global data pointer is passed to every serial driver function so they all have access to the global data.<br><a name="925689"> </a><br><li>Patch out the appropriate interrupt handler trap and replace it with the serial driver's ISP function (<code>SdrvISP</code>). For example, the system trap to be patched for IRQ3 is called <code>sysTrapHwrIRQ3Handler</code> (see <code>SysTraps.h</code>). Be sure to save the old interrupt handler to be re-installed when <code>DrvClose</code> is called. Here is an example of how to do this:<br></ul></dl><a name="925690"> </a><br><code>oldIntHandler = SysGetTrapAddress(sysTrapHwrIRQ3Handler);</code><br></dl><dl><a name="925691"> </a><code>SysSetTrapAddress(sysTrapHwrIRQ3Handler, SdrvISP);</code><br><dl><a name="925692"> </a><p></p><dt>If there is another serial device sharing the same IRQ line, you must tail-patch the IRQ handler rather than replace it. In other words, you must call the previously installed handler after your own handler executes.<ul type="SQUARE"><a name="925693"> </a><br><li>Set up and open the hardware to its default state.<br></ul></dl></dl><dl><a name="925694"> </a><h4>Compatibility </h4><dl><a name="925698"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925699"> </a><h4>See Also </h4><dl><a name="925703"> </a><p></p><dt><code><a href="SerialDriver.html#925634"></code>SdrvISP<code></a></code></dl></dl></dl><a name="925706"> </a><br> <br> <br><h3> SdrvReadChar</h3><dl><dl><a name="925707"> </a><h4>Purpose </h4><dl><a name="925708"> </a><p></p><dt>Reads a byte (if available) from the receive FIFO of the UART.</dl><a name="925709"> </a><h4>Prototype </h4><dl><a name="925710"> </a><dt><code>asm UInt16 SdrvReadChar(SdrvDataPtr drvrDataP:__A0):__D0</code></dl></dl><dl><a name="925711"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925712"> </a><CODE>A1 = <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE></dl><dl><a name="925713"> </a><h4>Result </h4><dl><a name="925714"> </a><p></p><dt>D0 returns an <code>Int16</code> value. The returned 16-bit word contains the data byte read from the hardware in the low-order byte. If there is an error, the error code is returned in the low-order byte and the error flag (<code>$80</code>) is set in the high-order byte.</dl></dl><dl><a name="925715"> </a><h4>Comments </h4><dl><a name="925716"> </a><p></p><dt>This function should be written in 68K assembly language for speed, but can be written in a higher-level language as long as the register usage for the parameters and return values is obeyed. If this function is too slow, hardware overruns may occur.<a name="925717"> </a><p></p><dt>This function is responsible for translating break, framing, parity, and overrun errors back to the calling function. If an error is received by the hardware, the high-order byte of the return value should be set to <code>$80</code> to mark the low-order byte as an error code and not a readable byte. The error code returned in the low-order byte of D0 should be translated into one of the following four serial manager error codes: <code>serLineErrorBreak</code>, <code>serLineErrorFraming</code>, <code>serLineErrorParity</code>, or <code>serLineErrorHWOverrun</code>.<a name="925718"> </a><p></p><dt><code>SdrvReadChar</code> executes during interrupt time, and cannot call any OS functions that are normally not allowed to be called during this time. All registers needed for this function should be saved onto the stack (except for D0). The A1 register must not be changed on exit.</dl><a name="925719"> </a><h4>Compatibility </h4><dl><a name="925723"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925726"> </a><br> <br> <br><h3> SdrvStatus</h3><dl><dl><a name="925727"> </a><h4>Purpose </h4><dl><a name="925728"> </a><p></p><dt>Returns UART status.</dl><a name="925729"> </a><h4>Prototype </h4><dl><a name="925730"> </a><dt><code>UInt16 SdrvStatus(SdrvDataPtr drvrDataP)</code></dl></dl><dl><a name="925731"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925732"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE></dl><dl><a name="925733"> </a><h4>Result </h4><dl><a name="925734"> </a><p></p><dt>An unsigned long bitfield denoting the status of the UART. The individual bit flags are described in the <code><a href="SerialDriver.html#925043"></code>DrvrStatusEnum<code></a></code> type.</dl></dl><dl><a name="925738"> </a><h4>Comments </h4><dl><a name="925739"> </a><p></p><dt>The <code>drvrStatusCtsOn</code> flag should be set if the UART's CTS line is active. The <code>drvrStatusRtsOn</code> flag should be set if the RTS line for the UART is currently high. The <code>drvrStatusDsrOn</code> flag should be set if DSR is turned on. Again, this may not be supported on all UARTs and should be set or cleared based on the type of hardware used. The <code>drvrStatusTxFifoFull</code> flag is set if the transmit FIFO for the hardware has no available space to receive more data and the flag should be cleared if the transmit FIFO does have available space. And the <code>drvrStatusBreakAsserted</code> flag should be set if the UART currently has sending break characters enabled.</dl><a name="925740"> </a><h4>Compatibility </h4><dl><a name="925744"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925747"> </a><br> <br> <br><h3> SdrvWriteChar</h3><dl><dl><a name="925748"> </a><h4>Purpose </h4><dl><a name="925749"> </a><p></p><dt>Writes a byte to the appropriate UART register for transmission.</dl><a name="925750"> </a><h4>Prototype </h4><dl><a name="925751"> </a><dt><code>Err SdrvWriteChar(SdrvDataPtr&nbsp;drvrDataP, UInt8&nbsp;aChar)</code></dl></dl><dl><a name="925752"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925753"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925754"> </a><CODE>-&gt; <code>aChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Byte of data to be written to the UART.<br></TD></TR></TABLE></dl><dl><a name="925755"> </a><h4>Result </h4><p><a name="925761"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925758"> </a>0</td><td><a name="925760"> </a>No error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925762"> </a><h4>Compatibility </h4><dl><a name="925766"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925768"> </a><h2> Virtual Driver-Defined Functions</h2><dl><a name="925770"> </a><p></p><dt>The functions in this section must be defined by your virtual driver.</dl><a name="925773"> </a><br> <br> <br><h3> DrvEntryPoint</h3><dl><dl><a name="925774"> </a><h4>Purpose </h4><dl><a name="925775"> </a><p></p><dt>Entry point for the virtual driver.</dl><a name="925776"> </a><h4>Prototype </h4><dl><a name="925777"> </a><dt><code>Err DrvEntryPoint(DrvrEntryOpCodeEnum&nbsp;opCode, void&nbsp;*&nbsp;uartData)</code></dl></dl><dl><a name="925778"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925779"> </a><CODE>-&gt; <code>opCode</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Entry function code.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925780"> </a><CODE>&lt;-&gt; <code>uartData</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to data specific to the opCode.<br></TD></TR></TABLE></dl><dl><a name="925781"> </a><h4>Result </h4><p><a name="925791"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925784"> </a>0</td><td><a name="925786"> </a>No error.</td></tr><tr><td><a name="925788"> </a>-1</td><td><a name="925790"> </a>The opCode is invalid or the hardware could not be found.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925792"> </a><h4>Comments </h4><dl><a name="925793"> </a><p></p><dt>This functions serves a dual purpose based on the value of the <code>opCode</code> parameter. The two possible codes are <code>drvrEntryGetUartFeatures</code> and <code>drvrEntryGetDrvrFuncts</code>.<a name="925794"> </a><p></p><dt><code>DrvEntryPoint</code> is called with the <code>drvrEntryGetUartFeatures</code> code when the new serial manager is installed into the system at boot time and is looking for all installed drivers. When this opCode is set, the <code>uartData</code> pointer points to a <code><a href="SerialDriver.html#924939"></code>DrvrInfoType<code></a></code> structure. This function does not allocate the structure, it just fills in the fields with information.<a name="925798"> </a><p></p><dt>This function should check to make sure the associated serial device can operate under the current OS and system settings. If the hardware cannot be found, the function should leave the <code>DrvrInfoType</code> struct untouched and return a -1 error.<a name="925799"> </a><p></p><dt>The driver needs to supply a string that describes the port it manages. This string is displayed to the user in the Connection panel and is returned by the <code><a href="NewSerialManager.html#925447"></code>SrmGetDeviceInfo<code></a></code> function. To set this string, copy it into the <code>portDesc</code> field of the <code>DrvrInfoType</code> structure. Alternatively, you can supply this string in a driver resource of type 'tSTR' and id <code>kPortDescStrID</code>.<a name="925803"> </a><p></p><dt><code>DrvEntryPoint</code> is called with the <code>drvrEntryGetDrvrFuncts</code> code when a virtual port is opened. The <code>uartData</code> pointer points to a <code><a href="SerialDriver.html#925284"></code>VdrvAPIType<code></a></code> structure and <code>DrvEntryPoint</code> must fill in the fields of this structure with appropriate function pointers.</dl><a name="925807"> </a><h4>Compatibility </h4><dl><a name="925811"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925814"> </a><br> <br> <br><h3> VdrvClose</h3><dl><dl><a name="925815"> </a><h4>Purpose </h4><dl><a name="925816"> </a><p></p><dt>Handles all activities needed to close the virtual device.</dl><a name="925817"> </a><h4>Prototype </h4><dl><a name="925818"> </a><dt><code>Err VdrvClose(VdrvDataPtr&nbsp;drvrDataP)</code></dl></dl><dl><a name="925819"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925820"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE></dl><dl><a name="925821"> </a><h4>Result </h4><p><a name="925827"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925824"> </a>0</td><td><a name="925826"> </a>No error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925828"> </a><h4>Compatibility </h4><dl><a name="925832"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925835"> </a><br> <br> <br><h3> VdrvControl</h3><dl><dl><a name="925836"> </a><h4>Purpose </h4><dl><a name="925837"> </a><p></p><dt>Extends the <code>SrmControl</code> function to the level of the virtual device.</dl><a name="925838"> </a><h4>Prototype </h4><dl><a name="925839"> </a><dt><code>Err *VdrvControl(VdrvDataPtr&nbsp;drvrDataP, VdrvCtlOpCodeEnum&nbsp;controlCode, void&nbsp;*&nbsp;controlDataP, UInt16&nbsp;*&nbsp;controlDataLenP)</code></dl></dl><dl><a name="925840"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925841"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925842"> </a><CODE>-&gt; <code>controlCode</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Control function opCode. One of the opCodes listed in the <code><a href="SerialDriver.html#925326"></code>VdrvCtlOpCodeEnum<code></a></code> type.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925846"> </a><CODE>&lt;-&gt; <code>controlDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to data for the specified control function.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925847"> </a><CODE>&lt;-&gt; <code>controlDataLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to length of control data being passed in or out.<br></TD></TR></TABLE></dl><dl><a name="925848"> </a><h4>Result </h4><p><a name="925862"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925851"> </a>0</td><td><a name="925853"> </a>No error.</td></tr><tr><td><a name="925855"> </a><code>serErrNotSupported</code></td><td><a name="925857"> </a><code>controlCode</code> not supported.</td></tr><tr><td><a name="925859"> </a><code>serErrBadParam</code></td><td><a name="925861"> </a><code>controlDataP</code> or <code>ControlDataLenP</code> is bad.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925863"> </a><h4>Comments </h4><dl><a name="925864"> </a><p></p><dt>This function should support the opCodes listed in the <code><a href="SerialDriver.html#925326"></code>VdrvCtlOpCodeEnum<code></a></code> type. If this function does not support an opCode, it must return the <code>serErrNotSupported</code> error code for that opCode.<a name="925871"> </a><p></p><dt><a href="SerialDriver.html#925873">Table 59.2</a> shows what is passed for the <code>controlDataP</code> and <code>controlDataLenP</code> parameters for each of the control codes that use them. Control codes not listed do not use these parameters.</dl></dl></dl><a name="925873"> </a><h4>Table 59.2	 VdrvControl Parameters</h4><p><a name="925918"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925876"> </a><code>vdvrOpCodeSetBaudRate</code> </td><td><a name="925878"> </a>-&gt; <code>controlDataP</code> = Pointer to <code>Int32</code> (baud rate), <a name="925879"> </a>-&gt; <code>controlDataLenP</code> = Pointer to <code>sizeof(Int32)</code>.</td></tr><tr><td><a name="925881"> </a><code>vdvrOpCodeSetSettingsFlags</code> </td><td><a name="925883"> </a>-&gt; controlDataP = Pointer to <code>UInt32</code> (bitfield; see <a href="NewSerialManager.html#925130">Serial Settings Constants</a>)<a name="925887"> </a>-&gt; controlDataLenP = Pointer to <code>sizeof(UInt32)</code> </td></tr><tr><td><a name="925889"> </a><code>vdvrOpCodeFIFOCount</code> </td><td><a name="925891"> </a>-&gt; controlDataP = Pointer to <code>Int16</code>, which contains the number of bytes in the FIFO. <a name="925892"> </a>-&gt; controlDataLenP = Pointer to <code>sizeof(Int16)</code>.</td></tr><tr><td><a name="925894"> </a><code>vdrvOpCodeGetOptTransmitSize</code> </td><td><a name="925896"> </a>&lt;- controlDataP = Pointer to <code>Int32</code> (buffer size),<a name="925897"> </a>&lt;- controlDataLenP = Pointer to <code>sizeof(Int32)</code>.<a name="925898"> </a>Return the optimum buffer size for sending data, or 0 to specify any buffer size is acceptable.</td></tr><tr><td><a name="925900"> </a><code>vdrvOpCodeGetMaxRcvBlockSize</code> </td><td><a name="925902"> </a>&lt;- controlDataP = Pointer to <code>Int32</code> (block size),<a name="925903"> </a>&lt;- controlDataLenP = Pointer to <code>sizeof(Int32)</code>.<a name="925904"> </a>Return the maximum block size that the serial manager should request from the virtual device.</td></tr><tr><td><a name="925906"> </a><code>vdrvOpCodeNotifyBytesReadFromQ</code> </td><td><a name="925908"> </a>-&gt; controlDataP = Pointer to <code>Int32</code> (number of bytes read),<a name="925909"> </a>-&gt; controlDataLenP = Pointer to <code>sizeof(Int32)</code>.</td></tr><tr><td><a name="925911"> </a><code>vdvrOpCodeUserDef</code> </td><td><a name="925913"> </a>&lt;-&gt; <code>controlDataP</code> = Pointer from <code><a href="NewSerialManager.html#925280"></code>SrmControl<code></a></code> (user-defined data), <a name="925917"> </a>&lt;-&gt; <code>controlDataLenP</code> = Pointer to <code>sizeof(Int32)</code>.</td></tr></table><table><tr><td></table></div></p><dl><a name="925919"> </a><h4>Compatibility </h4><dl><a name="925923"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl><a name="925926"> </a><br> <br> <br><h3> VdrvOpen</h3><dl><dl><a name="925927"> </a><h4>Purpose </h4><dl><a name="925928"> </a><p></p><dt>Initializes the virtual device to begin communication.</dl><a name="925929"> </a><h4>Prototype </h4><dl><a name="925930"> </a><dt><code>Err VdrvOpen(VdrvDataPtr*&nbsp;drvrDataP, UInt32&nbsp;baudRate, DrvrHWRcvQPtr&nbsp;rcvQP)</code></dl></dl><dl><a name="925931"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925932"> </a><CODE>&lt;-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a pointer to the driver's private global area (allocated by this function). A pointer to this private global area is passed to the other virtual driver functions.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925933"> </a><CODE>-&gt; <code>baudRate</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Initial baud rate setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925934"> </a><CODE>-&gt; <code>rcvQP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's receive queue buffer structure. For details on the fields, see <code><a href="SerialDriver.html#924992"></code>DrvrRcvQType<code></a></code>.<br></TD></TR></TABLE></dl><dl><a name="925938"> </a><h4>Result </h4><p><a name="925944"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925941"> </a>0</td><td><a name="925943"> </a>No error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925945"> </a><h4>Comments </h4><dl><a name="925946"> </a><p></p><dt>This function must allocate and initialize any global variables (and pass back a pointer to a pointer to them in <code>drvrDataP</code>), do any set-up necessary for communicating with other software, and save the <code>rcvQP</code> pointer since it will need the functions and pointers to structures enclosed within to be able to save received data into the new serial manager's receive queue.</dl><a name="925947"> </a><h4>Compatibility </h4><dl><a name="925951"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925954"> </a><br> <br> <br><h3> VdrvStatus</h3><dl><dl><a name="925955"> </a><h4>Purpose </h4><dl><a name="925956"> </a><p></p><dt>Returns virtual device status.</dl><a name="925957"> </a><h4>Prototype </h4><dl><a name="925958"> </a><dt><code>UInt16 VdrvStatus(VdrvDataPtr drvrDataP)</code></dl></dl><dl><a name="925959"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925960"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE></dl><dl><a name="925961"> </a><h4>Result </h4><dl><a name="925962"> </a><p></p><dt>An unsigned long bitfield denoting the status of the virtual device, but only if the virtual device is emulating hardware. The individual bit flags are described in the <code><a href="SerialDriver.html#925043"></code>DrvrStatusEnum<code></a></code> type.</dl></dl><dl><a name="925966"> </a><h4>Comments </h4><dl><a name="925967"> </a><p></p><dt>Generally, status is returned only to the client application using the virtual device. The new serial manager does not use status information from virtual devices.</dl><a name="925968"> </a><h4>Compatibility </h4><dl><a name="925972"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925975"> </a><br> <br> <br><h3> VdrvWrite</h3><dl><dl><a name="925976"> </a><h4>Purpose </h4><dl><a name="925977"> </a><p></p><dt>Writes a block of bytes.</dl><a name="925978"> </a><h4>Prototype </h4><dl><a name="925979"> </a><dt><code>UInt32 VdrvWrite(VdrvDataPtr&nbsp;drvrDataP, void&nbsp;*&nbsp;bufP, UInt32&nbsp;size, Err*&nbsp;errP)</code></dl></dl><dl><a name="925980"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925981"> </a><CODE>-&gt; <code>drvrDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the driver's private global area.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925982"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to buffer containing the data to be written to the virtual device.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925983"> </a><CODE>-&gt; <code>size</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes in the buffer <code>bufP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925984"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to an error code resulting from the operation. Zero is returned if there is no error.<br></TD></TR></TABLE></dl><dl><a name="925985"> </a><h4>Result </h4><dl><a name="925986"> </a><p></p><dt>Returns the actual number of bytes written.</dl></dl><dl><a name="925987"> </a><h4>Compatibility </h4><dl><a name="925991"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925993"> </a><h2> Serial Manager Queue Functions</h2><dl><a name="925995"> </a><p></p><dt>The functions in this section are supplied by the new serial manager to the virtual driver via the <a href="SerialDriver.html#924992">DrvrRcvQType</a> passed to the <code><a href="SerialDriver.html#925926"></code>VdrvOpen<code></a></code> function.</dl><a name="926004"> </a><br> <br> <br><h3> GetSize</h3><dl><dl><a name="926005"> </a><h4>Purpose </h4><dl><a name="926006"> </a><p></p><dt>Returns the total size of the new serial manager's receive queue.</dl><a name="926007"> </a><h4>Prototype </h4><dl><a name="926008"> </a><dt><code>typedef UInt32 (*GetSizeProcPtr)(void&nbsp;*&nbsp;theQ)</code></dl></dl><dl><a name="926009"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926010"> </a><CODE>-&gt; <code>theQ</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the receive queue.<br></TD></TR></TABLE></dl><dl><a name="926011"> </a><h4>Result </h4><dl><a name="926012"> </a><p></p><dt>Size in bytes of the new serial manager's receive queue.</dl></dl><dl><a name="926013"> </a><h4>Comments </h4><dl><a name="926014"> </a><p></p><dt>This function is useful for implementing flow control.</dl><a name="926015"> </a><h4>Compatibility </h4><dl><a name="926019"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="926022"> </a><br> <br> <br><h3> GetSpace</h3><dl><dl><a name="926023"> </a><h4>Purpose </h4><dl><a name="926024"> </a><p></p><dt>Returns the available space in the new serial manager's receive queue.</dl><a name="926025"> </a><h4>Prototype </h4><dl><a name="926026"> </a><dt><code>typedef UInt32 (*GetSpaceProcPtr)(void&nbsp;*&nbsp;theQ)</code></dl></dl><dl><a name="926027"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926028"> </a><CODE>-&gt; <code>theQ</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the receive queue.<br></TD></TR></TABLE></dl><dl><a name="926029"> </a><h4>Result </h4><dl><a name="926030"> </a><p></p><dt>Size in bytes of the available space in the new serial manager's receive queue.</dl></dl><dl><a name="926031"> </a><h4>Comments </h4><dl><a name="926032"> </a><p></p><dt>This function is useful for implementing flow control.</dl><a name="926033"> </a><h4>Compatibility </h4><dl><a name="926037"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="926040"> </a><br> <br> <br><h3> WriteBlock</h3><dl><dl><a name="926041"> </a><h4>Purpose </h4><dl><a name="926042"> </a><p></p><dt>Writes a block of bytes to the new serial manager's receive queue.</dl><a name="926043"> </a><h4>Prototype </h4><dl><a name="926044"> </a><dt><code>typedef Err (*WriteBlockProcPtr)(void&nbsp;*&nbsp;theQ, UInt8&nbsp;*&nbsp;bufP, UInt16&nbsp;size, UInt16&nbsp;lineErrs)</code></dl></dl><dl><a name="926045"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926046"> </a><CODE>-&gt; <code>theQ</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the receive queue.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926047"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the buffer holding bytes for the WriteBlock function.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926048"> </a><CODE>-&gt; <code>size</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size of <code>bufP</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926049"> </a><CODE>-&gt; <code>lineErrs</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Any serial line errors received should be reported here.<br></TD></TR></TABLE></dl><dl><a name="926050"> </a><h4>Result </h4><p><a name="926060"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="926053"> </a>0</td><td><a name="926055"> </a>No error.</td></tr><tr><td><a name="926057"> </a><code>serErrLineErr</code></td><td><a name="926059"> </a>There was a software overrun line error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="926061"> </a><h4>Compatibility </h4><dl><a name="926065"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="926068"> </a><br> <br> <br><h3> WriteByte</h3><dl><dl><a name="926069"> </a><h4>Purpose </h4><dl><a name="926070"> </a><p></p><dt>Writes one byte to the new serial manager's receive queue.</dl><a name="926071"> </a><h4>Prototype </h4><dl><a name="926072"> </a><dt><code>typedef Err (*WriteByteProcPtr)(void&nbsp;*&nbsp;theQ, UInt8&nbsp;theByte, UInt16&nbsp;lineErrs)</code></dl></dl><dl><a name="926073"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926074"> </a><CODE>-&gt; <code>theQ</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the receive queue.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926075"> </a><CODE>-&gt; <code>theByte</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The byte to be written to the queue.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926076"> </a><CODE>-&gt; <code>lineErrs</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Any serial line errors received should be reported here.<br></TD></TR></TABLE></dl><dl><a name="926077"> </a><h4>Result </h4><p><a name="926087"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="926080"> </a>0</td><td><a name="926082"> </a>No error.</td></tr><tr><td><a name="926084"> </a><code>serErrLineErr</code></td><td><a name="926086"> </a>There was a software overrun line error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="926088"> </a><h4>Compatibility </h4><dl><a name="926092"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.<a name="926102"> </a><p></p><dt><strong></strong></dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="SerialManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="SerialLinkManager.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 61 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:07 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SerialDriver.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
</html>