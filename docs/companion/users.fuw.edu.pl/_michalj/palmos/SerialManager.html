<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SerialManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
<head><title>Serial Manager</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="ScriptPlugin.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="SerialDriver.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924905"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>58 Serial Manager</h1><dl><a name="924906"> </a><p></p><dt>This chapter provides reference material for the serial manager API:<ul type="SQUARE"><a name="924910"> </a><br><li><a href="SerialManager.html#924921">Serial Manager Data Structures</a><br><a name="924914"> </a><br><li><a href="SerialManager.html#925032">Serial Manager Functions</a><br></ul><a name="924916"> </a><p></p><dt>The header file <code>SerialMgrOld.h</code> declares the serial manager API. For more information on the serial manager, see the chapter <a href="SerialCommunication.html#928031">"Serial Communication"</a> in the <em>Palm OS Programmer's Companion</em>. </dl><a name="924921"> </a><h2> Serial Manager Data Structures</h2><a name="924923"> </a><h3> SerCtlEnum</h3><dl><a name="924927"> </a><p></p><dt>To perform a control function, applications call <a href="SerialManager.html#925082">SerControl</a>, which performs one of the control operations specified by <code>SerCtlEnum</code>, which has the following elements:<p><a name="924998"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="924931"> </a><strong>Element</strong></th><th><a name="924933"> </a><strong>Description</strong></th></tr><tr><td><a name="924936"> </a><code>serCtlFirstReserved</code> = 0</td><td><a name="924938"> </a>Reserve 0</td></tr><tr><td><a name="924941"> </a><code>serCtlStartBreak</code> </td><td><a name="924943"> </a>Turn RS232 break signal on. Applications have to make sure that the break is set long enough to generate a value BREAK! <a name="924944"> </a><code>valueP = 0; valueLenP = 0</code></td></tr><tr><td><a name="924947"> </a><code>serCtlStopBreak</code> </td><td><a name="924949"> </a>Turn RS232 break signal off: <a name="924950"> </a><code>valueP = 0; valueLenP = 0</code></td></tr><tr><td><a name="924953"> </a><code>serCtlBreakStatus</code> </td><td><a name="924955"> </a>Get RS232 break signal status (on or off):<a name="924956"> </a><code>valueP</code> = ptr to Word for returning status<a name="924957"> </a>	 	 (0 = off, !0 = on)<p><a name="924958"> </a><code>*valueLenP = sizeof(Word)</code></p></td></tr><tr><td><a name="924961"> </a><code>serCtlStartLocalLoopback</code> </td><td><a name="924963"> </a>Start local loopback test;<a name="924964"> </a><code>valueP = 0, valueLenP = 0</code></td></tr><tr><td><a name="924967"> </a><code>serCtlStopLocalLoopback</code> </td><td><a name="924969"> </a>Stop local loopback test <a name="924970"> </a><code>valueP = 0, valueLenP = 0</code></td></tr><tr><td><a name="924973"> </a><code>serCtlMaxBaud</code> </td><td><a name="924975"> </a><code>valueP = ptr</code> to <code>DWord</code> for returned baud <a name="924976"> </a><code>*valueLenP</code><code> = sizeof(DWord)</code></td></tr><tr><td><a name="924979"> </a><code>serCtlHandshakeThreshold</code> </td><td><a name="924981"> </a>Retrieve HW handshake threshold; this is the maximum baud rate that does not require hardware handshaking<a name="924982"> </a><code>valueP</code> = <code>ptr </code>to DWord for returned baud <a name="924983"> </a><code>*valueLenP = sizeof(DWord)</code></td></tr><tr><td><a name="924986"> </a><code>serCtlEmuSetBlockingHook</code> </td><td><a name="924988"> </a>Set a blocking hook routine.<a name="924989"> </a><blockquote><hr><em><strong>WARNING!</strong></em><p></p>WARNING: For use with the Simulator on Mac OS only: NOT SUPPORTED ON THE PALM DEVICE. <hr><br></blockquote><a name="924990"> </a><code>valueP = </code>ptr to SerCallbackEntryType<code> </code><a name="924991"> </a><code>*valueLenP=sizeof(SerCallbackEntryType)</code><a name="924992"> </a>Returns the old settings in the first argument.</td></tr><tr><td><a name="924995"> </a><code>serCtlLAST</code> </td><td><a name="924997"> </a>Add new address entries before this one.</td></tr></table><table><tr><td></table></div></p></dl><a name="925000"> </a><h3> SerSettingsType</h3><dl><a name="925002"> </a><p></p><dt>The SerSettingsType structure defines serial port attributes; it is used by the calls <a href="SerialManager.html#925115">SerGetSettings</a> and <a href="SerialManager.html#925503">SerSetSettings</a>. The <code>SerSettingsPtr</code> type points to a SerSettingsType structure.<dl><a name="925009"> </a><br><code>typedef struct SerSettingsType {</code><br></dl><dl><a name="925010"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;baudRate;</code><br><a name="925011"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;flags;</code><br><a name="925012"> </a><code>&nbsp&nbsp&nbsp Int32&nbsp;ctsTimeout;</code><br><a name="925013"> </a><code>&nbsp&nbsp&nbsp } SerSettingsType;</code><br><a name="925014"> </a><code></code><br><a name="925015"> </a><code>typedef SerSettingsType* SerSettingsPtr;</code><br></dl></dl><a name="925016"> </a><h4> Field Descriptions</h4><p><a name="925030"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925019"> </a><code>baudRate</code> </td><td><a name="925021"> </a>Baud rate</td></tr><tr><td><a name="925023"> </a><code>flags</code> </td><td><a name="925025"> </a>Miscellaneous settings</td></tr><tr><td><a name="925027"> </a><code>ctsTimeout</code> </td><td><a name="925029"> </a>Maximum number of ticks to wait for CTS to become asserted before transmitting; used only when configured with the <code>serSettingsFlagCTSAutoM</code> flag.</td></tr></table><table><tr><td></table></div></p><a name="925032"> </a><h2> Serial Manager Functions</h2><a name="925034"> </a><br> <br> <br><h3> SerClearErr</h3><dl><dl><a name="925035"> </a><h4>Purpose </h4><dl><a name="925036"> </a><p></p><dt>Reset the serial port's line error status.</dl><a name="925037"> </a><h4>Prototype </h4><dl><a name="925039"> </a><dt><code>Err SerClearErr (UInt16&nbsp;refNum)</code></dl></dl><dl><a name="925040"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925041"> </a><CODE>-&gt; <code>refNum</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>The serial library reference number.<br></TD></TR></TABLE></dl><dl><a name="925042"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925043"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE></dl><dl><a name="925044"> </a><h4>Comments </h4><dl><a name="925045"> </a><p></p><dt>Call <code>SerClearErr</code> only after a serial manager function (<code>SerReceive</code>, <code>SerReceiveCheck</code>, <code>SerSend</code>, etc.) returns with the error code <code>serErrLineErr</code>. <a name="925047"> </a><p></p><dt>The reason for this is that <code>SerClearErr</code> resets the serial port. So, if <code>SerClearErr</code> is called unconditionally while a byte is coming into the serial port, that byte is guaranteed to become corrupted.<a name="925048"> </a><p></p><dt>The right strategy is to always check the error code returned by a serial manager function. If it `s <code>serErrLineErr</code>, call <code>SerClearErr</code> immediately. However, don't make unsolicited calls to <code>SerClearErr</code>. <a name="925051"> </a><p></p><dt>When you get <code>serErrLineErr</code>, consider flushing the receive queue for a fraction of a second by calling <code>SerReceiveFlush</code>. <code>SerReceiveFlush</code> calls <code>SerClearErr</code> for you.</dl></dl></dl><a name="925054"> </a><br> <br> <br><h3> SerClose</h3><dl><dl><a name="925055"> </a><h4>Purpose </h4><dl><a name="925056"> </a><p></p><dt>Release the serial port previously acquired by SerOpen.</dl><a name="925057"> </a><h4>Prototype </h4><dl><a name="925058"> </a><dt><code>Err SerClose (UInt16&nbsp;refNum)</code></dl></dl><dl><a name="925059"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925060"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE></dl><dl><a name="925061"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925062"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925064"> </a><CODE>serErrNotOpen</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port wasn't open.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925066"> </a><CODE>serErrStillOpen</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port still held open by another process.<br></TD></TR></TABLE></dl><dl><a name="925067"> </a><h4>Comments </h4><dl><a name="925068"> </a><p></p><dt>Releases the serial port and shuts down serial port hardware if the open count has reached 0. Open serial ports consume more energy from the device's batteries; it's therefore essential to keep a port open only as long as necessary.</dl><a name="925069"> </a><h4> Caveat</h4><dl><a name="925073"> </a><p></p><dt>Don't call SerClose unless the return value from <a href="SerialManager.html#925179">SerOpen</a> was 0 (zero) or serErrAlreadyOpen.</dl><a name="925075"> </a><h4>See Also </h4><dl><a name="925079"> </a><p></p><dt><a href="SerialManager.html#925179">SerOpen</a></dl></dl></dl><a name="925082"> </a><br> <br> <br><h3> SerControl</h3><dl><dl><a name="925083"> </a><h4>Purpose </h4><dl><a name="925084"> </a><p></p><dt>Perform a control function. </dl><a name="925085"> </a><h4>Prototype </h4><dl><a name="925086"> </a><dt><code>Err SerControl (UInt16&nbsp;refNum, UInt16&nbsp;op, void&nbsp;*valueP, UInt16&nbsp;*valueLenP)</code></dl></dl><dl><a name="925087"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925088"> </a><CODE>-&gt; <code>refNum</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925089"> </a><CODE>-&gt; <code>op</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Control operation to perform (<code>SerCtlEnum</code>).<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925090"> </a><CODE>&lt;-&gt; <code>valueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to value for operation.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925091"> </a><CODE>&lt;-&gt; <code>valueLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to size of value.<br></TD></TR></TABLE></dl><dl><a name="925092"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925093"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925095"> </a><CODE><code>serErrBadParam</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Invalid parameter (unknown). <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925097"> </a><CODE><code>serErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Library not open.<br></TD></TR></TABLE></dl><dl><a name="925098"> </a><h4>Comments </h4><dl><a name="925099"> </a><p></p><dt>This function provides extensible control features for the serial manager. You can <ul type="SQUARE"><a name="925100"> </a><br><li>Turn on/off the RS232 break signal and check its status.<br><a name="925101"> </a><br><li>Perform a local loopback test.<br><a name="925102"> </a><br><li>Get the maximum supported baud rate.<br><a name="925103"> </a><br><li>Get the hardware handshake threshold baud rate.<br></ul><a name="925104"> </a><p></p><dt>There is one emulator-only control, <code>serCtlEmuSetBlockingHook</code>. See <a href="SerialCommunication.html#925054">Using the Serial Manager</a> for more information.</dl><a name="925108"> </a><h4>Compatibility </h4><dl><a name="925112"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl></dl></dl><a name="925115"> </a><br> <br> <br><h3> SerGetSettings</h3><dl><dl><a name="925116"> </a><h4>Purpose </h4><dl><a name="925120"> </a><p></p><dt>Fill in the <code><a href="SerialManager.html#925000"></code>SerSettingsType<code></a></code> structure with current serial port attributes.</dl><a name="925121"> </a><h4>Prototype </h4><dl><a name="925122"> </a><dt><code>Err SerGetSettings (UInt16&nbsp;refNum, SerSettingsPtr&nbsp;settingsP)</code></dl></dl><dl><a name="925123"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925124"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925128"> </a><CODE>&lt;-&gt; <code>settingsP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to <code><a href="SerialManager.html#925000"></code>SerSettingsType<code></a></code> structure to be filled in.<br></TD></TR></TABLE></dl><dl><a name="925129"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925130"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925132"> </a><CODE>serErrNotOpen</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The port wasn't open.<br></TD></TR></TABLE></dl><dl><a name="925133"> </a><h4>Comments </h4><dl><a name="925134"> </a><p></p><dt>The information returned by this call includes the current baud rate, CTS timeout, handshaking options, and data format options.<a name="925138"> </a><p></p><dt>See the <code><a href="SerialManager.html#925000"></code>SerSettingsType<code></a></code> structure for more details.</dl><a name="925139"> </a><h4>See Also </h4><dl><a name="925143"> </a><p></p><dt><a href="SerialManager.html#925364">SerSend</a></dl></dl></dl><a name="925146"> </a><br> <br> <br><h3> SerGetStatus</h3><dl><dl><a name="925147"> </a><h4>Purpose </h4><dl><a name="925148"> </a><p></p><dt>Return the pending line error status for errors that have been detected since the last time <a href="SerialManager.html#925034">SerClearErr</a> was called.</dl><a name="925153"> </a><h4>Prototype </h4><dl><a name="925154"> </a><dt><code>UInt16 SerGetStatus (UInt16&nbsp;refNum, Boolean&nbsp;*ctsOnP, Boolean&nbsp;*dsrOnP)</code></dl></dl><dl><a name="925155"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925156"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925157"> </a><CODE>-&gt; <code>ctsOnP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to location for storing a Boolean value.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925158"> </a><CODE>-&gt; <code>dsrOnP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to location for storing a Boolean value.<br></TD></TR></TABLE></dl><dl><a name="925159"> </a><h4>Result </h4><dl><a name="925160"> </a><p></p><dt>Returns any combination of the following constants, bitwise ORed together:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925162"> </a><CODE><code>serLineErrorParity</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Parity error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925163"> </a><CODE>serLineErrorHWOverrun</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Hardware overrun.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925164"> </a><CODE>serLineErrorFraming</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Framing error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925165"> </a><CODE>serLineErrorBreak</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Break signal detected.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925166"> </a><CODE>serLineErrorHShake</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Line handshake error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925167"> </a><CODE>serLineErrorSWOverrun</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Software overrun.<br></TD></TR></TABLE></dl></dl><dl><a name="925168"> </a><h4>Comments </h4><dl><a name="925169"> </a><p></p><dt>When another serial manager function returns an error code of serErrLineErr, SerGetStatus can be used to find out the specific nature of the line error(s). <a name="925171"> </a><p></p><dt>The values returned via <code>ctsOnP</code> and <code>dsrOnP</code> are not meaningful in the present version of the software</dl><a name="925172"> </a><h4>See Also </h4><dl><a name="925176"> </a><p></p><dt><a href="SerialManager.html#925034">SerClearErr</a></dl></dl></dl><a name="925179"> </a><br> <br> <br><h3> SerOpen</h3><dl><dl><a name="925180"> </a><h4>Purpose </h4><dl><a name="925181"> </a><p></p><dt>Acquire and open a serial port with given baud rate and default settings.</dl><a name="925182"> </a><h4>Prototype </h4><dl><a name="925184"> </a><dt><code>Err SerOpen (UInt16&nbsp;refNum, UInt16&nbsp;port, UInt32&nbsp;baud)</code></dl></dl><dl><a name="925185"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925186"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925187"> </a><CODE>-&gt; <code>port</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925188"> </a><CODE>-&gt; <code>baud</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Baud rate.<br></TD></TR></TABLE></dl><dl><a name="925189"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925190"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925192"> </a><CODE>serErrAlreadyOpen</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port was open. Enables port sharing by "friendly" clients (not recommended).<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925194"> </a><CODE>serErrBadParam</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Invalid parameter.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925196"> </a><CODE>memErrNotEnoughSpace</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Insufficient memory.<br></TD></TR></TABLE></dl><dl><a name="925197"> </a><h4>Comments </h4><dl><a name="925198"> </a><p></p><dt>Acquires the serial port, powers it up, and prepares it for operation. To obtain the serial library reference number, call <a href="SystemManager.html#925491">SysLibFind</a> with "Serial Library" as the library name. This reference number must be passed as a parameter to all serial manager functions. The device currently contains only one serial port with port number 0 (zero). <a name="928528"> </a><p></p><dt>The baud rate is an integral baud value (for example - 300, 1200, 2400, 9600, 19200, 38400, 57600, etc.). The Palm OS<sup>&#174;</sup> device has been tested at the standard baud rates in the range of 300 - 57600 baud. Baud rates through 1 Mbit are theoretically possible. Use CTS handshaking at baud rates above 19200 (see <a href="SerialManager.html#925503">SerSetSettings</a>). <a name="925208"> </a><p></p><dt>An error code of 0 (zero) or serErrAlreadyOpen indicates that the port was successfully opened. If the port is already open when SerOpen is called, the port's open count is incremented and an error code of serErrAlreadyOpen is returned. This ability to open the serial port multiple times allows cooperating tasks to share the serial port. Other tasks must refrain from using the port if serErrAlreadyOpen is returned and close it by calling <a href="SerialManager.html#925054">SerClose</a>. </dl></dl></dl><a name="925216"> </a><br> <br> <br><h3> SerReceive</h3><dl><dl><a name="925217"> </a><h4>Purpose </h4><dl><a name="925218"> </a><p></p><dt>Receives <code>size</code> bytes worth of data or returns with error if a line error or timeout is encountered.</dl><a name="925219"> </a><h4>Prototype </h4><dl><a name="925220"> </a><dt><code>UInt32 SerReceive (UInt16&nbsp;refNum, void&nbsp;*bufP, UInt32&nbsp;count, Int32&nbsp;timeout, Err* errP)</code></dl></dl><dl><a name="925221"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925222"> </a><CODE><code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925223"> </a><CODE>&lt;-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Buffer for receiving data.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925224"> </a><CODE>-&gt; <code>count</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to receive.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925225"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Interbyte timeout in ticks, 0 for none, -1 forever.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925226"> </a><CODE>&lt;-&gt; <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>For returning error code.<br></TD></TR></TABLE></dl><dl><a name="925227"> </a><h4>Result </h4><dl><a name="925228"> </a><p></p><dt>Number of bytes received:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925229"> </a><CODE><code>*errP = 0</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925231"> </a><CODE><code>serErrLineErr</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>RS232 line error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925233"> </a><CODE><code>serErrTimeOut</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Interbyte timeout.<br></TD></TR></TABLE></dl></dl><dl><a name="925234"> </a><h4>Compatibility </h4><dl><a name="925238"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.<a name="925239"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>The old versions of <code>SerSend</code> and <code>SerReceive</code> are still available as <code>SerSend10</code> and <code>SerReceive10</code> (not V10).<hr><br></blockquote></dl><a name="925240"> </a><h4>See Also </h4><dl><a name="925244"> </a><p></p><dt><a href="SerialManager.html#925247">SerReceive10</a></dl></dl></dl><a name="925247"> </a><br> <br> <br><h3> SerReceive10</h3><dl><dl><a name="925248"> </a><h4>Purpose </h4><dl><a name="925249"> </a><p></p><dt>Receive a stream of bytes.</dl><a name="925250"> </a><h4>Prototype </h4><dl><a name="925251"> </a><dt><code>Err SerReceive10 (UInt16&nbsp;refNum, void&nbsp;*bufP, UInt32&nbsp;bytes, Int32&nbsp;timeout)</code></dl></dl><dl><a name="925252"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925253"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925254"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the buffer for receiving data.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925255"> </a><CODE>-&gt; <code>bytes</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes desired.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925256"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Interbyte time out in system ticks (-1 = forever).<br></TD></TR></TABLE></dl><dl><a name="925257"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925258"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error. Requested number of bytes was received.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925260"> </a><CODE>serErrTimeOut</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Interbyte time out exceeded while waiting for the next byte to arrive.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925265"> </a><CODE>serErrLineErr</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Line error occurred (see <a href="SerialManager.html#925034">SerClearErr</a> and <a href="SerialManager.html#925146">SerGetStatus</a>).<br></TD></TR></TABLE></dl><dl><a name="925269"> </a><h4>Comments </h4><dl><a name="925270"> </a><p></p><dt>SerReceive blocks until all the requested data has been received or an error occurs. Because this call returns immediately without any data if line errors are pending, it is important to acknowledge the detection of line errors by calling <a href="SerialManager.html#925034">SerClearErr</a>. If you just need to retrieve all or some of the bytes which are already in the receive queue, call <a href="SerialManager.html#925281">SerReceiveCheck</a> first to get the count of bytes presently in the receive queue.</dl><a name="925277"> </a><h4>Compatibility </h4><dl><a name="925278"> </a><p></p><dt>This function corresponds to the 1.0 version of <code>SerReceive</code>. </dl></dl></dl><a name="925281"> </a><br> <br> <br><h3> SerReceiveCheck</h3><dl><dl><a name="925282"> </a><h4>Purpose </h4><dl><a name="925283"> </a><p></p><dt>Return the count of bytes presently in the receive queue.</dl><a name="925284"> </a><h4>Prototype </h4><dl><a name="925286"> </a><dt><code>Err SerReceiveCheck (UInt16&nbsp;refNum, UInt32&nbsp;*numBytesP)</code></dl></dl><dl><a name="925287"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925288"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925289"> </a><CODE>&lt;-&gt; <code>numBytesP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to location for returning the byte count.<br></TD></TR></TABLE></dl><dl><a name="925290"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925291"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925296"> </a><CODE>serErrLineErr</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Line error pending (see <a href="SerialManager.html#925034">SerClearErr</a> and <a href="SerialManager.html#925146">SerGetStatus</a>).<br></TD></TR></TABLE></dl><dl><a name="925300"> </a><h4>Comments </h4><dl><a name="925301"> </a><p></p><dt>Because this call does not return the byte count if line errors are pending, it is important to acknowledge the detection of line errors by calling <a href="SerialManager.html#925034">SerClearErr</a>. </dl><a name="925305"> </a><h4>See Also </h4><dl><a name="925309"> </a><p></p><dt><a href="SerialManager.html#925328">SerReceiveWait</a></dl></dl></dl><a name="925312"> </a><br> <br> <br><h3> SerReceiveFlush</h3><dl><dl><a name="925313"> </a><h4>Purpose </h4><dl><a name="925314"> </a><p></p><dt>Discard all data presently in the receive queue and flush bytes coming into the serial port. Clear the saved error status.</dl><a name="925315"> </a><h4>Prototype </h4><dl><a name="925317"> </a><dt><code>void SerReceiveFlush (UInt16&nbsp;refNum, Int32&nbsp;timeout)</code></dl></dl><dl><a name="925318"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925319"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925320"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Interbyte time out in system ticks (-1 = forever).<br></TD></TR></TABLE></dl><dl><a name="925321"> </a><h4>Result </h4><dl><a name="925322"> </a><p></p><dt>Returns nothing.</dl></dl><dl><a name="925323"> </a><h4>Comments </h4><dl><a name="925325"> </a><p></p><dt><code>SerReceiveFlush</code> blocks until a timeout occurs while waiting for the next byte to arrive.</dl></dl></dl><a name="925328"> </a><br> <br> <br><h3> SerReceiveWait</h3><dl><dl><a name="925329"> </a><h4>Purpose </h4><dl><a name="925330"> </a><p></p><dt>Wait for at least <code>bytes</code> bytes of data to accumulate in the receive queue.</dl><a name="925331"> </a><h4>Prototype </h4><dl><a name="925332"> </a><dt><code>Err SerReceiveWait (UInt16&nbsp;refNum, UInt32&nbsp;bytes, Int32&nbsp;timeout)</code></dl></dl><dl><a name="925333"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925334"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925335"> </a><CODE>-&gt; <code>bytes</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes desired.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925336"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Interbyte timeout in system ticks (-1 = forever).<br></TD></TR></TABLE></dl><dl><a name="925337"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925338"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925340"> </a><CODE>serErrTimeOut</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Interbyte timeout exceeded while waiting for next byte to arrive.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925345"> </a><CODE><code>serErrLineErr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Line error occurred (see <a href="SerialManager.html#925034">SerClearErr</a> and <code><a href="SerialManager.html#925146"></code>SerGetStatus<code></a></code>).<br></TD></TR></TABLE></dl><dl><a name="925349"> </a><h4>Comments </h4><dl><a name="925350"> </a><p></p><dt>This is the preferred method of waiting for serial input, since it blocks the current task and allows switching the processor into a more energy-efficient state. <a name="925351"> </a><p></p><dt>SerReceiveWait blocks until the desired number of bytes accumulate in the receive queue or an error occurs. The desired number of bytes must be less than the current receive queue size. The default queue size is 512 bytes. Because this call returns immediately if line errors are pending, it is important to acknowledge the detection of line errors by calling <a href="SerialManager.html#925034">SerClearErr</a>. </dl><a name="925355"> </a><h4>See Also </h4><dl><a name="925362"> </a><p></p><dt><a href="SerialManager.html#925281">SerReceiveCheck</a>, <a href="SerialManager.html#925485">SerSetReceiveBuffer</a></dl></dl></dl><a name="925364"> </a><br> <br> <br><h3> SerSend</h3><dl><dl><a name="925365"> </a><h4>Purpose </h4><dl><a name="925366"> </a><p></p><dt>Send one or more bytes of data over the serial port.</dl><a name="925367"> </a><h4>Prototype </h4><dl><a name="925369"> </a><dt><code>UInt32 SerSend (UInt16&nbsp;refNum, void&nbsp;*bufP, UInt32&nbsp;count, Err&nbsp;*errP</code></dl></dl><dl><a name="925370"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925371"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925372"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to data to send.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925373"> </a><CODE>-&gt; <code>count</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to send.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925374"> </a><CODE>&lt;-&gt; <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>For returning error code.<br></TD></TR></TABLE></dl><dl><a name="925375"> </a><h4>Result </h4><dl><a name="925376"> </a><p></p><dt>Returns the number of bytes transferred.<a name="925377"> </a><p></p><dt>Stores in <code>errP</code>:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925378"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925380"> </a><CODE><code>serErrTimeOut</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Handshake timeout.<br></TD></TR></TABLE><dl><a name="925381"> </a><p></p><dt>The old calls worked, but they did not return enough info when they failed. The new calls (available in Palm OS v2.0 and greater) add more parameters to solve this problem and make serial communications programming simpler. <a name="925382"> </a><p></p><dt>Don't call the new functions when running on Palm OS 1.0.</dl></dl></dl><dl><a name="925383"> </a><h4>Compatibility </h4><dl><a name="925387"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.<a name="925388"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>The old versions of <code>SerSend</code> and <code>SerReceive</code> are still available as <code>SerSend10</code> and <code>SerReceive10</code> (not V10).<hr><br></blockquote></dl><a name="925389"> </a><h4>See Also </h4><dl><a name="925396"> </a><p></p><dt><a href="SerialManager.html#925400">SerSend10</a>, <a href="SerialManager.html#925457">SerSendWait</a></dl></dl></dl><a name="925400"> </a><br> <br> <br><h3> SerSend10</h3><dl><dl><a name="925401"> </a><h4>Purpose </h4><dl><a name="925402"> </a><p></p><dt>Send a stream of bytes to the serial port.</dl><a name="925403"> </a><h4>Prototype </h4><dl><a name="925404"> </a><dt><code>Err SerSend10 (UInt16&nbsp;refNum, void&nbsp;*bufP, UInt32&nbsp;size)</code></dl></dl><dl><a name="925405"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925406"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925407"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the data to send.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925408"> </a><CODE>-&gt; <code>size</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size (in number of bytes) of the data to send.<br></TD></TR></TABLE></dl><dl><a name="925409"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925410"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925412"> </a><CODE><code>serErrTimeOut</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Handshake timeout (such as waiting for CTS to become asserted).<br></TD></TR></TABLE></dl><dl><a name="925413"> </a><h4>Comments </h4><dl><a name="925414"> </a><p></p><dt>In the present implementation, <code>S</code>erSend10 blocks until all data is transferred to the UART or a timeout error (if CTS handshaking is enabled) occurs. Future implementations may queue up the request and return immediately, performing transmission in the background. If your software needs to detect when all data has been transmitted, see <a href="SerialManager.html#925457">SerSendWait</a>.<a name="925418"> </a><p></p><dt>This routine observes the current CTS time out setting if CTS handshaking is enabled (see <a href="SerialManager.html#925115">SerGetSettings</a> and <a href="SerialManager.html#925364">SerSend</a>).</dl><a name="925425"> </a><h4>Compatibility </h4><dl><a name="925426"> </a><p></p><dt>This function corresponds to the 1.0 version of <code>SerSend</code>.</dl><a name="925427"> </a><h4>See Also </h4><dl><a name="925434"> </a><p></p><dt><a href="SerialManager.html#925364">SerSend</a>, <a href="SerialManager.html#925457">SerSendWait</a></dl></dl></dl><a name="925437"> </a><br> <br> <br><h3> SerSendFlush</h3><dl><dl><a name="925438"> </a><h4>Purpose </h4><dl><a name="925439"> </a><p></p><dt>Discard all data presently in the transmit queue.</dl><a name="925440"> </a><h4>Prototype </h4><dl><a name="925441"> </a><dt><code>Err SerSendFlush (UInt16&nbsp;refNum)</code></dl></dl><dl><a name="925442"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925443"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE></dl><dl><a name="925444"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925445"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE></dl><dl><a name="925446"> </a><h4>See Also </h4><dl><a name="925453"> </a><p></p><dt><code><a href="SerialManager.html#925364"></code>SerSend<code></a></code>, <code><a href="SerialManager.html#925457"></code>SerSendWait<code></a></code></dl></dl></dl><a name="925457"> </a><br> <br> <br><h3> SerSendWait</h3><dl><dl><a name="925458"> </a><h4>Purpose </h4><dl><a name="925459"> </a><p></p><dt>Wait until the serial transmit buffer empties.</dl><a name="925460"> </a><h4>Prototype </h4><dl><a name="925462"> </a><dt><code>Err SerSendWait (UInt16&nbsp;refNum, Int32&nbsp;timeout)</code></dl></dl><dl><a name="925463"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925464"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925465"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reserved for future enhancements. Set to (-1) for compatibility.<br></TD></TR></TABLE></dl><dl><a name="925466"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925467"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925469"> </a><CODE>serErrTimeOut</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Handshake timeout (such as waiting for CTS to become asserted).<br></TD></TR></TABLE></dl><dl><a name="925470"> </a><h4>Comments </h4><dl><a name="925471"> </a><p></p><dt>SerSendWait blocks until all data is transferred or a timeout error (if CTS handshaking is enabled) occurs. This routine observes the current CTS timeout setting if CTS handshaking is enabled (see <a href="SerialManager.html#925115">SerGetSettings</a> and <a href="SerialManager.html#925364">SerSend</a>).</dl><a name="925478"> </a><h4>See Also </h4><dl><a name="925482"> </a><p></p><dt><code><a href="SerialManager.html#925364"></code>SerSend<code></a></code></dl></dl></dl><a name="925485"> </a><br> <br> <br><h3> SerSetReceiveBuffer</h3><dl><dl><a name="925486"> </a><h4>Purpose </h4><dl><a name="925487"> </a><p></p><dt>Replace the default receive queue. To restore the original buffer, pass <code>bufSize</code> = 0.</dl><a name="925488"> </a><h4>Prototype </h4><dl><a name="925490"> </a><dt><code>Err SerSetReceiveBuffer (UInt16&nbsp;refNum, void&nbsp;*bufP, UInt16&nbsp;bufSize)</code></dl></dl><dl><a name="925491"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925492"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925493"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to buffer to be used as the new receive queue.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925494"> </a><CODE>-&gt; <code>bufSize</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size of buffer, or 0 to restore the default receive queue.<br></TD></TR></TABLE></dl><dl><a name="925495"> </a><h4>Result </h4><dl><a name="925496"> </a><p></p><dt>Returns 0 if successful.</dl></dl><dl><a name="925497"> </a><h4>Comments </h4><dl><a name="925498"> </a><p></p><dt>The specified buffer needs to contain 32 extra bytes for serial manager overhead (its size should be your application's requirement plus 32 bytes). The default receive queue must be restored before the serial port is closed. To restore the default receive queue, call <code><a href="SerialManager.html#925485"></code>SerSetReceiveBuffer<code></a></code> passing 0 (zero) for the buffer size. The serial manager does not free the custom receive queue.</dl></dl></dl><a name="925503"> </a><br> <br> <br><h3> SerSetSettings</h3><dl><dl><a name="925504"> </a><h4>Purpose </h4><dl><a name="925505"> </a><p></p><dt>Set the serial port settings; that is, change its attributes.</dl><a name="925506"> </a><h4>Prototype </h4><dl><a name="925508"> </a><dt><code>Err SerSetSettings (UInt16&nbsp;refNum, SerSettingsPtr&nbsp;settingsP)</code></dl></dl><dl><a name="925509"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925510"> </a><CODE>-&gt; <code>refNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Serial library reference number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925514"> </a><CODE>&lt;-&gt; <code>settingsP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the filled in <code><a href="SerialManager.html#925000"></code>SerSettingsType<code></a></code> structure.<br></TD></TR></TABLE></dl><dl><a name="925515"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925516"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925518"> </a><CODE>serErrNotOpen</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The port wasn't open.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925520"> </a><CODE>serErrBadParam</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Invalid parameter.<br></TD></TR></TABLE></dl><dl><a name="925521"> </a><h4>Comments </h4><dl><a name="925522"> </a><p></p><dt>The attributes set by this call include the current baud rate, CTS timeout, handshaking options, and data format options. See the definition of the <code><a href="SerialManager.html#925000"></code>SerSettingsType<code></a></code> structure for more details.<a name="925526"> </a><p></p><dt>To do 7E1 transmission, <code>OR</code> together:<a name="925527"> </a><p></p><dt><code>serSettingsFlagBitsPerChar7 | serSettingsFlagParityOnM | serSettingsFlagParityEvenM | serSettingsFlagStopBits1</code><a name="925528"> </a><p></p><dt>If you're trying to communicate at speeds greater than 19.2 Kbps, you need to use hardware handshaking: <code>serSettingsFlagRTSAutoM</code> | <code>serSettingsFlagCTSAutoM</code>. </dl><a name="925529"> </a><h4>See Also </h4><dl><a name="925533"> </a><p></p><dt><code><a href="SerialManager.html#925115"></code>SerGetSettings<code></a></code><dl><a name="927584"> </a><p></p><dt><strong></strong></dl></dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="ScriptPlugin.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="SerialDriver.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 60 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:06 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SerialManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
</html>