<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/MemoryManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:01 GMT -->
<head><title>Memory Manager</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="KeyManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="NotifyMgr.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924905"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>35 Memory Manager</h1><dl><a name="924906"> </a><p></p><dt>This chapter provides reference information for the memory manager. The memory manager API is declared in the header file <code>MemoryMgr.h</code>. <a name="924908"> </a><p></p><dt>For more information on the memory manager, see the chapter <a href="Memory.html#924904">"Memory"</a> in the <em>Palm OS Programmer's Companion</em>. </dl><a name="924912"> </a><h2> Memory Manager Functions</h2><a name="924915"> </a><br> <br> <br><h3> MemCardInfo</h3><dl><dl><a name="924916"> </a><h4>Purpose </h4><dl><a name="924918"> </a><p></p><dt>Return information about a memory card.</dl><a name="929247"> </a><h4>Prototype </h4><dl><a name="929248"> </a><dt><code>Err MemCardInfo (UInt16&nbsp;cardNo, Char*&nbsp;cardNameP, Char*&nbsp;manufNameP, UInt16*&nbsp;versionP, UInt32*&nbsp;crDateP, UInt32*&nbsp;romSizeP, UInt32*&nbsp;ramSizeP, UInt32*&nbsp;freeBytesP)</code></dl></dl><dl><a name="924921"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924922"> </a><CODE><code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Card number.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924923"> </a><CODE><code>cardNameP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to character array (32 bytes), or 0. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924924"> </a><CODE><code>manufNameP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to character array (32 bytes), or 0. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924925"> </a><CODE><code>versionP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to version variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924926"> </a><CODE><code>crDateP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to creation date variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924927"> </a><CODE><code>romSizeP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to ROM size variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924928"> </a><CODE><code>ramSizeP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to RAM size variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924929"> </a><CODE><code>freeBytesP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to free byte-count variable, or 0.<br></TD></TR></TABLE></dl><dl><a name="924930"> </a><h4>Result </h4><dl><a name="924931"> </a><p></p><dt>Returns 0 if no error.</dl></dl><dl><a name="924932"> </a><h4>Comments </h4><dl><a name="924933"> </a><p></p><dt>Pass 0 for those variables that you don't want returned. </dl></dl></dl><a name="924936"> </a><br> <br> <br><h3> MemCmp</h3><dl><dl><a name="924937"> </a><h4>Purpose </h4><dl><a name="924939"> </a><p></p><dt>Compare two blocks of memory.<a name="944970"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>Blocks are compared as unsigned bytes. <hr><br></blockquote></dl><a name="924940"> </a><h4>Prototype </h4><dl><a name="924941"> </a><dt><code>Int16 MemCmp (const&nbsp;void*&nbsp;s1, const&nbsp;void*&nbsp;s2, Int32&nbsp;numBytes)</code></dl></dl><dl><a name="924942"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924943"> </a><CODE><code>s1, s2</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointers to block of memory.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924944"> </a><CODE><code>numBytes</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to compare. <br></TD></TR></TABLE></dl><dl><a name="924945"> </a><h4>Result </h4><dl><a name="924946"> </a><p></p><dt>Zero if they match, non-zero if not:<a name="924947"> </a><p></p><dt>+ if <code>s1</code> &gt; <code>s2</code> <a name="924948"> </a><p></p><dt>- if <code>s1</code> &lt; <code>s2</code> </dl></dl><dl><a name="924949"> </a><h4>Compatibility </h4><dl><a name="924953"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.<a name="949634"> </a><p></p><dt><code>MemCmp</code> can be used to test the equality of blocks in memory on all versions that support <code>MemCmp</code>; however, testing the sort ordering of blocks in memory works reliably only on Palm OS<sup>&#174;</sup> versions 3.5 and higher. On versions earlier than 3.2, <code>MemCmp</code> always returns a positive value if the blocks are unequal. On versions 3.2 and 3.3, <code>MemCmp</code> reliably returns positive to indicate <code>s1</code> &gt; <code>s2</code> and negative to indicate <code>s1</code> &lt; <code>s2</code> <strong>only</strong> if the characters that differ are less than 128 apart. If the difference is greater than that, <code>MemCmp</code> may return positive when it should return negative and vice versa. </dl></dl></dl><a name="924956"> </a><br> <br> <br><h3> MemDebugMode</h3><dl><dl><a name="924957"> </a><h4>Purpose </h4><dl><a name="924959"> </a><p></p><dt>Return the current debugging mode of the memory manager.</dl><a name="924960"> </a><h4>Prototype </h4><dl><a name="924961"> </a><dt><code>UInt16 MemDebugMode(void)</code></dl></dl><dl><a name="924962"> </a><h4>Parameters </h4><dl><a name="924963"> </a><p></p><dt>No parameters.</dl></dl><dl><a name="924964"> </a><h4>Result </h4><dl><a name="924968"> </a><p></p><dt>Returns debug flags as described for <a href="MemoryManager.html#925796">MemSetDebugMode</a>.</dl></dl></dl><a name="924971"> </a><br> <br> <br><h3> MemHandleCardNo</h3><dl><dl><a name="924972"> </a><h4>Purpose </h4><dl><a name="924974"> </a><p></p><dt>Return the card number a chunk resides in.</dl><a name="924975"> </a><h4>Prototype </h4><dl><a name="924976"> </a><dt><code>UInt16 MemHandleCardNo (MemHandle&nbsp;h)</code></dl></dl><dl><a name="924977"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924978"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE></dl><dl><a name="924979"> </a><h4>Result </h4><dl><a name="924980"> </a><p></p><dt>Returns the card number.</dl></dl><dl><a name="924981"> </a><h4>Comments </h4><dl><a name="924982"> </a><p></p><dt>Call this routine to retrieve the card number (0 or 1) a movable chunk resides on. </dl><a name="924983"> </a><h4>See Also </h4><dl><a name="924987"> </a><p></p><dt><code><a href="MemoryManager.html#925580"></code>MemPtrCardNo<code></a></code> </dl></dl></dl><a name="924989"> </a><br> <br> <br><h3> MemHandleDataStorage</h3><dl><dl><a name="924990"> </a><h4>Purpose </h4><dl><a name="924992"> </a><p></p><dt>Return <code>true</code> if the given handle is part of a data storage heap. If not, it's a handle in the dynamic heap.</dl><a name="924994"> </a><h4>Prototype </h4><dl><a name="924996"> </a><dt><code>Boolean MemHandleDataStorage (MemHandle&nbsp;h) </code></dl></dl><dl><a name="924997"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924998"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE></dl><dl><a name="924999"> </a><h4>Result </h4><dl><a name="925000"> </a><p></p><dt>Returns <code>true</code> if the handle is part of a data storage heap.</dl></dl><dl><a name="925001"> </a><h4>Comments </h4><dl><a name="925002"> </a><p></p><dt>Called by Fields package routines to determine if they need to worry about data storage write-protection when editing a text field.</dl><a name="925003"> </a><h4>See Also </h4><dl><a name="925007"> </a><p></p><dt><code><a href="MemoryManager.html#925596"></code>MemPtrDataStorage<code></a></code> </dl></dl></dl><a name="925010"> </a><br> <br> <br><h3> MemHandleFree</h3><dl><dl><a name="925011"> </a><h4>Purpose </h4><dl><a name="925013"> </a><p></p><dt>Dispose of a movable chunk.</dl><a name="925014"> </a><h4>Prototype </h4><dl><a name="925015"> </a><dt><code>Err MemHandleFree (MemHandle&nbsp;h)</code></dl></dl><dl><a name="925016"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925017"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE></dl><dl><a name="925018"> </a><h4>Result </h4><dl><a name="925019"> </a><p></p><dt>Returns 0 if no error, or memErrInvalidParam if an error occurs.</dl></dl><dl><a name="925020"> </a><h4>Comments </h4><dl><a name="925021"> </a><p></p><dt>Call this routine to dispose of a movable chunk.</dl><a name="925022"> </a><h4>See Also </h4><dl><a name="925026"> </a><p></p><dt><code><a href="MemoryManager.html#925071"></code>MemHandleNew<code></a></code> </dl></dl></dl><a name="925029"> </a><br> <br> <br><h3> MemHandleHeapID</h3><dl><dl><a name="925030"> </a><h4>Purpose </h4><dl><a name="925032"> </a><p></p><dt>Return the heap ID of a chunk.</dl><a name="925033"> </a><h4>Prototype </h4><dl><a name="925034"> </a><dt><code>UInt16 MemHandleHeapID (MemHandle&nbsp;h)</code></dl></dl><dl><a name="925035"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925036"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE></dl><dl><a name="925037"> </a><h4>Result </h4><dl><a name="925038"> </a><p></p><dt>Returns the heap ID of a chunk.</dl></dl><dl><a name="925039"> </a><h4>Comments </h4><dl><a name="925040"> </a><p></p><dt>Call this routine to get the heap ID of the heap a chunk resides in.</dl><a name="925041"> </a><h4>See Also </h4><dl><a name="925045"> </a><p></p><dt><code><a href="MemoryManager.html#925631"></code>MemPtrHeapID<code></a></code> </dl></dl></dl><a name="925048"> </a><br> <br> <br><h3> MemHandleLock</h3><dl><dl><a name="925049"> </a><h4>Purpose </h4><dl><a name="925050"> </a><p></p><dt>Lock a chunk and obtain a pointer to the chunk's data.</dl><a name="925051"> </a><h4>Prototype </h4><dl><a name="925053"> </a><dt><code>MemPtr MemHandleLock (MemHandle&nbsp;h)</code></dl></dl><dl><a name="925054"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925055"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE></dl><dl><a name="925056"> </a><h4>Result </h4><dl><a name="925057"> </a><p></p><dt>Returns a pointer to the chunk.</dl></dl><dl><a name="925058"> </a><h4>Comments </h4><dl><a name="925060"> </a><p></p><dt>Call this routine to lock a chunk and obtain a pointer to the chunk.<a name="925061"> </a><p></p><dt><code>MemHandleLock</code> and <code>MemHandleUnlock</code> should be used in pairs.</dl><a name="925062"> </a><h4>See Also </h4><dl><a name="925069"> </a><p></p><dt><code><a href="MemoryManager.html#925071"></code>MemHandleNew<code></a></code>, <code><a href="MemoryManager.html#925203"></code>MemHandleUnlock<code></a></code></dl></dl></dl><a name="925071"> </a><br> <br> <br><h3> MemHandleNew</h3><dl><dl><a name="925072"> </a><h4>Purpose </h4><dl><a name="925074"> </a><p></p><dt>Allocate a new movable chunk in the dynamic heap and returns a handle to it. </dl><a name="925075"> </a><h4>Prototype </h4><dl><a name="925077"> </a><dt><code>MemHandle MemHandleNew (UInt32&nbsp;size)</code></dl></dl><dl><a name="925078"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925079"> </a><CODE>-&gt; <code>size</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The desired size of the chunk.<br></TD></TR></TABLE></dl><dl><a name="925080"> </a><h4>Result </h4><dl><a name="925081"> </a><p></p><dt>Returns a handle to the new chunk, or 0 if unsuccessful.</dl></dl><dl><a name="925082"> </a><h4>Comments </h4><dl><a name="925083"> </a><p></p><dt>Use this call to allocate dynamic memory. Before you can write data to the memory chunk that <code>MemHandleNew</code> allocates, you must call <code><a href="MemoryManager.html#925048"></code>MemHandleLock<code></a></code> to lock the chunk and get a pointer to it. </dl><a name="925087"> </a><h4>See Also </h4><dl><a name="925100"> </a><p></p><dt><code><a href="MemoryManager.html#925616"></code>MemPtrFree<code></a></code>, <code><a href="MemoryManager.html#925646"></code>MemPtrNew<code></a></code>, <code><a href="MemoryManager.html#925010"></code>MemHandleFree<code></a></code>, <code><a href="MemoryManager.html#925048"></code>MemHandleLock<code></a></code></dl></dl></dl><a name="925103"> </a><br> <br> <br><h3> MemHandleResize</h3><dl><dl><a name="925104"> </a><h4>Purpose </h4><dl><a name="925105"> </a><p></p><dt>Resize a chunk.</dl><a name="925106"> </a><h4>Prototype </h4><dl><a name="925108"> </a><dt><code>Err MemHandleResize (MemHandle&nbsp;h, UInt32&nbsp;newSize)</code></dl></dl><dl><a name="925109"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925110"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925111"> </a><CODE>-&gt; <code>newSize</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The new desired size.<br></TD></TR></TABLE></dl><dl><a name="925112"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925113"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925115"> </a><CODE>memErrInvalidParam</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Invalid parameter passed.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925117"> </a><CODE>memErrNotEnoughSpace</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Not enough free space in heap to grow chunk.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925119"> </a><CODE>memErrChunkLocked</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Can't grow chunk because it's locked. <br></TD></TR></TABLE></dl><dl><a name="925120"> </a><h4>Comments </h4><dl><a name="925121"> </a><p></p><dt>Call this routine to resize a chunk. This routine is always successful when shrinking the size of a chunk, even if the chunk is locked. When growing a chunk, it first attempts to grab free space immediately following the chunk so that the chunk does not have to move. If the chunk has to move to another free area of the heap to grow, it must be movable and have a lock count of 0. <a name="925122"> </a><p></p><dt>On devices running version 2.0 or earlier of Palm OS, the <code>MemHandleResize</code> function tries to resize the chunk only within the same heap, whereas <code><a href="DataAndResourceManager.html#927127"></code>DmResizeRecord<code></a></code> will look for space in other data heaps if it can't find enough space in the original heap. </dl><a name="955500"> </a><h4>See Also </h4><dl><a name="955507"> </a><p></p><dt><code><a href="MemoryManager.html#925071"></code>MemHandleNew<code></a></code>, <code><a href="MemoryManager.html#925160"></code>MemHandleSize<code></a></code></dl></dl></dl><a name="955510"> </a><br> <br> <br><h3> MemHandleSetOwner</h3><dl><dl><a name="925137"> </a><h4>Purpose </h4><dl><a name="925138"> </a><p></p><dt>Set the owner ID of a chunk.</dl><a name="925139"> </a><h4>Prototype </h4><dl><a name="925141"> </a><dt><code>Err MemHandleSetOwner (MemHandle&nbsp;h, UInt16&nbsp;owner)</code></dl></dl><dl><a name="925142"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925143"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925144"> </a><CODE>-&gt; <code>owner</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>New owner ID of the chunk. Specify 0 to set the owner to the operating system.<br></TD></TR></TABLE></dl><dl><a name="925145"> </a><h4>Result </h4><dl><a name="925146"> </a><p></p><dt>Returns 0 if no error, or memErrInvalidParam if an error occurs.</dl></dl><dl><a name="925147"> </a><h4>Comments </h4><dl><a name="925151"> </a><p></p><dt>When you allocate a parameter block to pass to <code><a href="SystemManager.html#925699"></code>SysUIAppSwitch<code></a></code> or <code><a href="SystemManager.html#924917"></code>SysAppLaunch<code></a></code>, you must call <code><a href="MemoryManager.html#925698"></code>MemPtrSetOwner<code></a></code> to grant ownership of the parameter block chunk to the OS (your application is originally set as the owner). If the parameter block structure references any chunks by handle, you also must call <code>MemHandleSetOwner</code> to grant ownership of those blocks to the OS. If you don't change the ownership of these chunks, they will get freed before the application you're launching has a chance to use them.</dl></dl></dl><a name="925160"> </a><br> <br> <br><h3> MemHandleSize</h3><dl><dl><a name="925161"> </a><h4>Purpose </h4><dl><a name="925163"> </a><p></p><dt>Return the requested size of a chunk.</dl><a name="925164"> </a><h4>Prototype </h4><dl><a name="925166"> </a><dt><code>UInt32 MemHandleSize (MemHandle&nbsp;h)</code></dl></dl><dl><a name="925167"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925168"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE></dl><dl><a name="925169"> </a><h4>Result </h4><dl><a name="925170"> </a><p></p><dt>Returns the requested size of the chunk.</dl></dl><dl><a name="925171"> </a><h4>Comments </h4><dl><a name="925172"> </a><p></p><dt>Call this routine to get the size originally requested for a chunk.</dl><a name="925173"> </a><h4>See Also </h4><dl><a name="925177"> </a><p></p><dt><code><a href="MemoryManager.html#925103"></code>MemHandleResize<code></a></code></dl></dl></dl><a name="925180"> </a><br> <br> <br><h3> MemHandleToLocalID</h3><dl><dl><a name="925181"> </a><h4>Purpose </h4><dl><a name="925182"> </a><p></p><dt>Convert a handle into a local chunk ID which is card relative.</dl><a name="925183"> </a><h4>Prototype </h4><dl><a name="925185"> </a><dt><code>LocalID MemHandleToLocalID (MemHandle&nbsp;h)</code></dl></dl><dl><a name="925186"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925187"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Chunk handle.<br></TD></TR></TABLE></dl><dl><a name="925188"> </a><h4>Result </h4><dl><a name="925189"> </a><p></p><dt>Returns local ID, or NULL (0) if unsuccessful.</dl></dl><dl><a name="925190"> </a><h4>Comments </h4><dl><a name="925192"> </a><p></p><dt>Call this routine to convert a chunk handle to a local ID.</dl><a name="925193"> </a><h4>See Also </h4><dl><a name="925200"> </a><p></p><dt><code><a href="MemoryManager.html#925428"></code>MemLocalIDToGlobal<code></a></code>, <code><a href="MemoryManager.html#925449"></code>MemLocalIDToLockedPtr<code></a></code></dl></dl></dl><a name="925203"> </a><br> <br> <br><h3> MemHandleUnlock</h3><dl><dl><a name="925204"> </a><h4>Purpose </h4><dl><a name="925206"> </a><p></p><dt>Unlock a chunk given a chunk handle.</dl><a name="925207"> </a><h4>Prototype </h4><dl><a name="925209"> </a><dt><code>Err MemHandleUnlock (MemHandle&nbsp;h)</code></dl></dl><dl><a name="925210"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925211"> </a><CODE>-&gt; <code>h</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The chunk handle.<br></TD></TR></TABLE></dl><dl><a name="925212"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925213"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925215"> </a><CODE>memErrInvalidParam</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Invalid parameter passed.<br></TD></TR></TABLE></dl><dl><a name="925216"> </a><h4>Comments </h4><dl><a name="925217"> </a><p></p><dt>Call this routine to decrement the lock count for a chunk. <a name="925218"> </a><p></p><dt><code>MemHandleLock</code> and <code>MemHandleUnlock</code> should be used in pairs.</dl><a name="925219"> </a><h4>See Also </h4><dl><a name="925223"> </a><p></p><dt><code><a href="MemoryManager.html#925048"></code>MemHandleLock<code></a></code> </dl></dl></dl><a name="925225"> </a><br> <br> <br><h3> MemHeapCheck</h3><dl><dl><a name="925226"> </a><h4>Purpose </h4><dl><a name="925227"> </a><p></p><dt>Check validity of a given heap.</dl><a name="925228"> </a><h4>Prototype </h4><dl><a name="925230"> </a><dt><code>Err MemHeapCheck (UInt16&nbsp;heapID)</code></dl></dl><dl><a name="925231"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925232"> </a><CODE><code>heapID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of heap to check.<br></TD></TR></TABLE></dl><dl><a name="925233"> </a><h4>Result </h4><dl><a name="925234"> </a><p></p><dt>Returns 0 if no error. </dl></dl><dl><a name="925235"> </a><h4>See Also </h4><dl><a name="925242"> </a><p></p><dt><code><a href="MemoryManager.html#924956"></code>MemDebugMode<code></a></code>, <code><a href="MemoryManager.html#925796"></code>MemSetDebugMode<code></a></code></dl></dl></dl><a name="925245"> </a><br> <br> <br><h3> MemHeapCompact</h3><dl><dl><a name="925246"> </a><h4>Purpose </h4><dl><a name="925247"> </a><p></p><dt>Compact a heap.</dl><a name="925248"> </a><h4>Prototype </h4><dl><a name="925250"> </a><dt><code>Err MemHeapCompact (UInt16&nbsp;heapID)</code></dl></dl><dl><a name="925251"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925252"> </a><CODE>-&gt; <code>heapID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of the heap to compact.<br></TD></TR></TABLE></dl><dl><a name="925253"> </a><h4>Result </h4><dl><a name="925254"> </a><p></p><dt>Always returns 0.</dl></dl><dl><a name="925255"> </a><h4>Comments </h4><dl><a name="925256"> </a><p></p><dt>Most applications never need to call this function explicitly. The system software calls this function at various times; for example, during memory allocation (if sufficient free space is not available) and during system reboot.<a name="925258"> </a><p></p><dt>Call this routine to compact a heap and merge all free space. This routine attempts to move all movable chunks to the start of the heap and merge all free space in the center of the heap.</dl></dl></dl><a name="925260"> </a><br> <br> <br><h3> MemHeapDynamic</h3><dl><dl><a name="925261"> </a><h4>Purpose </h4><dl><a name="925263"> </a><p></p><dt>Return <code>true</code> if the given heap is a dynamic heap.</dl><a name="925264"> </a><h4>Prototype </h4><dl><a name="925266"> </a><dt><code>Boolean MemHeapDynamic (UInt16&nbsp;heapID) </code></dl></dl><dl><a name="925267"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925268"> </a><CODE><code>heapID</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of the heap to be tested.<br></TD></TR></TABLE></dl><dl><a name="925269"> </a><h4>Result </h4><dl><a name="925270"> </a><p></p><dt>Returns <code>true</code> if dynamic, <code>false</code> if not.</dl></dl><dl><a name="925271"> </a><h4>Comments </h4><dl><a name="925272"> </a><p></p><dt>Dynamic heaps are used for volatile storage, application stacks, globals, and dynamically allocated memory. <a name="933194"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>In Palm OS 3.5, the dynamic heap is sized based on the amount of memory available, and is generally larger than before.<hr><br></blockquote></dl><a name="925273"> </a><h4>See Also </h4><dl><a name="925280"> </a><p></p><dt><code><a href="MemoryManager.html#925537"></code>MemNumHeaps<code></a></code>, <code><a href="MemoryManager.html#925346"></code>MemHeapID<code></a></code></dl></dl></dl><a name="925283"> </a><br> <br> <br><h3> MemHeapFlags</h3><dl><dl><a name="925284"> </a><h4>Purpose </h4><dl><a name="925285"> </a><p></p><dt>Return the heap flags for a heap.</dl><a name="925286"> </a><h4>Prototype </h4><dl><a name="925288"> </a><dt><code>UInt16 MemHeapFlags (UInt16&nbsp;heapID)</code></dl></dl><dl><a name="925289"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925290"> </a><CODE>-&gt; <code>heapID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of heap.<br></TD></TR></TABLE></dl><dl><a name="925291"> </a><h4>Result </h4><dl><a name="925292"> </a><p></p><dt>Returns the heap flags.</dl></dl><dl><a name="925293"> </a><h4>Comments </h4><dl><a name="925294"> </a><p></p><dt>Call this routine to retrieve the heap flags for a heap. The flags can be examined to determine if the heap is ROM based or not. ROM-based heaps have the memHeapFlagReadOnly bit set.</dl><a name="925296"> </a><h4>See Also </h4><dl><a name="925303"> </a><p></p><dt><code><a href="MemoryManager.html#925537"></code>MemNumHeaps<code></a></code>, <code><a href="MemoryManager.html#925346"></code>MemHeapID<code></a></code></dl></dl></dl><a name="925306"> </a><br> <br> <br><h3> MemHeapFreeBytes</h3><dl><dl><a name="925307"> </a><h4>Purpose </h4><dl><a name="925308"> </a><p></p><dt>Return the total number of free bytes in a heap and the size of the largest free chunk in the heap.</dl><a name="925310"> </a><h4>Prototype </h4><dl><a name="925312"> </a><dt><code>Err MemHeapFreeBytes (UInt16&nbsp;heapID, UInt32*&nbsp;freeP, UInt32*&nbsp;maxP)</code></dl></dl><dl><a name="925313"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925314"> </a><CODE>-&gt; <code>heapID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of heap.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925315"> </a><CODE>&lt;-&gt; <code>freeP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a variable of type <code>UInt32</code> for free bytes.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925316"> </a><CODE>&lt;-&gt; <code>maxP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a variable of type <code>UInt32</code> for max free chunk size.<br></TD></TR></TABLE></dl><dl><a name="925317"> </a><h4>Result </h4><dl><a name="925318"> </a><p></p><dt>Always returns 0.</dl></dl><dl><a name="925319"> </a><h4>Comments </h4><dl><a name="925320"> </a><p></p><dt>This routine doesn't compact the heap but may be used to determine in advance whether an allocation request will succeed. Before allocating memory, call this function and test the return value of <code>maxP</code> to determine whether enough free space to fulfill your allocation request exists. If not, you may make more space available by calling the <code><a href="MemoryManager.html#925245"></code>MemHeapCompact<code></a> </code>function. An alternative approach is to just call the <code><a href="MemoryManager.html#925245"></code>MemHeapCompact<code></a> </code>function as necessary when an error is returned by the <code><a href="MemoryManager.html#925646"></code>MemPtrNew<code></a></code> or <code><a href="MemoryManager.html#925071"></code>MemHandleNew<code></a></code> functions. </dl><a name="925333"> </a><h4>See Also </h4><dl><a name="925343"> </a><p></p><dt><code><a href="MemoryManager.html#925394"></code>MemHeapSize<code></a></code>, <code><a href="MemoryManager.html#925346"></code>MemHeapID<code></a></code>, <code><a href="MemoryManager.html#925245"></code>MemHeapCompact<code></a></code></dl></dl></dl><a name="925346"> </a><br> <br> <br><h3> MemHeapID</h3><dl><dl><a name="925347"> </a><h4>Purpose </h4><dl><a name="925348"> </a><p></p><dt>Return the heap ID for a heap, given its index and the card number.</dl><a name="925349"> </a><h4>Prototype </h4><dl><a name="925351"> </a><dt><code>UInt16 MemHeapID (UInt16&nbsp;cardNo, UInt16&nbsp;heapIndex)</code></dl></dl><dl><a name="925352"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925353"> </a><CODE>-&gt; <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The card number, either 0 or 1.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925354"> </a><CODE>-&gt; <code>heapIndex</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The heap index, anywhere from 0 to <code><a href="MemoryManager.html#925537"></code>MemNumHeaps<code></a></code> - 1.<br></TD></TR></TABLE></dl><dl><a name="925359"> </a><h4>Result </h4><dl><a name="925360"> </a><p></p><dt>Returns the heap ID.</dl></dl><dl><a name="925361"> </a><h4>Comments </h4><dl><a name="925363"> </a><p></p><dt>Call this routine to retrieve the heap ID of a heap, given the heap index and the card number. A heap ID must be used to obtain information on a heap such as its size, free bytes, etc., and is also passed to any routines which manipulate heaps.</dl><a name="925364"> </a><h4>See Also </h4><dl><a name="925368"> </a><p></p><dt><code><a href="MemoryManager.html#925537"></code>MemNumHeaps<code></a></code> </dl></dl></dl><a name="925370"> </a><br> <br> <br><h3> MemHeapScramble</h3><dl><dl><a name="925371"> </a><h4>Purpose </h4><dl><a name="925372"> </a><p></p><dt>Scramble the specified heap. </dl><a name="925373"> </a><h4>Prototype </h4><dl><a name="925375"> </a><dt><code>Err MemHeapScramble (UInt16&nbsp;heapID)</code></dl></dl><dl><a name="925376"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925377"> </a><CODE><code>heapID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of heap to scramble.<br></TD></TR></TABLE></dl><dl><a name="925378"> </a><h4>Comments </h4><dl><a name="925379"> </a><p></p><dt>The system attempts to move each movable chunk.<a name="925381"> </a><p></p><dt>Useful for debugging.</dl></dl><dl><a name="925382"> </a><h4>Result </h4><dl><a name="925383"> </a><p></p><dt>Always returns 0.</dl></dl><dl><a name="925384"> </a><h4>See Also </h4><dl><a name="925391"> </a><p></p><dt><code><a href="MemoryManager.html#924956"></code>MemDebugMode<code></a></code>, <code><a href="MemoryManager.html#925796"></code>MemSetDebugMode<code></a></code></dl></dl></dl><a name="925394"> </a><br> <br> <br><h3> MemHeapSize</h3><dl><dl><a name="925395"> </a><h4>Purpose </h4><dl><a name="925396"> </a><p></p><dt>Return the total size of a heap including the heap header.</dl><a name="925397"> </a><h4>Prototype </h4><dl><a name="925399"> </a><dt><code>UInt32 MemHeapSize (UInt16&nbsp;heapID)</code></dl></dl><dl><a name="925400"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925401"> </a><CODE>-&gt; <code>heapID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of heap.<br></TD></TR></TABLE></dl><dl><a name="925402"> </a><h4>Result </h4><dl><a name="925403"> </a><p></p><dt>Returns the total size of the heap.</dl></dl><dl><a name="925404"> </a><h4>See Also </h4><dl><a name="925411"> </a><p></p><dt><code><a href="MemoryManager.html#925306"></code>MemHeapFreeBytes<code></a></code>, <code><a href="MemoryManager.html#925346"></code>MemHeapID<code></a></code></dl></dl></dl><a name="925414"> </a><br> <br> <br><h3> MemLocalIDKind</h3><dl><dl><a name="925415"> </a><h4>Purpose </h4><dl><a name="925416"> </a><p></p><dt>Return whether or not a local ID references a handle or a pointer.</dl><a name="925417"> </a><h4>Prototype </h4><dl><a name="925419"> </a><dt><code>LocalIDKind MemLocalIDKind (LocalID&nbsp;local)</code></dl></dl><dl><a name="925420"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925421"> </a><CODE>-&gt; <code>local</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Local ID to query<br></TD></TR></TABLE></dl><dl><a name="925422"> </a><h4>Result </h4><dl><a name="925423"> </a><p></p><dt>Returns LocalIDKind, or a memIDHandle or memIDPtr (see MemoryMgr.h).</dl></dl><dl><a name="925424"> </a><h4>Comments </h4><dl><a name="925425"> </a><p></p><dt>This routine determines if the given local ID is to a nonmovable (memIDPtr) or movable (memIDHandle) chunk. </dl></dl></dl><a name="925428"> </a><br> <br> <br><h3> MemLocalIDToGlobal</h3><dl><dl><a name="925429"> </a><h4>Purpose </h4><dl><a name="925431"> </a><p></p><dt>Convert a local ID, which is card relative, into a global pointer in the designated card.</dl><a name="925432"> </a><h4>Prototype </h4><dl><a name="925434"> </a><dt><code>MemPtr MemLocalIDToGlobal (LocalID&nbsp;local, UInt16&nbsp;cardNo)</code></dl></dl><dl><a name="925435"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925436"> </a><CODE>-&gt; <code>local</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The local ID to convert.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925437"> </a><CODE>-&gt; <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Memory card the chunk resides in.<br></TD></TR></TABLE></dl><dl><a name="925438"> </a><h4>Result </h4><dl><a name="925439"> </a><p></p><dt>Returns pointer or handle to chunk.</dl></dl><dl><a name="925440"> </a><h4>See Also </h4><dl><a name="925447"> </a><p></p><dt><code><a href="MemoryManager.html#925414"></code>MemLocalIDKind<code></a></code>, <code><a href="MemoryManager.html#925449"></code>MemLocalIDToLockedPtr<code></a></code></dl></dl></dl><a name="925449"> </a><br> <br> <br><h3> MemLocalIDToLockedPtr</h3><dl><dl><a name="925450"> </a><h4>Purpose </h4><dl><a name="925451"> </a><p></p><dt>Return a pointer to a chunk given its local ID and card number.<a name="925452"> </a><p></p><dt>If the local ID references a movable chunk handle, this routine automatically locks the chunk before returning.</dl><a name="925453"> </a><h4>Prototype </h4><dl><a name="925455"> </a><dt><code>MemPtr MemLocalIDToLockedPtr (LocalID&nbsp;local, UInt16&nbsp;cardNo)</code></dl></dl><dl><a name="925456"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925457"> </a><CODE><code>local</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Local chunk ID. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925458"> </a><CODE><code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Card number.<br></TD></TR></TABLE></dl><dl><a name="925459"> </a><h4>Result </h4><dl><a name="925460"> </a><p></p><dt>Returns pointer to chunk, or 0 if an error occurs.</dl></dl><dl><a name="925461"> </a><h4>See Also </h4><dl><a name="925471"> </a><p></p><dt><code><a href="MemoryManager.html#925428"></code>MemLocalIDToGlobal<code></a></code>, <code><a href="MemoryManager.html#925480"></code>MemLocalIDToPtr<code></a></code>, <code><a href="MemoryManager.html#925414"></code>MemLocalIDKind<code></a></code>, <code><a href="MemoryManager.html#925736"></code>MemPtrToLocalID<code></a></code>, <code><a href="MemoryManager.html#925180"></code>MemHandleToLocalID<code></a></code></dl></dl></dl><a name="925480"> </a><br> <br> <br><h3> MemLocalIDToPtr</h3><dl><dl><a name="925481"> </a><h4>Purpose </h4><dl><a name="925482"> </a><p></p><dt>Return pointer to chunk, given the local ID and card number.</dl><a name="925483"> </a><h4>Prototype </h4><dl><a name="925485"> </a><dt><code>MemPtr MemLocalIDToPtr (LocalID&nbsp;local, UInt16&nbsp;cardNo)</code></dl></dl><dl><a name="925486"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925487"> </a><CODE>-&gt; <code>local</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Local ID to query.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925488"> </a><CODE>-&gt; <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Card number the chunk resides in.<br></TD></TR></TABLE></dl><dl><a name="925489"> </a><h4>Result </h4><dl><a name="925490"> </a><p></p><dt>Returns a pointer to the chunk, or 0 if error.</dl></dl><dl><a name="925491"> </a><h4>Comments </h4><dl><a name="925492"> </a><p></p><dt>If the local ID references a movable chunk and that chunk is <strong>not</strong> locked, this function returns 0 to indicate an error.</dl><a name="925493"> </a><h4>See Also </h4><dl><a name="925500"> </a><p></p><dt><code><a href="MemoryManager.html#925428"></code>MemLocalIDToGlobal<code></a></code>, <code><a href="MemoryManager.html#925449"></code>MemLocalIDToLockedPtr<code></a></code></dl></dl></dl><a name="925502"> </a><br> <br> <br><h3> MemMove</h3><dl><dl><a name="925503"> </a><h4>Purpose </h4><dl><a name="925504"> </a><p></p><dt>Move a range of memory to another rangein the dynamic heap. </dl><a name="925506"> </a><h4>Prototype </h4><dl><a name="925508"> </a><dt><code>Err MemMove (void*&nbsp;dstP, const&nbsp;void*&nbsp;sP, Int32&nbsp;numBytes)</code></dl></dl><dl><a name="925509"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925510"> </a><CODE><code>dstP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to destination.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925511"> </a><CODE><code>sP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to source.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925512"> </a><CODE><code>numBytes</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to move.<br></TD></TR></TABLE></dl><dl><a name="925513"> </a><h4>Result </h4><dl><a name="925514"> </a><p></p><dt>Always returns 0.</dl></dl><dl><a name="925515"> </a><h4>Comments </h4><dl><a name="925516"> </a><p></p><dt>Handles overlapping ranges.<a name="925520"> </a><p></p><dt>For operations where the destination is in a data heap, see <a href="DataAndResourceManager.html#927305">DmSet</a>, <a href="DataAndResourceManager.html#927456">DmWrite</a>, and related functions.</dl></dl></dl><a name="925525"> </a><br> <br> <br><h3> MemNumCards</h3><dl><dl><a name="925526"> </a><h4>Purpose </h4><dl><a name="925527"> </a><p></p><dt>Return the number of memory card slots in the system. Not all slots need to be populated.</dl><a name="925528"> </a><h4>Prototype </h4><dl><a name="925530"> </a><dt><code>UInt16 MemNumCards (void)</code></dl></dl><dl><a name="925531"> </a><h4>Parameters </h4><dl><a name="925532"> </a><p></p><dt>None.</dl></dl><dl><a name="925533"> </a><h4>Result </h4><dl><a name="925534"> </a><p></p><dt>Returns number of slots in the system.</dl></dl></dl><a name="925537"> </a><br> <br> <br><h3> MemNumHeaps</h3><dl><dl><a name="925538"> </a><h4>Purpose </h4><dl><a name="925539"> </a><p></p><dt>Return the number of heaps available on a particular card.</dl><a name="925540"> </a><h4>Prototype </h4><dl><a name="925542"> </a><dt><code>UInt16 MemNumHeaps (UInt16&nbsp;cardNo)</code></dl></dl><dl><a name="925543"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925544"> </a><CODE>-&gt; <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The card number; either 0 or 1.<br></TD></TR></TABLE></dl><dl><a name="925545"> </a><h4>Result </h4><dl><a name="925547"> </a><p></p><dt>Number of heaps available, including ROM- and RAM-based heaps.</dl></dl><dl><a name="925548"> </a><h4>Comments </h4><dl><a name="925549"> </a><p></p><dt>Call this routine to retrieve the total number of heaps on a memory card. The information can be obtained by calling <a href="MemoryManager.html#925394">MemHeapSize</a>, <a href="MemoryManager.html#925306">MemHeapFreeBytes</a>, and <a href="MemoryManager.html#925283">MemHeapFlags</a> on each heap using its heap ID. The heap ID is obtained by calling <a href="MemoryManager.html#925346">MemHeapID</a> with the card number and the heap index, which can be any value from 0 to <code>MemNumHeaps</code>.</dl></dl></dl><a name="925563"> </a><br> <br> <br><h3> MemNumRAMHeaps</h3><dl><dl><a name="925564"> </a><h4>Purpose </h4><dl><a name="925565"> </a><p></p><dt>Return the number of RAM heaps in the given card.</dl><a name="925566"> </a><h4>Prototype </h4><dl><a name="925568"> </a><dt><code>UInt16 MemNumRAMHeaps (UInt16&nbsp;cardNo)</code></dl></dl><dl><a name="925569"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925570"> </a><CODE><code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The card number.<br></TD></TR></TABLE></dl><dl><a name="925571"> </a><h4>Result </h4><dl><a name="925572"> </a><p></p><dt>Returns the number of RAM heaps.</dl></dl><dl><a name="925573"> </a><h4>See Also </h4><dl><a name="925577"> </a><p></p><dt><code><a href="MemoryManager.html#925525"></code>MemNumCards<code></a></code> </dl></dl></dl><a name="925580"> </a><br> <br> <br><h3> MemPtrCardNo</h3><dl><dl><a name="925581"> </a><h4>Purpose </h4><dl><a name="925582"> </a><p></p><dt>Return the card number (0 or 1) a nonmovable chunk resides on.</dl><a name="925583"> </a><h4>Prototype </h4><dl><a name="925585"> </a><dt><code>UInt16 MemPtrCardNo (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925586"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925587"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the chunk.<br></TD></TR></TABLE></dl><dl><a name="925588"> </a><h4>Result </h4><dl><a name="925589"> </a><p></p><dt>Returns the card number.</dl></dl><dl><a name="925590"> </a><h4>See Also </h4><dl><a name="925594"> </a><p></p><dt><code><a href="MemoryManager.html#924971"></code>MemHandleCardNo<code></a></code> </dl></dl></dl><a name="925596"> </a><br> <br> <br><h3> MemPtrDataStorage</h3><dl><dl><a name="925597"> </a><h4>Purpose </h4><dl><a name="925598"> </a><p></p><dt>Return <code>true</code> if the given pointer is part of a data storage heap; if not, it is a pointer in the dynamic heap.</dl><a name="925599"> </a><h4>Prototype </h4><dl><a name="925601"> </a><dt><code>Boolean MemPtrDataStorage (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925602"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925603"> </a><CODE><code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a chunk.<br></TD></TR></TABLE></dl><dl><a name="925604"> </a><h4>Result </h4><dl><a name="925606"> </a><p></p><dt>Returns <code>true</code> if the chunk is part of a data storage heap.</dl></dl><dl><a name="925607"> </a><h4>Comments </h4><dl><a name="925608"> </a><p></p><dt>Called by Fields package to determine if it needs to worry about data storage write-protection when editing a text field.</dl><a name="925609"> </a><h4>See Also </h4><dl><a name="925613"> </a><p></p><dt><code><a href="MemoryManager.html#925260"></code>MemHeapDynamic<code></a></code></dl></dl></dl><a name="925616"> </a><br> <br> <br><h3> MemPtrFree</h3><dl><dl><a name="925617"> </a><h4>Purpose </h4><dl><a name="925618"> </a><p></p><dt>Macro to dispose of a chunk.</dl><a name="925619"> </a><h4>Prototype </h4><dl><a name="925621"> </a><dt><code>Err MemPtrFree (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925622"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925623"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a chunk.<br></TD></TR></TABLE></dl><dl><a name="925624"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925626"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>If no error or <code>memErrInvalidParam</code> (invalid parameter).<br></TD></TR></TABLE></dl><dl><a name="925627"> </a><h4>Comments </h4><dl><a name="925628"> </a><p></p><dt>Call this routine to dispose of a nonmovable chunk. </dl></dl></dl><a name="925631"> </a><br> <br> <br><h3> MemPtrHeapID</h3><dl><dl><a name="925632"> </a><h4>Purpose </h4><dl><a name="925635"> </a><p></p><dt>Return the heap ID of a chunk.</dl><a name="925636"> </a><h4>Prototype </h4><dl><a name="925637"> </a><dt><code>UInt16 MemPtrHeapID (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925638"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925639"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the chunk.<br></TD></TR></TABLE></dl><dl><a name="925640"> </a><h4>Result </h4><dl><a name="925641"> </a><p></p><dt>Returns the heap ID of a chunk.</dl></dl><dl><a name="925642"> </a><h4>Comments </h4><dl><a name="925643"> </a><p></p><dt>Call this routine to get the heap ID of the heap a chunk resides in.</dl></dl></dl><a name="925646"> </a><br> <br> <br><h3> MemPtrNew</h3><dl><dl><a name="925647"> </a><h4>Purpose </h4><dl><a name="925649"> </a><p></p><dt>Allocate a new nonmovable chunk in the dynamic heap.</dl><a name="925650"> </a><h4>Prototype </h4><dl><a name="925652"> </a><dt><code>MemPtr MemPtrNew (UInt32&nbsp;size)</code></dl></dl><dl><a name="925653"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925654"> </a><CODE>-&gt; <code>size</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The desired size of the chunk.<br></TD></TR></TABLE></dl><dl><a name="925655"> </a><h4>Result </h4><dl><a name="925656"> </a><p></p><dt>Returns pointer to the new chunk, or 0 if unsuccessful.</dl></dl><dl><a name="925657"> </a><h4>Comments </h4><dl><a name="925658"> </a><p></p><dt>This routine allocates a nonmovable chunk in the dynamic heap and returns a pointer to the chunk. Applications can use it when allocating dynamic memory. <a name="931930"> </a><p></p><dt>In Palm OS 3.5, the dynamic heap is sized based on the amount of memory available, and is generally larger than before.<a name="931980"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>You cannot allocate a zero-size reference block.<hr><br></blockquote></dl></dl></dl><a name="925661"> </a><br> <br> <br><h3> MemPtrRecoverHandle</h3><dl><dl><a name="925662"> </a><h4>Purpose </h4><dl><a name="925663"> </a><p></p><dt>Recover the handle of a movable chunk, given a pointer to its data.</dl><a name="925664"> </a><h4>Prototype </h4><dl><a name="925666"> </a><dt><code>MemHandle MemPtrRecoverHandle (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925667"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925668"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the chunk.<br></TD></TR></TABLE></dl><dl><a name="925669"> </a><h4>Result </h4><dl><a name="925670"> </a><p></p><dt>Returns the handle of the chunk, or 0 if unsuccessful.</dl></dl><dl><a name="925671"> </a><h4>Comments </h4><dl><a name="925672"> </a><p></p><dt>Don't call this function for pointers in ROM or nonmovable data chunks.</dl></dl></dl><a name="925675"> </a><br> <br> <br><h3> MemPtrResize</h3><dl><dl><a name="925676"> </a><h4>Purpose </h4><dl><a name="925677"> </a><p></p><dt>Resize a chunk.</dl><a name="925678"> </a><h4>Prototype </h4><dl><a name="925680"> </a><dt><code>Err MemPtrResize (MemPtr&nbsp;p, UInt32&nbsp;newSize)</code></dl></dl><dl><a name="925681"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925682"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the chunk.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925683"> </a><CODE>-&gt; <code>newSize</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The new desired size.<br></TD></TR></TABLE></dl><dl><a name="925684"> </a><h4>Result </h4><dl><a name="925685"> </a><p></p><dt>Returns 0 if no error, or memErrNotEnoughSpace memErrInvalidParam, or memErrChunkLocked if an error occurs.</dl></dl><dl><a name="925686"> </a><h4>Comments </h4><dl><a name="925687"> </a><p></p><dt>Call this routine to resize a locked chunk. This routine is always successful when shrinking the size of a chunk. When growing a chunk, it attempts to use free space immediately following the chunk.</dl><a name="925688"> </a><h4>See Also </h4><dl><a name="925695"> </a><p></p><dt><code><a href="MemoryManager.html#925722"></code>MemPtrSize<code></a></code>, <code><a href="MemoryManager.html#925103"></code>MemHandleResize<code></a></code> </dl></dl></dl><a name="925698"> </a><br> <br> <br><h3> MemPtrSetOwner</h3><dl><dl><a name="925699"> </a><h4>Purpose </h4><dl><a name="925700"> </a><p></p><dt>Set the owner ID of a chunk.</dl><a name="925701"> </a><h4>Prototype </h4><dl><a name="925703"> </a><dt><code>Err MemPtrSetOwner (MemPtr&nbsp;p, UInt16&nbsp;owner)</code></dl></dl><dl><a name="925704"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925705"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the chunk.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925706"> </a><CODE>-&gt; <code>owner</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>New owner ID of the chunk. Specify 0 to set the owner to the operating system.<br></TD></TR></TABLE></dl><dl><a name="925707"> </a><h4>Result </h4><dl><a name="925708"> </a><p></p><dt>Returns 0 if no error, or memErrInvalidParam if an error occurs.</dl></dl><dl><a name="925709"> </a><h4>Comments </h4><dl><a name="925713"> </a><p></p><dt>When you allocate a parameter block to pass to <code><a href="SystemManager.html#925699"></code>SysUIAppSwitch<code></a></code> or <code><a href="SystemManager.html#924917"></code>SysAppLaunch<code></a></code>, you must call <code>MemPtrSetOwner</code> or <code><a href="MemoryManager.html#955510"></code>MemHandleSetOwner<code></a></code> to grant ownership of the parameter block chunk, and any other chunks referenced in it, to the OS (your application is originally set as the owner). If you don't change the ownership of the parameter block, it will get freed before the application you're launching has a chance to use it.</dl></dl></dl><a name="925722"> </a><br> <br> <br><h3> MemPtrSize</h3><dl><dl><a name="925723"> </a><h4>Purpose </h4><dl><a name="925724"> </a><p></p><dt>Return the size of a chunk.</dl><a name="925725"> </a><h4>Prototype </h4><dl><a name="925727"> </a><dt><code>UInt32 MemPtrSize (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925728"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925729"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the chunk.<br></TD></TR></TABLE></dl><dl><a name="925730"> </a><h4>Result </h4><dl><a name="925731"> </a><p></p><dt>The requested size of the chunk.</dl></dl><dl><a name="925732"> </a><h4>Comments </h4><dl><a name="925733"> </a><p></p><dt>Call this routine to get the original requested size of a chunk.</dl></dl></dl><a name="925736"> </a><br> <br> <br><h3> MemPtrToLocalID</h3><dl><dl><a name="925737"> </a><h4>Purpose </h4><dl><a name="925738"> </a><p></p><dt>Convert a pointer into a card-relative local chunk ID. </dl><a name="925739"> </a><h4>Prototype </h4><dl><a name="925741"> </a><dt><code>LocalID MemPtrToLocalID (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925742"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925743"> </a><CODE>-&gt; <code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a chunk.<br></TD></TR></TABLE></dl><dl><a name="925744"> </a><h4>Result </h4><dl><a name="925745"> </a><p></p><dt>Returns the local ID of the chunk.</dl></dl><dl><a name="925746"> </a><h4>Comments </h4><dl><a name="925748"> </a><p></p><dt>Call this routine to convert a chunk pointer to a local ID.</dl><a name="925749"> </a><h4>See Also </h4><dl><a name="925753"> </a><p></p><dt><code><a href="MemoryManager.html#925480"></code>MemLocalIDToPtr<code></a></code> </dl></dl></dl><a name="925756"> </a><br> <br> <br><h3> MemPtrUnlock</h3><dl><dl><a name="925757"> </a><h4>Purpose </h4><dl><a name="925758"> </a><p></p><dt>Unlock a chunk, given a pointer to the chunk.</dl><a name="925759"> </a><h4>Prototype </h4><dl><a name="925761"> </a><dt><code>Err MemPtrUnlock (MemPtr&nbsp;p)</code></dl></dl><dl><a name="925762"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925763"> </a><CODE><code>p</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a chunk.<br></TD></TR></TABLE></dl><dl><a name="925764"> </a><h4>Result </h4><dl><a name="925765"> </a><p></p><dt>0 if no error, or memErrInvalidParam if an error occurs.</dl></dl><dl><a name="925766"> </a><h4>Comments </h4><dl><a name="925768"> </a><p></p><dt>A chunk must <strong>not</strong> be unlocked more times than it was locked. </dl><a name="925769"> </a><h4>See Also </h4><dl><a name="925773"> </a><p></p><dt><code><a href="MemoryManager.html#925048"></code>MemHandleLock<code></a></code> </dl></dl></dl><a name="925775"> </a><br> <br> <br><h3> MemSet</h3><dl><dl><a name="925776"> </a><h4>Purpose </h4><dl><a name="925777"> </a><p></p><dt>Set a memory range in a dynamic heap to a specific value.</dl><a name="925778"> </a><h4>Prototype </h4><dl><a name="925780"> </a><dt><code>Err MemSet (void*&nbsp;dstP, Int32&nbsp;numBytes, UInt8&nbsp;value)</code></dl></dl><dl><a name="925781"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925782"> </a><CODE><code>dstP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the destination.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925783"> </a><CODE><code>numBytes</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to set.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925784"> </a><CODE><code>value</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Value to set.<br></TD></TR></TABLE></dl><dl><a name="925785"> </a><h4>Result </h4><dl><a name="925786"> </a><p></p><dt>Always returns 0.</dl></dl><dl><a name="925787"> </a><h4>Comments </h4><dl><a name="925791"> </a><p></p><dt>For operations where the destination is in a data heap, see <a href="DataAndResourceManager.html#927305">DmSet</a>, <a href="DataAndResourceManager.html#927456">DmWrite</a>, and related functions.</dl></dl></dl><a name="925796"> </a><br> <br> <br><h3> MemSetDebugMode</h3><dl><dl><a name="925797"> </a><h4>Purpose </h4><dl><a name="925799"> </a><p></p><dt>Set the debugging mode of the memory manager.</dl><a name="925800"> </a><h4>Prototype </h4><dl><a name="925802"> </a><dt><code>Err MemSetDebugMode (UInt16&nbsp;flags)</code></dl></dl><dl><a name="925803"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925804"> </a><CODE><code>flags</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Debug flags.<br></TD></TR></TABLE></dl><dl><a name="925805"> </a><h4>Comments </h4><dl><a name="925806"> </a><p></p><dt>Use the logical OR operator (<code>|</code>) to provide any combination of one, more, or none of the following flags:<a name="925807"> </a><p></p><dt><code>memDebugModeCheckOnChange<br>memDebugModeCheckOnAll<br>memDebugModeScrambleOnChange<br>memDebugModeScrambleOnAll<br>memDebugModeFillFree<br>memDebugModeAllHeaps<br>memDebugModeRecordMinDynHeapFree</code></dl></dl><dl><a name="925808"> </a><h4>Result </h4><dl><a name="925809"> </a><p></p><dt>Returns 0 if no error, or -1 if an error occurs.</dl></dl></dl><a name="925811"> </a><br> <br> <br><h3> MemStoreInfo</h3><dl><dl><a name="925812"> </a><h4>Purpose </h4><dl><a name="925813"> </a><p></p><dt>Return information on either the RAM store or the ROM store for a memory card.</dl><a name="925814"> </a><h4>Prototype </h4><dl><a name="925816"> </a><dt><code>Err MemStoreInfo (UInt16&nbsp;cardNo, UInt16&nbsp;storeNumber, UInt16*&nbsp;versionP, UInt16*&nbsp;flagsP, Char*&nbsp;nameP, UInt32*&nbsp;crDateP, UInt32*&nbsp;bckUpDateP, UInt32*&nbsp;heapListOffsetP, UInt32*&nbsp;initCodeOffset1P, UInt32*&nbsp;initCodeOffset2P, LocalID*&nbsp;databaseDirIDP)</code></dl></dl><dl><a name="925817"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925818"> </a><CODE>-&gt; <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Card number, either 0 or 1.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925819"> </a><CODE>-&gt; <code>storeNumber</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Store number; 0 for ROM, 1 for RAM.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925820"> </a><CODE>&lt;-&gt; <code>versionP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to version variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925821"> </a><CODE>&lt;-&gt; <code>flagsP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to flags variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925822"> </a><CODE>&lt;-&gt; <code>nameP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to character array (32 bytes), or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925823"> </a><CODE>&lt;-&gt; <code>crDateP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to creation date variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925824"> </a><CODE>&lt;-&gt; <code>bckUpDateP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to backup date variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925825"> </a><CODE>&lt;-&gt; <code>heapListOffsetP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to <code>heapListOffset</code> variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925826"> </a><CODE>&lt;-&gt; <code>initCodeOffset1P</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to <code>initCodeOffset1</code> variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925827"> </a><CODE>&lt;-&gt; <code>initCodeOffset2P</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to initCodeOffset2 variable, or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925828"> </a><CODE>&lt;-&gt; <code>databaseDirIDP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to database directory chunk ID variable, or 0.<br></TD></TR></TABLE></dl><dl><a name="925829"> </a><h4>Result </h4><dl><a name="925830"> </a><p></p><dt>Returns 0 if no error, or memErrCardNotPresent, memErrRAMOnlyCard, or memErrInvalidStoreHeader if an error occurs.</dl></dl><dl><a name="944398"> </a><h4>Comments </h4><dl><a name="946735"> </a><p></p><dt>Call this routine to retrieve any or all information on either the RAM store or the ROM store for a card. Pass 0 for variables that you don't wish returned.<a name="946882"> </a><p></p><dt><strong></strong></dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="KeyManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="NotifyMgr.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 37 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:28:38 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/MemoryManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:01 GMT -->
</html>