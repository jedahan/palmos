<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/Memory.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:12 GMT -->
<head><title>Memory</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="UserInterface.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="FilesAndDatabases.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS Programmer's Companion</B></center><hr><br><a name="924904"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924902"> </a>6 Memory</h1><dl><a name="924905"> </a><p></p><dt>This chapter helps you understand memory use on Palm OS<sup>&#174;</sup>. <ul type="SQUARE"><a name="924909"> </a><br><li><a href="Memory.html#924919">Introduction to Palm OS Memory Use</a> provides information about Palm OS hardware relevant to memory management. <br><a name="924913"> </a><br><li><a href="Memory.html#924946">Memory Architecture</a> discusses in detail how memory is structured on Palm OS. It also examines the structure of the basic building blocks of Palm OS memory: heaps, chunks, and records.<br><a name="924917"> </a><br><li><a href="Memory.html#925076">The Memory Manager</a> discusses how to use the Palm OS memory manager in your applications. The memory manager maintains the location and size of each memory chunk in nonvolatile storage, volatile storage, and ROM. It provides functions for allocating chunks, disposing of chunks, resizing chunks, locking and unlocking chunks, and compacting the heap when it becomes fragmented.<br></ul></dl><a name="924919"> </a><h2> Introduction to Palm OS Memory Use</h2><dl><a name="924921"> </a><p></p><dt>The Palm OS system software supports applications on low-cost, low-power, handheld devices. Given these constraints, Palm OS is efficient in its use of both memory and processing resources. This section presents two aspects of Palm OS devices that contribute to this efficiency: <a href="Memory.html#924929">Hardware Architecture</a> and <a href="Memory.html#924939">PC Connectivity</a>.</dl><a name="924929"> </a><h3> Hardware Architecture</h3><dl><a name="924930"> </a><p></p><dt>The first implementation of Palm OS provides nearly instantaneous response to user input while running on a 16 MHz Motorola<sup>&#174;</sup> 68000 type processor with a minimum of 128K of nonvolatile storage memory and 512 KB of ROM. Subsequent Palm OS devices provide additional RAM and ROM in varying amounts.<a name="924932"> </a><p></p><dt>The ROM and RAM for each Palm OS device resides on a memory module known as a <strong>card</strong>. Each memory card can contain ROM, RAM, or both. There is no RAM or ROM storage on the motherboard of the device. <a name="924934"> </a><p></p><dt>Though all previous and current Palm OS devices hold one card in a user-accessible hardware slot, it is unwise to assume that any Palm OS device has a memory module that can be removed physically. A "card" is simply a logical construct used by the operating system--Palm OS devices can have one card, multiple cards, or no cards. For example, the Simulator provided by the Palm OS SDK on Macintosh can simulate a device that has two cards. <a name="924935"> </a><p></p><dt>The ROM and RAM on each card is divided into one or more heaps of 64K (in the current implementation) or less. All the RAM-based heaps on a memory card are treated as the RAM store, and all the ROM-based heaps are treated as the ROM store. The heaps for a store do not have to be adjacent to each other in address space--they can be scattered throughout the memory space on the card--but they must all reside on the same card. <a name="924936"> </a><p></p><dt>The main suite of applications provided with each Palm OS device is built into ROM. This design permits the user to replace the operating system and the entire applications suite simply by installing a single replacement module<em>. </em>Additional or replacement applications and system extensions can be loaded into RAM, but doing so is not always practical in this RAM-constrained environment.</dl><a name="924939"> </a><h3> PC Connectivity</h3><dl><a name="924941"> </a><p></p><dt>PC connectivity is an integral component of the Palm OS device. The device comes with a cradle that connects to a desktop PC and with software for the PC that provides "one-button" backup and synchronization of all data on the device with the user's PC. <a name="924943"> </a><p></p><dt>Because all user data can be backed up on the PC, replacement of the nonvolatile storage area of the Palm OS device becomes a simple matter of installing the new module in place of the old one and resynchronizing with the PC. The format of the user's data in storage RAM can change with a new version of the ROM; the connectivity software on the PC is responsible for translating the data into the correct format when downloading it onto a device with a new ROM.</dl><a name="924946"> </a><h2> Memory Architecture</h2><a name="924947"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>This section describes the current (3.X) implementation of Palm OS memory architecture. This implementation may change as the Palm OS evolves. Do not rely on implementation-specific information described here; instead, always use the API provided to manipulate memory. <br><hr><br></blockquote><dl><a name="924949"> </a><p></p><dt>The Palm OS system software is designed around a 32-bit architecture. The system uses 32-bit addresses, and its basic data types are 8, 16, and 32 bits long. <a name="924950"> </a><p></p><dt>The 32-bit addresses available to software provide a total of 4 GB of address space for storing code and data. This address space affords a large growth potential for future revisions of both the hardware and software without affecting the execution model. Although a large memory space is available, Palm OS was designed to work efficiently with small amounts of RAM. For example, the first commercial Palm OS device has less than 1 MB of memory, or .025% of this address space. <a name="924952"> </a><p></p><dt>The Motorola 68328 processor's 32-bit registers and 32 internal address lines support a 32-bit execution model as well, although the external data bus is only 16 bits wide. This design reduces cost without impacting the software model. The processor's bus controller automatically breaks down 32-bit reads and writes into multiple 16-bit reads and writes externally.<a name="924953"> </a><p></p><dt>Each memory card in the Palm OS device has 256 MB of address space reserved for it. Memory card 0 starts at address $1000000, memory card 1 starts at address $2000000, and so on. <a name="924954"> </a><p></p><dt>The Palm OS divides the total available RAM store into two logical areas: <strong>dynamic</strong> RAM and <strong>storage</strong> RAM. Dynamic RAM is used as working space for temporary allocations, and is analogous to the RAM installed in a typical desktop system. The remainder of the available RAM on the card is designated as storage RAM and is analogous to disk storage on a typical desktop system. <a name="924956"> </a><p></p><dt>Because power is always applied to the memory system, both areas of RAM preserve their contents when the device is turned "off" (i.e., is in low-power sleep mode.) See <a href="SystemFeatures.html#925659">"Palm OS Power Modes"</a> in the chapter <a href="SystemFeatures.html#924905">"Palm System Features"</a> in this book. All of storage memory is preserved even when the device is reset explicitly. As part of the boot sequence, the system software reinitializes the dynamic area, and leaves the storage area intact. <a name="924963"> </a><p></p><dt>The entire dynamic area of RAM is used to implement a single heap that provides memory for dynamic allocations. From this <strong>dynamic heap</strong>, the system provides memory for dynamic data such as global variables, system dynamic allocations (TCP/IP, IrDA, and so on, as applicable), application stacks, temporary memory allocations, and application dynamic allocations (such as those performed when the application calls the <a href="MemoryManager.html#925071">MemHandleNew</a> function).<a name="924967"> </a><p></p><dt>The entire amount of RAM reserved for the dynamic heap is always dedicated to this use, regardless of whether it is actually used for allocations. The size of the dynamic area of RAM on a particular device varies according to the OS version running, the amount of physical RAM available, and the requirements of pre-installed software such as the TCP/IP stack or IrDA stack. <a href="Memory.html#929775">Table 6.1</a> provides more information about the dynamic heap space that currently available combinations of OS and hardware provide.<p><a name="925031"> </a> </p><p><div> <table border="3"><caption><B><a name="929775"> </a><h4>Table 6.1	 Dynamic Heap Space&nbsp;</h4></B></caption><tr><th><a name="929787"> </a><strong>RAM Usage</strong></th><th><a name="929789"> </a><strong>OS 3.5</strong><a name="930510"> </a><strong><img src="images/lt_equal.html"> </strong><strong>4 MB</strong><a name="930532"> </a><strong>TCP/IP &amp; IrDA<br></strong></th><th><a name="929795"> </a><strong>OS 3.5</strong><a name="930473"> </a><strong><img src="images/lt_equal.html"> </strong><strong>2 MB</strong><a name="929889"> </a><strong><br>TCP/IP &amp; IrDA</strong></th><th><a name="929797"> </a><strong>OS 3.0 &gt;</strong><strong> 3.3<br></strong><strong>&gt;</strong><strong> 1 MB<br>TCP/IP &amp; IrDA<br>(Palm III</strong>&#153;<strong>)</strong></th><th><a name="929799"> </a><strong>OS 2.0 <br>1 MB<br>TCP/IP only<br>(Professional)-</strong></th><th><a name="929801"> </a><strong>OS 2.0/1.0<br>512 KB<br>no TCP/IP or IrDA (Personal)</strong></th></tr><tr><td><a name="929803"> </a>Total dynamic area</td><td><a name="929805"> </a>256 KB</td><td><a name="929807"> </a>128 KB</td><td><a name="929809"> </a>96 KB</td><td><a name="929811"> </a>64 KB</td><td><a name="929813"> </a>32 KB</td></tr><tr><td><a name="929815"> </a>System Globals<br>(screen buffer, UI globals, database references, etc.)</td><td><a name="929817"> </a>40 KB<br>(OS)</td><td><a name="929819"> </a>40 KB<a name="929874"> </a>(OS)</td><td><a name="929821"> </a>~2.5 KB</td><td><a name="929823"> </a>~2.5 KB</td><td><a name="929825"> </a>~2.5 KB</td></tr><tr><td><a name="929827"> </a>TCP/IP stack</td><td><a name="929829"> </a>32 KB</td><td><a name="929831"> </a>32 KB</td><td><a name="929833"> </a>32 KB</td><td><a name="929835"> </a>32 KB</td><td><a name="929837"> </a>0 KB</td></tr><tr><td><a name="929839"> </a>System dynamic allocation<br>(IrDA, "Find" window, temporary allocations)</td><td><a name="929841"> </a>variable</td><td><a name="929843"> </a>variable</td><td><a name="929845"> </a>variable amount</td><td><a name="929847"> </a>~15 KB<br>(no IrDA in this OS)</td><td><a name="929849"> </a>~15 KB</td></tr><tr><td><a name="929851"> </a>Application stack<br>(call stack and local vars)</td><td><a name="929853"> </a>N/A (see note)</td><td><a name="929892"> </a>N/A (see note)</td><td><a name="929857"> </a>4 KB <br>(default)</td><td><a name="929859"> </a>2.5 KB</td><td><a name="929861"> </a>2.5 KB</td></tr><tr><td><a name="929863"> </a>Remaining dynamic space<br>(dynamic allocations, application global variables, and static variables)</td><td><a name="929865"> </a>184 KB</td><td><a name="929867"> </a>56 KB</td><td><a name="929869"> </a><strong><img src="images/lt_equal.html"></strong> 36 KB</td><td><a name="929871"> </a><strong><img src="images/lt_equal.html"></strong> 12 KB</td><td><a name="929873"> </a><strong><img src="images/lt_equal.html"> </strong>12 KB</td></tr></table><table><tr><td></table></div></p><a name="925032"> </a><p></p><dt>The remaining portion of RAM not dedicated to the dynamic heap is configured as one or more <strong>storage heaps</strong> used to hold nonvolatile user data such as appointments, to do lists, memos, address lists, and so on. An application accesses a storage heap by calling the database manager or resource manager, according to whether it needs to manipulate user data or resources. <a name="929890"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>Starting with Palm OS 3.5, the dynamic heap is sized based on the amount of memory available to the system. <hr><br></blockquote><a name="925033"> </a><p></p><dt>The size and number of storage heaps available on a particular device varies according to the OS version that is running; the amount of physical RAM that is available; and the storage requirements of end-user application software such as the Address List, Date Book, or third-party applications.<a name="925034"> </a><p></p><dt>Versions 1.0 and 2.0 of Palm OS subdivide storage RAM into multiple storage heaps of 64 KB each. Palm OS 3.X configures all storage RAM on a card as a single storage heap. Under all versions of Palm OS, system overhead limits the maximum usable data storage available in a single chunk to slightly less than 64 KB.<a name="925044"> </a><p></p><dt>In the Palm OS environment, all data are stored in memory manager chunks. A <strong>chunk</strong> is an area of contiguous memory between 1 byte and slightly less than 64 KB in size that has been allocated by the Palm OS memory manager. (Because system overhead requirements may vary, an exact figure for the maximum amount of usable data storage for all chunks cannot be specified.) Currently, all Palm OS implementations limit the maximum size of any chunk to slightly less than 64 KB; however, the API does not have this constraint, and it may be relaxed in the future. <a name="925046"> </a><p></p><dt>Each chunk resides in a heap. Some heaps are ROM-based and contain only nonmovable chunks; some are RAM-based and may contain movable or nonmovable chunks. A RAM-based heap may be a dynamic heap or a storage heap. The Palm OS memory manager allocates memory in the dynamic heap (for dynamic allocations, stacks, global variables, and so on). The Palm OS data manager allocates memory in one or more storage heaps (for nonvolatile user data). <a name="925047"> </a><p></p><dt>Every memory chunk used to hold storage data (as opposed to memory chunks that store dynamic data) is a <strong>record</strong> in a database implemented by the Palm OS data manager. In the Palm OS environment, a <strong>database</strong> is simply a list of memory chunks and associated database header information. Normally, the items in a database share some logical association; for example, a database may hold a collection of all address book entries, all datebook entries, and so on.<a name="925049"> </a><p></p><dt>A database is analogous to a file in a desktop system. Just as a traditional file system can create, delete, open, and close files, Palm OS applications can create, delete, open, and close databases as necessary. There is no restriction on where the records for a particular database reside as long as they are all on the same memory card. The records from one database can be interspersed with the records from one or more other databases in memory.<a name="925051"> </a><p></p><dt>Storing data by database fits nicely with the Palm OS memory manager design. Each record in a database is in fact a memory manager chunk. The data manager can use memory manager calls to allocate, delete, and resize database records. All heaps except for the dynamic heap are nonvolatile, so database records can be stored in any heap except the dynamic heap. Because records can be stored anywhere on the memory card, databases can be distributed over multiple discontiguous areas of physical RAM, but all records belonging to a particular database must reside on the same card. <a name="925052"> </a><p></p><dt>To understand how database records are manipulated, it helps to know something about the way the memory manager allocates and tracks memory chunks, as the next section describes.</dl><a name="925054"> </a><h3> Heap Overview</h3><a name="925055"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>This section describes the current (3.X) implementation of Palm OS memory architecture. This implementation may change as the Palm OS evolves. Do not rely on implementation-specific information described here; instead, always use the API provided to manipulate memory. <br><hr><br></blockquote><dl><a name="925057"> </a><p></p><dt>Recall that a <strong>heap</strong> is a contiguous area of memory used to contain and manage one or more smaller chunks of memory. When applications work with memory (allocate, resize, lock, etc.) they usually work with chunks of memory. An application can specify whether to allocate a new chunk of memory in the storage heap or the dynamic heap. The memory manager manages each heap independently and rearranges chunks as necessary to defragment heaps and merge free space. <a name="925058"> </a><p></p><dt>Heaps in the Palm OS environment are referenced through heap IDs. A <strong>heap ID</strong> is a unique 16-bit value that the memory manager uses to identify a heap within the Palm OS address space. Heap IDs start at 0 and increment sequentially by units of 1. Values are assigned beginning with the RAM heaps on card 0, continuing with the ROM heaps on card 0, and then continuing through RAM and ROM heaps on subsequent cards. The sequence of heap IDs is continuous; that is, no values in the sequence are skipped. <a name="925059"> </a><p></p><dt>The first heap (heap 0) on card 0 is the dynamic heap. This heap is reinitialized every time the Palm OS device is reset. When an application quits, the system frees any chunks allocated by that application in the dynamic heap. All other heaps are nonvolatile storage heaps that retain their contents through soft reset cycles. <a name="925061"> </a><p></p><dt>When a Palm OS device is presented with multiple dynamic heaps, the first heap (heap 0) on card 0 is the active dynamic heap. All other potential dynamic heaps are ignored. For example, it is possible that a future Palm OS device supporting multiple cards might be presented with two cards, each having its own dynamic heap; if so, only the dynamic heap residing on card 0 would be active--the system would not treat any heaps on other cards as dynamic heaps, nor would heap IDs be assigned to these heaps. Subsequent storage heaps would be assigned IDs in sequential order, as always beginning with RAM heaps, followed by ROM heaps. <a name="928995"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>In Palm OS 3.5, the dynamic heap is sized based on the amount of memory available to the system.<hr><br></blockquote></dl><a name="925062"> </a><h4> Overview of Memory Chunk Structure</h4><dl><a name="925063"> </a><p></p><dt>Memory chunks can be movable or nonmovable. Applications need to store data in movable chunks whenever feasible, thereby enabling the memory manager to move chunks as necessary to create contiguous free space in memory for allocation requests. <a name="925064"> </a><p></p><dt>When the memory manager allocates a nonmovable chunk it returns a pointer to that chunk. The pointer is simply that chunk's address in memory. Because the chunk cannot move, its pointer remains valid for the chunk's lifetime; thus, the pointer can be passed "as is" to the caller that requested the allocation. <a name="925065"> </a><p></p><dt>When the memory manager allocates a moveable chunk, it generates a pointer to that chunk, just as it did for the nonmovable chunk, but it does not return the pointer to the caller. Instead, it stores the pointer to the chunk, called the <strong>master chunk pointer</strong>, in a <strong>master pointer table</strong> that is used to track all of the moveable chunks in the heap, and returns a reference to the master chunk pointer. This reference to the master chunk pointer is known as a <strong>handle</strong>. It is this handle that the memory manager returns to the caller that requested the allocation of a moveable chunk. <a name="925066"> </a><p></p><dt>Using handles imposes a slight performance penalty over direct pointer access but permits the memory manager to move chunks around in the heap without invalidating any chunk references that an application might have stored away. As long as an application uses handles to reference data, only the master pointer to a chunk needs to be updated by the memory manager when it moves a chunk during defragmentation.<a name="925067"> </a><p></p><dt>An application typically locks a chunk handle for a short time while it has to read or manipulate the contents of the chunk. The process of locking a chunk tells the memory manager to mark that data chunk as immobile. When an application no longer needs the data chunk, it should unlock the handle immediately to keep heap fragmentation to a minimum.<a name="925068"> </a><p></p><dt>Note that any handle is good only until the system is reset. When the system resets, it reinitializes all dynamic memory areas and relaunches applications. Therefore, you must not store a handle in a database record or a resource. <a name="925071"> </a><p></p><dt>Each chunk on a memory card is actually located by means of a card-relative reference called a <strong>local ID</strong>. A local ID is a reference to a data chunk that the system computes from the base address of the card. The local ID of a nonmovable chunk is simply the offset of the chunk from the base address of the card. The local ID of a movable chunk is the offset of the master pointer to the chunk from the base address of the card, but with the low-order bit set. Since chunks are always aligned on word boundaries, only local IDs of movable chunks have the low-order bit set. Once the base address of the card is determined at runtime, a local ID can be converted quickly to a pointer or handle. <a name="925073"> </a><p></p><dt>For example, when an application needs the handle to a particular data record, it calls the data manager to retrieve the record by index from the appropriate database. The data manager fetches the local ID of the record out of the database header and uses it to compute the handle to the record. The handle to the record is never actually stored in the database itself. <a name="925074"> </a><p></p><dt>Although currently available Palm OS devices do not provide hardware support for multiple cards, the use of local IDs provides support in software for future devices that may allow the user to remove or insert memory cards. If the user moves a memory card to a slot having a different base address, the handle to a memory chunk on that card is likely to change, but the local ID associated with that chunk does not change. </dl><a name="925076"> </a><h2> The Memory Manager</h2><dl><a name="925077"> </a><p></p><dt>The Palm OS memory manager is responsible for maintaining the location and size of every memory chunk in nonvolatile storage, volatile storage, and ROM. It provides an API for allocating new chunks, disposing of chunks, resizing chunks, locking and unlocking chunks, and compacting heaps when they become fragmented. Because of the limited RAM and processor resources of the Palm OS device, the memory manager is efficient in its use of processing power and memory. <a name="925078"> </a><p></p><dt>This section provides background information on the organization of memory in Palm OS and provides an overview of the memory manager API, discussing these topics: <ul type="SQUARE"><a name="925082"> </a><br><li><a href="Memory.html#925088">Memory Manager Structures</a><br><a name="925086"> </a><br><li><a href="Memory.html#925142">Using the Memory Manager</a><br></ul></dl><a name="925088"> </a><h3> Memory Manager Structures</h3><dl><a name="925089"> </a><p></p><dt>This section discusses the different structures the memory manager uses: <ul type="SQUARE"><a name="925093"> </a><br><li><a href="Memory.html#925103">Heap Structures</a><br><a name="925097"> </a><br><li><a href="Memory.html#925120">Chunk Structures</a><br><a name="925101"> </a><br><li><a href="Memory.html#925133">Local ID Structures</a><br></ul></dl><a name="925103"> </a><h4> Heap Structures</h4><a name="925104"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Expect the heap structure to change in the future. Use the API to work with heaps.<br><hr><br></blockquote><dl><a name="925106"> </a><p></p><dt>A heap consists of the heap header, master pointer table, and the heap chunks.<ul type="SQUARE"><a name="925108"> </a><br><li><strong>Heap header</strong>. The heap header is located at the beginning of the heap. It holds the size of the heap and contains flags for the heap that provide certain information to the memory manager; for example, whether the heap is ROM-based.<br><a name="925110"> </a><br><li><strong>Master pointer table</strong>. Following the heap header is a master pointer table. It is used to store 32-bit pointers to movable chunks in the heap. <br><p></p><ul type="CIRCLE"><a name="925111"> </a><li>When the memory manager moves a chunk to compact the heap, the pointer for that chunk in the master pointer table is updated to the chunk's new location. The handles an application uses to track movable chunks reference the address of the master pointer to the chunk, not the chunk itself. In this way, handles remain valid even after a chunk is moved. The OS compacts the heap automatically when available contiguous space is not sufficient to fulfill an allocation request.<a name="925112"> </a><li>If the master pointer table becomes full, another is allocated and its offset is stored in the <code>nextMstrPtrTable</code> field of the previous master pointer table. Any number of master pointer tables can be linked in this way. Because additional master pointer chunks are nonmovable, they are allocated at the end of the heap, according to the guidelines described in the "Heap chunks" section following immediately. </ul><a name="925113"> </a><br><li><strong>Heap chunks</strong>. Following the master pointer table are the actual chunks in the heap. <br><p></p><ul type="CIRCLE"><a name="925115"> </a><li>Movable chunks are generally allocated at the beginning of the heap, and nonmovable chunks at the end of the heap. <a name="925116"> </a><li>Nonmovable chunks do not need an entry in the master pointer table since they are never relocated by the memory manager. <a name="925117"> </a><li>Applications can easily walk the heap by hopping from chunk to chunk because each chunk header contains the size of the chunk. All free and nonmovable chunks can be found in this manner by checking the flags in each chunk header.<dl><a name="925118"> </a><p></p><dt>Because heaps can be ROM-based, there is no information in the header that must be changed when using a heap. Also, ROM-based heaps contain only nonmovable chunks and have a master pointer table with 0 entries. </dl></ul></ul></dl><a name="925120"> </a><h4> Chunk Structures</h4><a name="925121"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Expect the chunk structure to change in the future. Use the API to work with chunks.<br><hr><br></blockquote><dl><a name="925122"> </a><p></p><dt>Each chunk begins with an 8-byte header followed by that chunk's data. The chunk header consists of a Flags:size adjustment byte, 3 bytes of size information, a lock:owner byte, and 3 bytes of <code>hOffset</code> information. <ul type="SQUARE"><a name="925123"> </a><br><li><strong>Flags:</strong><code>sizeAdj</code><strong> byte.</strong>This byte contains flags in the high nibble and a size adjustment in the low nibble. <br><p></p><ul type="CIRCLE"><a name="925124"> </a><li>The flags nibble has 1 bit currently defined, which is set for free chunks. <a name="925125"> </a><li>The size adjustment nibble can be used to calculate the requested size of the chunk, given the actual size. The requested size is computed by taking the size as stored in the chunk header and subtracting the size of the header and the size adjustment field. The actual size of a chunk is always a multiple of two so that chunks always start on a word boundary. </ul><a name="925126"> </a><br><li><strong>size</strong> <strong>field (3 bytes)</strong>. This three-byte value describes the size of the chunk, which is <strong>larger</strong> than the size requested by the application and includes the size of the chunk header itself. The maximum data size for a chunk is slightly less than 64 KB.<br><a name="925128"> </a><br><li><strong>Lock:owner byte</strong>. Following the size information is a byte that holds the lock count in the high nibble and the owner ID in the low nibble. <br><p></p><ul type="CIRCLE"><a name="925129"> </a><li>The lock count is incremented every time a chunk is locked and decremented every time a chunk is unlocked. A movable chunk can be locked a maximum of 14 times before being unlocked. Nonmovable chunks always have 15 in the lock field.<a name="925130"> </a><li>The owner ID determines the owner of a memory chunk and is set by the memory manager when allocating a new chunk. Owner ID information is useful for debugging and for garbage collection when an application terminates abnormally. </ul><a name="925131"> </a><br><li><strong>hOffset field (3 bytes)</strong>. The last three bytes in the chunk header is the distance from the master pointer for the chunk to the chunk's header, divided by two. Note that this offset could be a negative value if the master pointer table is at a higher address than the chunk itself. For nonmovable chunks that do not need an entry in the master pointer table, this field is 0.<br></ul></dl><a name="925133"> </a><h4> Local ID Structures</h4><a name="925134"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Expect the local ID structure to change in the future. Use the API to work with chunks.<br><hr><br></blockquote><dl><a name="925135"> </a><p></p><dt>Chunks that contain database records or other database information are tracked by the data manager through local IDs. A local ID is card relative and is always valid no matter what memory slot the card resides in. A local ID can be easily converted to a pointer or the handle to a chunk once the base address of the card is known. <a name="925136"> </a><p></p><dt>The upper 31 bits of a local ID contain the offset of the chunk or master pointer to the chunk from the beginning of the card. The low-order bit is set for local IDs of handles and clear for local IDs of pointers.<a name="925140"> </a><p></p><dt>The <a href="MemoryManager.html#925428">MemLocalIDToGlobal</a> function converts a local ID and card number (either 0 or 1) to a pointer or handle. It looks at the card number and adds the appropriate card base address to convert the local ID to a pointer or handle for that card.</dl><a name="925142"> </a><h3> Using the Memory Manager</h3><dl><a name="925143"> </a><p></p><dt>Use the memory manager API to allocate memory in the dynamic heap (for dynamic allocations, stacks, global variables, and so on) and use the data manager API to allocate memory in one or more storage heaps (for user data). The data manager calls the memory manager as appropriate to perform low-level allocations. (See <a href="FilesAndDatabases.html#924919">The Data Manager</a> for more information.)</dl><a name="925147"> </a><h4> Overview of the Memory Manager API</h4><dl><a name="925152"> </a><p></p><dt>To allocate a movable chunk, call <a href="MemoryManager.html#925071">MemHandleNew</a> and pass the desired chunk size. Before you can read or write data to this chunk, you must call <a href="MemoryManager.html#925048">MemHandleLock</a> to lock it and get a pointer to it. Every time you lock a chunk, its lock count is incremented. You can lock a chunk a maximum of 14 times before an error is returned. (Recall that unmovable chunks hold the value 15 in the lock field.) <a href="MemoryManager.html#925203">MemHandleUnlock</a> reverses the effect of <a href="MemoryManager.html#925048">MemHandleLock</a>--it decrements the value of the lock field by 1. When the lock count is reduced to 0, the chunk is free to be moved by the memory manager.<a name="925165"> </a><p></p><dt>When an application allocates memory in the dynamic heap, the memory manager uses an owner ID to associate that chunk with the application. The system further distinguishes chunks belonging to the currently active allocation by setting a special bit in the owner ID information. When the application quits, all chunks in the dynamic heap having this bit set are freed automatically. <a name="925167"> </a><p></p><dt>If the system needs to allocate a chunk that is not disposed of when an application quits, it changes the chunk's owner ID to 0 by calling the system functions <a href="MemoryManager.html#955510">MemHandleSetOwner</a> or <a href="MemoryManager.html#925698">MemPtrSetOwner</a>. These functions are not generally used by applications, except in special circumstances. For example, when the current application is passing a parameter block to a new application that it is launching, the owner of the block must be set to the system; otherwise, when the current application exits, the system deletes the block when it frees all memory allocated by the current application.<a name="925174"> </a><p></p><dt>To determine the size of a movable chunk, pass its handle to <a href="MemoryManager.html#925160">MemHandleSize</a>. To resize it, call <a href="MemoryManager.html#925103">MemHandleResize</a>. You generally cannot increase the size of a chunk if it's locked unless there happens to be free space in the heap immediately following the chunk. If the chunk is unlocked, the memory manager is allowed to move it to another area of the heap to increase its size.When you no longer need the chunk, call <a href="MemoryManager.html#925010">MemHandleFree</a>, which releases the chunk even if it is locked. <a name="925187"> </a><p></p><dt>If you have a pointer to a locked, movable chunk, you can recover the handle by calling <a href="MemoryManager.html#925661">MemPtrRecoverHandle</a>. In fact, all of the <code>MemPtr</code><em>Xxx</em> calls, including <a href="MemoryManager.html#925722">MemPtrSize</a>, also work on pointers to locked, movable chunks.<a name="925199"> </a><p></p><dt>To allocate a nonmovable chunk, call <a href="MemoryManager.html#925646">MemPtrNew</a> and pass the desired size of the chunk. This call returns a pointer to the chunk, which can be used directly to read or write to it. <a name="929003"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>You cannot allocate a zero-size chunk.<hr><br></blockquote><a name="925200"> </a><p></p><dt>To determine the size of a nonmovable chunk, call <code>MemPtrSize. </code>To resize it, call <a href="MemoryManager.html#925675">MemPtrResize</a>. You generally can't increase the size of a nonmovable chunk unless there is free space in the heap immediately following the chunk. When you no longer need the chunk, call <a href="MemoryManager.html#925616">MemPtrFree</a>, which releases the chunk even if it's locked. <a name="925216"> </a><p></p><dt>Use the memory manager utility routines <a href="MemoryManager.html#925502">MemMove</a> and <a href="MemoryManager.html#925775">MemSet</a> to move memory from one place to another or to fill memory with a specific value.<a name="925217"> </a><p></p><dt>In most situations, the proper way to free memory is by calling one of the <code><a href="MemoryManager.html#925616"></code>MemPtrFree<code></a></code> or <a href="MemoryManager.html#925010">MemHandleFree</a> functions.<a name="925224"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>For important cautions and practical advice regarding the proper use of memory on Palm OS devices, be sure to read <a href="Design.html#925149">"Writing Robust Code"</a> in the chapter <a href="Design.html#924905">"Good Design Practices"</a> in this book.<hr><br></blockquote></dl><a name="925231"> </a><h4> Storage Heap Sizes and Memory Management Schemes</h4><dl><a name="925233"> </a><p></p><dt>In Palm OS version 1.0, individual storage heaps were limited to a maximum size of 64 KB each and the memory manager moved objects automatically among multiple storage heaps to prevent any of them from becoming too full. This strategy tended to decrease the availability of contiguous space for large objects. The version 2.0 memory manager abandoned this approach, increasing the availability of contiguous heap space; however, it still limited the maximum size of individual heaps to 64 KB each. Palm OS version 3.X removes the 64 KB maximum size restriction on individual heaps and creates just two heaps: one 96K dynamic heap and one storage heap that is the size of all remaining RAM on the card. <a name="927235"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>Starting with PalmOS 3.5, the dynamic heap is sized based on the amount of memory available to the system. The size which will be used is as follows:</p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="927259"> </a><strong>Device RAM size </strong></th><th><a name="927261"> </a><strong>Heap size </strong></th></tr><tr><td><a name="927263"> </a>&lt; 2 mb of ram </td><td><a name="927265"> </a>64 k</td></tr><tr><td><a name="927267"> </a>&gt;= 2 mb </td><td><a name="927269"> </a>128 k</td></tr><tr><td><a name="927271"> </a>&gt;= 4 mb </td><td><a name="927273"> </a>256 k</td></tr></table><table><tr><td></table></div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<hr><br></blockquote></dl><a name="927190"> </a><h3> Optimizing Memory Manager Performance</h3><dl><a name="925235"> </a><p></p><dt>Because Palm OS applications must perform well in a RAM-constrained environment, proper code segmentation is critical to achieving optimum performance. <a name="925236"> </a><p></p><dt>If your application segments are too large, your application may not perform well (or to run at all) when large contiguous blocks of memory are not available. Conversely, if your application segments are too small, performance may be hindered by the overhead required to find and load resources too frequently. <a name="925237"> </a><p></p><dt>Unfortunately, it impossible to specify a single size for memory chunks that will perform optimally for all applications.You will need to experiment with segmenting your code in different ways while measuring your application's performance in order to discover the size and arrangement of resource chunks that will optimize your particular application's responsiveness and overall performance. The Metrowerks CodeWarrior Debugger, Palm OS Debugger, and the Simulator provide tools for examining the internal structure of heaps, viewing the amount of free space available, manipulating blocks, and so on. </dl><a name="925238"> </a><h2> Summary of Memory Management</h2><p><a name="925440"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925241"> </a><strong>Memory Manager Functions</strong></th><th><a name="925243"> </a><strong></strong></th></tr><tr><td colspan=2 rowspan=1><a name="925245"> </a><strong>Allocating and Freeing Memory</strong></td></tr><tr><td><a name="925252"> </a><a href="MemoryManager.html#925071">MemHandleNew</a><br><a href="MemoryManager.html#925048">MemHandleLock</a><br><a href="MemoryManager.html#925449">MemLocalIDToLockedPtr</a><br><a href="MemoryManager.html#925010">MemHandleFree</a></td><td><a name="925266"> </a><a href="MemoryManager.html#925646">MemPtrNew</a><br><a href="MemoryManager.html#925203">MemHandleUnlock</a><br><a href="MemoryManager.html#925756">MemPtrUnlock</a><br><a href="MemoryManager.html#925616">MemPtrFree</a></td></tr><tr><td><a name="925277"> </a><strong>Resizing Chunks</strong></td><td><a name="925279"> </a></td></tr><tr><td><a name="925284"> </a><a href="MemoryManager.html#925103">MemHandleResize</a><br><a href="MemoryManager.html#925675">MemPtrResize</a><br><a href="MemoryManager.html#925306">MemHeapFreeBytes</a></td><td><a name="925295"> </a><a href="MemoryManager.html#925160">MemHandleSize</a><br><a href="MemoryManager.html#925722">MemPtrSize</a><br><a href="MemoryManager.html#925394">MemHeapSize</a></td></tr><tr><td><a name="925303"> </a><strong>Working With Memory</strong></td><td><a name="925305"> </a></td></tr><tr><td><a name="925310"> </a><a href="MemoryManager.html#925502">MemMove</a><br><a href="MemoryManager.html#924936">MemCmp</a></td><td><a name="925318"> </a><a href="MemoryManager.html#925775">MemSet</a><br><a href="MemoryManager.html#925245">MemHeapCompact</a></td></tr><tr><td><a name="925323"> </a><strong>Converting Pointers</strong></td><td><a name="925325"> </a></td></tr><tr><td><a name="925330"> </a><strong><a href="MemoryManager.html#925661">MemPtrRecoverHandle</a><br><a href="MemoryManager.html#925414">MemLocalIDKind</a><br><a href="MemoryManager.html#925736">MemPtrToLocalID</a></strong></td><td><a name="925341"> </a><a href="MemoryManager.html#925180">MemHandleToLocalID</a><br><a href="MemoryManager.html#925428">MemLocalIDToGlobal</a><br><a href="MemoryManager.html#925480">MemLocalIDToPtr</a></td></tr><tr><td><a name="925349"> </a><strong>Chunk Information</strong></td><td><a name="925351"> </a></td></tr><tr><td><a name="925356"> </a><a href="MemoryManager.html#924971">MemHandleCardNo</a><br><a href="MemoryManager.html#925029">MemHandleHeapID</a><br><a href="MemoryManager.html#925580">MemPtrCardNo</a><br><a href="MemoryManager.html#925698">MemPtrSetOwner</a></td><td><a name="925370"> </a><a href="MemoryManager.html#924989">MemHandleDataStorage</a><br><a href="MemoryManager.html#955510">MemHandleSetOwner</a><br><a href="MemoryManager.html#925596">MemPtrDataStorage</a></td></tr><tr><td><a name="925378"> </a><strong>Heap Information</strong></td><td><a name="925380"> </a></td></tr><tr><td><a name="925385"> </a><a href="MemoryManager.html#925631">MemPtrHeapID</a><br><a href="MemoryManager.html#925260">MemHeapDynamic</a><br><a href="MemoryManager.html#925283">MemHeapFlags</a></td><td><a name="925396"> </a><a href="MemoryManager.html#925346">MemHeapID</a><br><a href="MemoryManager.html#925225">MemHeapCheck</a><br></td></tr><tr><td><a name="925401"> </a><strong>Card Information</strong></td><td><a name="925403"> </a></td></tr><tr><td><a name="925408"> </a><a href="MemoryManager.html#924915">MemCardInfo</a> <br><a href="MemoryManager.html#925537">MemNumHeaps</a><br><a href="MemoryManager.html#925811">MemStoreInfo</a></td><td><a name="925419"> </a><a href="MemoryManager.html#925525">MemNumCards</a><br><a href="MemoryManager.html#925563">MemNumRAMHeaps</a><br></td></tr><tr><td><a name="925424"> </a><strong>Debugging</strong></td><td><a name="925426"> </a></td></tr><tr><td><a name="925431"> </a><a href="MemoryManager.html#924956">MemDebugMode</a> <br><a href="MemoryManager.html#925796">MemSetDebugMode</a></td><td><a name="925439"> </a><a href="MemoryManager.html#925370">MemHeapScramble</a></td></tr></table><table><tr><td></table></div></p><p><a name="930066"> </a> <strong></strong></p><dl><a name="925457"> </a><p></p><dt><strong></strong></dl><hr><br><center><B>Palm OS Programmer's Companion</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="UserInterface.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="FilesAndDatabases.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 75 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:40 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/Memory.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:12 GMT -->
</html>