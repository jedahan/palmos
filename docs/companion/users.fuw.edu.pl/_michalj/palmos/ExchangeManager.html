<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/ExchangeManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
<head><title>Exchange Manager</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="ConnectionMgr.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="IRLib.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924906"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>51 Exchange Manager</h1><dl><a name="924907"> </a><p></p><dt>This chapter provides reference material for the exchange manager API:<ul type="SQUARE"><a name="924911"> </a><br><li><a href="ExchangeManager.html#924926">Exchange Manager Data Structures</a><br><a name="924915"> </a><br><li><a href="ExchangeManager.html#941092">Exchange Manager Functions</a><br><a name="924919"> </a><br><li><a href="ExchangeManager.html#925378">Application-Defined Functions</a><br></ul><a name="924921"> </a><p></p><dt>The header file <code>ExgMgr.h</code> declares the exchange manager API. For more information on the exchange manager, see the chapter <a href="Beaming.html#924904">"Beaming (Infrared Communication)"</a> in the <em>Palm OS Programmer's Companion</em>. </dl><a name="924926"> </a><h2> Exchange Manager Data Structures</h2><a name="934509"> </a><h3> ExgAskResultType</h3><dl><a name="934514"> </a><p></p><dt>The <code>ExgAskResultType</code> enum defines possible values for the <code>result</code> field of the <code><a href="AppLaunchCodes.html#925235"></code>sysAppLaunchCmdExgAskUser<code></a></code> launch code parameter block. <dl><a name="934515"> </a><br><code>typedef enum { </code><br></dl><dl><a name="934616"> </a><code>&nbsp&nbsp&nbsp exgAskDialog,</code><br><a name="934649"> </a><code>&nbsp&nbsp&nbsp exgAskOk,</code><br><a name="934650"> </a><code>&nbsp&nbsp&nbsp exgAskCancel } </code><br><a name="934651"> </a><code>ExgAskResultType;</code><br></dl></dl><a name="934685"> </a><h4> Value Descriptions</h4><p><a name="934707"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="934688"> </a><code>exgAskDialog </code></td><td><a name="934690"> </a>The exchange manager should display the exchange dialog to prompt the user to confirm the receipt of data. See <code><a href="ExchangeManager.html#937271"></code>ExgDoDialog<code></a></code>. </td></tr><tr><td><a name="934692"> </a><code>exgAskOk </code></td><td><a name="934694"> </a>Accept the data.</td></tr><tr><td><a name="934696"> </a><code>exgAskCancel </code></td><td><a name="934698"> </a>Reject the data.</td></tr></table><table><tr><td></table></div></p><a name="924929"> </a><h3> ExgGoToType</h3><dl><a name="924930"> </a><p></p><dt>The <code>ExgGoToType</code> structure defines information that is passed to the <code><a href="AppLaunchCodes.html#925328"></code>sysAppLaunchCmdGoto<code></a></code> launch command, after an item is received. The <code>ExgGoToPtr</code> type points to a <code>ExgGoToType</code> structure.<dl><a name="924934"> </a><br><code>typedef struct {</code><br></dl><dl><a name="924935"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;dbCardNo;</code><br><a name="924936"> </a><code>&nbsp&nbsp&nbsp LocalID&nbsp;dbID;</code><br><a name="924937"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;recordNum;</code><br><a name="924938"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;uniqueID;</code><br><a name="924939"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;matchCustom;</code><br><a name="924940"> </a><code>} ExgGoToType;	 </code><br><a name="924941"> </a><code></code><br><a name="924942"> </a><code>typedef ExgGoToType * ExgGoToPtr;</code><br></dl></dl><a name="924943"> </a><h4> Field Descriptions</h4><p><a name="924965"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="924946"> </a><code>dbCardNo</code></td><td><a name="924948"> </a>Card number of the database.</td></tr><tr><td><a name="924950"> </a><code>dbID</code></td><td><a name="924952"> </a>LocalID of the database.</td></tr><tr><td><a name="924954"> </a><code>recordNum</code></td><td><a name="924956"> </a>Index of the record that contains a match.</td></tr><tr><td><a name="924958"> </a><code>uniqueID</code></td><td><a name="924960"> </a>Position in the record of the match.</td></tr><tr><td><a name="924962"> </a><code>matchCustom </code></td><td><a name="924964"> </a>Application-specific information.</td></tr></table><table><tr><td></table></div></p><a name="924968"> </a><h3> ExgSocketType</h3><dl><a name="924969"> </a><p></p><dt>The <code>ExgSocketType</code> structure defines an exchange manager socket. The <code>ExgSocketPtr</code> type points to a <code>ExgSocketType</code> structure.<dl><a name="924970"> </a><br><code>typedef struct ExgSocketType {</code><br></dl><dl><a name="924971"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;libraryRef;</code><br><a name="924972"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;socketRef;</code><br><a name="924973"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;target;</code><br><a name="924974"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;count;</code><br><a name="924975"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;length;</code><br><a name="924976"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;time;</code><br><a name="924977"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;appData;</code><br><a name="924978"> </a><code>&nbsp&nbsp&nbsp UInt32&nbsp;goToCreator;</code><br><a name="924979"> </a><code>&nbsp&nbsp&nbsp ExgGoToType&nbsp;goToParams;</code><br><a name="924980"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;localMode:1;</code><br><a name="924981"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;packetMode:1;</code><br><a name="940917"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;noGoTo:1;</code><br><a name="940918"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;noStatus:1;</code><br><a name="924982"> </a><code>&nbsp&nbsp&nbsp UInt16&nbsp;reserved:12;</code><br><a name="924983"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;*description;</code><br><a name="924984"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;*type;</code><br><a name="924985"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;*name;</code><br><a name="924986"> </a><code>} ExgSocketType;</code><br><a name="924987"> </a><code></code><br><a name="924988"> </a><code>typedef ExgSocketType* ExgSocketPtr;</code><br><dl><a name="943774"> </a><p></p><dt>Note that when data is received, some of the fields in this structure may not be filled in. The existing IR library does not send values for the <code>count</code>, <code>time</code>, <code>appData</code>, or <code>type</code> fields; however, it may do so in the future. When you are sending data, it is recommended that you provide values for all of these fields, but you should not rely on receiving values for them. </dl></dl></dl><a name="924989"> </a><h4> Field Descriptions</h4><p><a name="941090"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="941014"> </a><code>libraryRef</code></td><td><a name="941016"> </a>Identifies the exchange library in use.</td></tr><tr><td><a name="941018"> </a><code>socketRef</code></td><td><a name="941020"> </a>Identifies the connection (used by exchange library).</td></tr><tr><td><a name="941022"> </a><code>target</code></td><td><a name="941024"> </a>Creator ID of the application the data is being sent to.</td></tr><tr><td><a name="941026"> </a><code>count</code></td><td><a name="941028"> </a>Number of objects in this connection, usually 1 (optional). </td></tr><tr><td><a name="941030"> </a><code>length </code></td><td><a name="941032"> </a>Total byte count for all objects being sent (optional).</td></tr><tr><td><a name="941034"> </a><code>time</code></td><td><a name="941036"> </a>Last modified time of object (optional).</td></tr><tr><td><a name="941038"> </a><code>appData</code></td><td><a name="941040"> </a>Application-specific information (optional). </td></tr><tr><td><a name="941042"> </a><code>goToCreator</code></td><td><a name="941044"> </a>Creator ID of the application to launch via the <code><a href="AppLaunchCodes.html#925328"></code>sysAppLaunchCmdGoto<code></a></code> launch code after the item is received if <code>noGoTo</code> is 0.</td></tr><tr><td><a name="941049"> </a><code>goToParams</code></td><td><a name="941051"> </a>If <code>goToCreator</code> is specified, then this contains information about where to go. See <code><a href="ExchangeManager.html#924929"></code>ExgGoToType<code></a></code>.</td></tr><tr><td><a name="941056"> </a><code>localMode</code></td><td><a name="941058"> </a>Set to 1 to exchange with local machine only. Set to 0 to enable an exchange with a remote machine. Default is 0.</td></tr><tr><td><a name="941060"> </a><code>packetMode</code></td><td><a name="941062"> </a>Set to 1 to use connectionless packet mode (Ultra). Default is 0.</td></tr><tr><td><a name="941064"> </a><code>noGoTo</code> </td><td><a name="941066"> </a>Set to 1 to disable launching the application with <code><a href="AppLaunchCodes.html#925328"></code>sysAppLaunchCmdGoto<code></a></code>. This flag is only valid if <code>localMode</code> is 1. Default is 0. </td></tr><tr><td><a name="941071"> </a><code>noStatus</code> </td><td><a name="941073"> </a>This field is not currently used. </td></tr><tr><td><a name="941075"> </a><code>reserved</code></td><td><a name="941077"> </a>Reserved system flags.</td></tr><tr><td><a name="941079"> </a><code>description</code></td><td><a name="941081"> </a>Pointer to text description of object (for user).</td></tr><tr><td><a name="941083"> </a><code>type</code></td><td><a name="941085"> </a>Pointer to Mime type of object (optional).</td></tr><tr><td><a name="941087"> </a><code>name</code></td><td><a name="941089"> </a>Pointer to name of object, generally a file name including extension. If you don't provide a name, the exchange manager sets this field to <code>Palm.exg</code>. </td></tr><tr><td><a name="945140"> </a></td><td><a name="945142"> </a>Because the current IR library does not send the <code>type</code> field, the file extension is used to identify the data type. The built-in applications recognize the following extensions:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="945338"> </a><CODE>txt</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Memo<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="945419"> </a><CODE>vcf</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>AddressBook<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="945454"> </a><CODE>vcs</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Datebook and ToDo <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="945483"> </a><CODE>prc, pdb, pqa</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Launcher<br></TD></TR></TABLE></td></tr></table><table><tr><td></table></div></p><a name="941100"> </a><h4> Compatibility</h4><dl><a name="941103"> </a><p></p><dt>The <code>noGoTo</code> and <code>noStatus</code> flags are only defined if <a href="CompatibilityApdx.html#486514">3.5 New Feature Set</a> is present.</dl><a name="941092"> </a><h2> Exchange Manager Functions</h2><a name="941095"> </a><br> <br> <br><h3> ExgAccept</h3><dl><dl><a name="925063"> </a><h4>Purpose </h4><dl><a name="925064"> </a><p></p><dt>Accepts a connection from a remote device.</dl><a name="925065"> </a><h4>Prototype </h4><dl><a name="925066"> </a><dt><code>Err ExgAccept (ExgSocketPtr&nbsp;socketP)</code></dl></dl><dl><a name="925067"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925068"> </a><CODE>-&gt; <code>socketP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the socket structure.<br></TD></TR></TABLE></dl><dl><a name="925069"> </a><h4>Result </h4><dl><a name="925083"> </a><p></p><dt>Returns the following result codes:<p><a name="926207"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925072"> </a><code>errNone</code></td><td><a name="925074"> </a>No error</td></tr><tr><td><a name="925076"> </a><code>exgErrBadLibrary</code></td><td><a name="925078"> </a>Couldn't find default exchange library</td></tr><tr><td><a name="925080"> </a><code>exgErrStackInit</code></td><td><a name="925082"> </a>Couldn't initialize the IR stack (not enough battery power or unsupported hardware)</td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925084"> </a><h4>Comments </h4><dl><a name="925085"> </a><p></p><dt>An application calls this function when it has been called with the special application launch code <code><a href="AppLaunchCodes.html#925259"></code>sysAppLaunchCmdExgReceiveData<code></a></code>. The application is passed <code>socketP</code> as a parameter. It should pass this parameter to <code>ExgAccept</code> to accept the connection and then call <code>ExgReceive</code> one or more times to receive the data.</dl><a name="925089"> </a><h4>Compatibility </h4><dl><a name="925093"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl><a name="925094"> </a><h4>See Also </h4><dl><a name="925098"> </a><p></p><dt><code><a href="ExchangeManager.html#925290"></code>ExgReceive<code></a></code></dl></dl></dl><a name="925101"> </a><br> <br> <br><h3> ExgDBRead</h3><dl><dl><a name="925102"> </a><h4>Purpose </h4><dl><a name="925103"> </a><p></p><dt>Reads a Palm OS<sup>&#174;</sup> database in its internal format and writes it to storage RAM. For example, this function might read in a database transmitted by a beaming operation using the exchange manager.</dl><a name="925104"> </a><h4>Prototype </h4><dl><a name="925105"> </a><dt><code>Err ExgDBRead (ExgDBReadProcPtr&nbsp;readProcP, ExgDBDeleteProcPtr&nbsp;deleteProcP, void*&nbsp;userDataP, LocalID*&nbsp;dbIDP, UInt16&nbsp;cardNo, Boolean*&nbsp;needResetP, Boolean&nbsp;keepDates)</code></dl></dl><dl><a name="925106"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925107"> </a><CODE>-&gt; <code>readProcP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to a function that you supply that reads in the database and passes it to <code>ExgDBRead</code>. See <code><a href="ExchangeManager.html#925408"></code>ReadProc<code></a></code> for details.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925112"> </a><CODE>-&gt; <code>deleteProcP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to a function that is called if a database with an identical name already exists on the device, so you can erase it before <code>ExgDBRead</code> stores the received database. See <code><a href="ExchangeManager.html#925388"></code>DeleteProc<code></a></code> for details.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925116"> </a><CODE>-&gt; <code>userDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to any data you want to pass to either the <code>readProcP</code> or <code>deleteProcP</code> functions.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925117"> </a><CODE>&lt;- <code>dbIDP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The ID of the database that <code>ExgDBRead</code> created on the local device.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925118"> </a><CODE>&lt;- <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The number of the card on which the database was stored by <code>ExgDBRead</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925119"> </a><CODE>&lt;- <code>needResetP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Set to <code>true</code> by <code>ExgDBRead</code> if the <code>dmHdrAttrResetAfterInstall</code> attribute bit is set in the received database.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925120"> </a><CODE>-&gt; <code>keepDates</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Specify <code>true</code> to retain the creation, modification, and last backup dates as set in the received database header. Specify <code>false</code> to reset these dates to the current date.<br></TD></TR></TABLE></dl><dl><a name="925121"> </a><h4>Result </h4><dl><a name="925122"> </a><p></p><dt>Returns <code>errNone</code> if successful; otherwise, returns one of the data manager error codes (<code>dmErr...</code>) or a callback-specific error code (if the <code>readProcP</code> function returns an error, it is also returned by <code>ExgDBRead</code>).</dl></dl><dl><a name="925124"> </a><h4>Comments </h4><dl><a name="925125"> </a><p></p><dt>The read callback function passed in <code>readProcP</code> is called multiple times by <code>ExgDBRead</code>. Each time, <code>ExgDBRead</code> passes in <code>sizeP</code> the number of bytes it expects to receive in the next chunk that the read callback function is to return in <code>dataP</code>. It's important for the read callback function to set the number of bytes (in <code>sizeP</code>) that it actually placed in <code>dataP</code>, if it's not the same as what <code>ExgDBRead</code> expected. <code>ExgDBRead</code> stops calling the read callback function after it receives the entire database (it knows when it's got it all based on the header information).</dl><a name="925126"> </a><h4>Compatibility </h4><dl><a name="925130"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl><a name="925131"> </a><h4>See Also </h4><dl><a name="925135"> </a><p></p><dt><code><a href="ExchangeManager.html#925138"></code>ExgDBWrite<code></a></code></dl></dl></dl><a name="925138"> </a><br> <br> <br><h3> ExgDBWrite</h3><dl><dl><a name="925139"> </a><h4>Purpose </h4><dl><a name="925140"> </a><p></p><dt>Reads a given Palm OS database in its internal format from the local device and writes it out using a function you supply. For example, this function might read a local database and transmit it by a beaming operation using the exchange manager.	 </dl><a name="925141"> </a><h4>Prototype </h4><dl><a name="925142"> </a><dt><code>Err ExgDBWrite (ExgDBWriteProcPtr&nbsp;writeProcP, void*&nbsp;userDataP, const&nbsp;char*&nbsp;nameP, LocalID&nbsp;dbID, UInt16&nbsp;cardNo)</code></dl></dl><dl><a name="925143"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925145"> </a><CODE>-&gt; <code>writeProcP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to a function that you supply that writes out the database identified by <code>dbID</code>. See <code><a href="ExchangeManager.html#925424"></code>WriteProc<code></a></code> for details.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925149"> </a><CODE>-&gt; <code>userDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to any data you want to pass to the <code>writeProcP</code> function.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925150"> </a><CODE>-&gt; <code>nameP</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>A pointer to the name of the database that you want <code>ExgDBWrite</code> to read and pass to <code>writeProcP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925151"> </a><CODE>-&gt; <code>dbID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The id of the database that you want <code>ExgDBWrite</code> to read and pass to <code>writeProcP</code>. If you don't supply an ID, then <code>nameP</code> is used to search for the database by name.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925152"> </a><CODE>-&gt; <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The number of the card on which to look for the database identified by <code>nameP</code>.<br></TD></TR></TABLE></dl><dl><a name="925153"> </a><h4>Result </h4><dl><a name="925154"> </a><p></p><dt>Returns <code>errNone</code> if successful; otherwise, returns one of the data manager error codes (<code>dmErr...</code>) or a callback-specific error code (if the <code>writeProcP</code> function returns an error, it is also returned by <code>ExgDBWrite</code>).</dl></dl><dl><a name="925155"> </a><h4>Comments </h4><dl><a name="925156"> </a><p></p><dt>The <code>writeProcP</code> parameter points to a function that you supply and that is called by <code>ExgDBWrite</code> to write out a database. For example, you might use this function to call exchange manager functions to beam the database to another unit.<a name="925157"> </a><p></p><dt>The write callback function is called multiple times by <code>ExgDBWrite</code>. In the <code>sizeP</code> parameter, <code>ExgDBWrite</code> passes the number of bytes in <code>dataP</code>. Due to transport errors, timeouts, or other problems, you may not be able to successfully send all this data. If the write callback function didn't handle it all, it's important that it set in <code>sizeP</code> the number of bytes that it did handle successfully. <code>ExgDBWrite</code> stops calling the write callback function after you write out the entire database (it knows when you've done it all based on the header information and number of bytes you return in <code>sizeP</code> each time).</dl><a name="925158"> </a><h4>Compatibility </h4><dl><a name="925162"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl><a name="925163"> </a><h4>See Also </h4><dl><a name="925167"> </a><p></p><dt><code><a href="ExchangeManager.html#925101"></code>ExgDBRead<code></a></code></dl></dl></dl><a name="925170"> </a><br> <br> <br><h3> ExgDisconnect</h3><dl><dl><a name="925171"> </a><h4>Purpose </h4><dl><a name="925172"> </a><p></p><dt>Terminates an exchange manager transfer and disconnects.</dl><a name="925173"> </a><h4>Prototype </h4><dl><a name="925174"> </a><dt><code>Err ExgDisconnect(ExgSocketPtr&nbsp;socketP, Err&nbsp;error)</code></dl></dl><dl><a name="925175"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925176"> </a><CODE>-&gt; <code>socketP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the socket structure identifying the connection to terminate.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925177"> </a><CODE>-&gt; <code>error</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Any application error that occurred.<br></TD></TR></TABLE></dl><dl><a name="925178"> </a><h4>Result </h4><dl><a name="925196"> </a><p></p><dt>Returns the following result codes:<p><a name="926311"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925181"> </a><code>errNone</code> </td><td><a name="925183"> </a>No error</td></tr><tr><td><a name="925185"> </a><code>exgErrBadLibrary</code></td><td><a name="925187"> </a>Couldn't find default exchange library</td></tr><tr><td><a name="925189"> </a><code>exgMemError</code></td><td><a name="925191"> </a>Couldn't read data to send</td></tr><tr><td><a name="925193"> </a><code>exgErrUserCancel</code></td><td><a name="925195"> </a>User cancelled transfer</td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925197"> </a><h4>Comments </h4><dl><a name="925198"> </a><p></p><dt>In the <code>error</code> parameter, pass any error that occurs during the application loop, including errors returned from other exchange manager functions. This ensures that the connection is shut down knowing that it failed rather than succeeded.<a name="925199"> </a><p></p><dt>It's especially important to check the result code from this function, since this will tell you if the transfer was successful. An <code>errNone</code> return value means that the item was delivered to the destination successfully. It does not mean that the user on the other end actually kept the data. <a name="925200"> </a><p></p><dt><code>ExgDisconnect</code> is used for sending and receiving. When receiving, the application can insert its creator ID into the <code>goToCreator</code> field in the socket structure and add other goto information. After the application returns from the <code>sysAppLaunchCmdExgReceiveData</code> call, the system will launch the application with a standard <code>sysAppLaunchCmdGoto</code> launch code built from the information in the socket header <code>gotoParams</code> field.</dl><a name="925201"> </a><h4>Compatibility </h4><dl><a name="925205"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl><a name="925206"> </a><h4>See Also </h4><dl><a name="925216"> </a><p></p><dt><code><a href="ExchangeManager.html#925246"></code>ExgPut<code></a></code>, <code><a href="ExchangeManager.html#925290"></code>ExgReceive<code></a></code>, <code><a href="ExchangeManager.html#925348"></code>ExgSend<code></a></code></dl></dl></dl><a name="937271"> </a><br> <br> <br><h3> ExgDoDialog</h3><dl><dl><a name="937272"> </a><h4>Purpose </h4><dl><a name="937273"> </a><p></p><dt>Display a dialog that allows users to accept or reject the receipt of data. </dl><a name="937274"> </a><h4>Prototype </h4><dl><a name="937275"> </a><dt><code>Boolean ExgDoDialog (ExgSocketPtr&nbsp;socketP, ExgDialogInfoType&nbsp;*infoP, Err&nbsp;*errP)</code></dl></dl><dl><a name="937276"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="937277"> </a><CODE>-&gt; <code>socketP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the socket structure identifying the connection. You can obtain this pointer from the <code><a href="AppLaunchCodes.html#925235"></code>sysAppLaunchCmdExgAskUser<code></a></code> launch code parameter block. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="937282"> </a><CODE>&lt;-&gt; <code>infoP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to an <code>ExgDialogInfoType</code> structure (see the "Comment" section below). <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="937283"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><code>errNone</code> if no error, or the error code if an error occurred. Currently, no errors are returned.<br></TD></TR></TABLE></dl><dl><a name="937284"> </a><h4>Result </h4><dl><a name="937285"> </a><p></p><dt>Returns <code>true</code> if the user clicks the OK button on the dialog, or <code>false</code> otherwise. </dl></dl><dl><a name="937286"> </a><h4>Comments </h4><dl><a name="937287"> </a><p></p><dt>This function displays the exchange dialog, which prompts the user to accept or reject incoming data. <a name="937288"> </a><p></p><dt>By default, the exchange manager calls this function for you if you don't handle the <code><a href="AppLaunchCodes.html#925235"></code>sysAppLaunchCmdExgAskUser<code></a></code> launch code or if you return <code>exgAskDialog</code> from the launch code handler. When the exchange manager calls <code>ExgDoDialog</code>, the dialog only displays a message similar to "Do you want to accept `John Doe' into AddressBook?" and allows the user to accept or reject the data. If the user clicks OK, the data should be received as an unfiled record. <a name="937293"> </a><p></p><dt>To allow users to select a category when accepting incoming data, handle <code><a href="AppLaunchCodes.html#925235"></code>sysAppLaunchCmdExgAskUser<code></a></code> to call <code>ExgDoDialog</code> explicitly, and pass it a pointer to an <code>ExgDialogInfoType</code> structure. The <code>ExgDialogInfoType</code> structure is defined as follows: </dl></dl><dl><a name="937297"> </a><br><code>typedef struct {</code><br></dl><dl><a name="937298"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 version;</code><br><a name="937299"> </a><code>&nbsp&nbsp&nbsp DmOpenRef	 	 	 	 	 db;</code><br><a name="937300"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 categoryIndex;</code><br><a name="937302"> </a><code>} ExgDialogInfoType;</code><br><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="937303"> </a><CODE>-&gt; <code>version</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Set this field to 0 to specify version 0 of this structure. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="937304"> </a><CODE>-&gt; <code>db</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to an open database that defines the categories the dialog should display. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="937305"> </a><CODE>&lt;- <code>categoryIndex</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Index of the category in which the user wants to file the incoming data. <br></TD></TR></TABLE><dl><a name="939408"> </a><p></p><dt>If <code>db</code> is valid, the function extracts the category information from the specified database and displays it in a pop-up list. Upon return, the <code>categoryIndex</code> field contains the index of the category the user selected, or <code>dmUnfiledCategory</code> if the user did not select a category. <a name="939409"> </a><p></p><dt>If the call to <code>ExgDoDialog</code> is successful, your application is responsible for retaining the value returned in <code>categoryIndex</code> and using it to file the incoming data as a record in that category. One way to do this is to store the <code>categoryIndex</code> in the socket's <code>appData</code> field (see <code><a href="ExchangeManager.html#924968"></code>ExgSocketType<code></a></code>) and then extract it from the socket in your response to the launch code <code><a href="AppLaunchCodes.html#925259"></code>sysAppLaunchCmdExgReceiveData<code></a></code>. For example: </dl></dl><dl><a name="937907"> </a><br><code>if (cmd == sysAppLaunchCmdExgReceiveData) {</code><br></dl><dl><a name="939753"> </a><code>&nbsp&nbsp&nbsp UInt16 categoryID = </code><br><a name="939866"> </a><code>&nbsp&nbsp&nbsp 	 (ExgSocketPtr)cmdPBP-&gt;appData;</code><br><a name="939754"> </a><code>&nbsp&nbsp&nbsp /* other declarations */</code><br><a name="937963"> </a><code></code><br><a name="938200"> </a><code>/* Receive the data, and create a new record </code><br><a name="939501"> </a><code>&nbsp&nbsp&nbsp using the received data. indexNew is the </code><br><a name="942330"> </a><code>&nbsp&nbsp&nbsp index of this record. */</code><br></dl><dl><a name="937742"> </a><br><code>&nbsp&nbsp&nbsp if (categoryID){</code><br></dl><dl><a name="937743"> </a><code>&nbsp&nbsp&nbsp 	 UInt16 attr;</code><br><a name="937744"> </a><code>&nbsp&nbsp&nbsp 	 Err err;</code><br><a name="937747"> </a><code>&nbsp&nbsp&nbsp 	 err = DmRecordInfo(dbP, indexNew, &amp;attr, </code><br><a name="938171"> </a><code>&nbsp&nbsp&nbsp 	 	 NULL, NULL);</code><br><a name="938079"> </a><code></code><br><a name="938080"> </a><code>&nbsp&nbsp&nbsp 	 // Set the category to the one the user </code><br><a name="938435"> </a><code>&nbsp&nbsp&nbsp 	 // specified, and mark the record dirty. </code><br><a name="938082"> </a><code>&nbsp&nbsp&nbsp 	 if ((attr &amp; dmRecAttrCategoryMask) != </code><br><a name="938113"> </a><code>&nbsp&nbsp&nbsp 	 	 categoryID) {</code><br><a name="937751"> </a><code>&nbsp&nbsp&nbsp 	 	 attr &amp;= ~dmRecAttrCategoryMask;</code><br><a name="937752"> </a><code>&nbsp&nbsp&nbsp 	 	 attr |= categoryID | dmRecAttrDirty;</code><br><a name="937753"> </a><code>&nbsp&nbsp&nbsp 	 	 err = DmSetRecordInfo(dbP, indexNew, </code><br><a name="938142"> </a><code>&nbsp&nbsp&nbsp 	 	 	 &amp;attr, NULL);</code><br><a name="937754"> </a><code>&nbsp&nbsp&nbsp 	 }</code><br><a name="937755"> </a><code>&nbsp&nbsp&nbsp }</code><br><a name="939867"> </a><code>}</code><br><dl><a name="944423"> </a><p></p><dt>Some of the Palm OS built-in applications (AddressBook, Memo, and ToDo) use this method of setting the category on data received through beaming. Refer to the example code for these applications provided in the SDK for a more complete example of how to use <code>ExgDoDialog</code>.<a name="938778"> </a><p></p><dt>When you explicitly call <code>ExgDoDialog</code>, you must set the <code>result</code> field of the <code>sysAppLaunchCmdExgAskUser</code> launch code's parameter block to either <code>exgAskOk</code> (upon success) or <code>exgAskCancel</code> (upon failure) to prevent the system from displaying the dialog a second time. </dl></dl><dl><a name="937315"> </a><h4>Compatibility </h4><dl><a name="937316"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#486514">3.5 New Feature Set</a> is present. </dl></dl></dl><a name="925246"> </a><br> <br> <br><h3> ExgPut</h3><dl><dl><a name="925247"> </a><h4>Purpose </h4><dl><a name="925248"> </a><p></p><dt>Initiates the transfer of data to the destination device.</dl><a name="925249"> </a><h4>Prototype </h4><dl><a name="925250"> </a><dt><code>Err ExgPut (ExgSocketPtr&nbsp;socketP)</code></dl></dl><dl><a name="925251"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925252"> </a><CODE>-&gt; <code>socketP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the socket structure containing connection information and information identifying the object to send.<br></TD></TR></TABLE></dl><dl><a name="925253"> </a><h4>Result </h4><dl><a name="925271"> </a><p></p><dt>Returns the following result codes:<p><a name="926349"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925256"> </a><code>errNone</code></td><td><a name="925258"> </a>No error</td></tr><tr><td><a name="925260"> </a><code>exgErrBadLibrary</code></td><td><a name="925262"> </a>Couldn't find default exchange library</td></tr><tr><td><a name="925264"> </a><code>exgErrStackInit</code></td><td><a name="925266"> </a>Couldn't initialize the IR stack (not enough battery power or unsupported hardware)</td></tr><tr><td><a name="925268"> </a><code>exgMemError</code></td><td><a name="925270"> </a>Not enough memory to initialize transfer</td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925272"> </a><h4>Comments </h4><dl><a name="925273"> </a><p></p><dt>If the connection does not already exist, this function establishes one. You must create and pass a pointer to an <code>ExgSocketType</code> structure containing information about the data to send and the destination application. All unused fields in the structure <strong>must</strong> be zeroed. <a name="925274"> </a><p></p><dt>If no error is returned, this call <strong>must</strong> be followed by <code>ExgSend</code>, to begin sending data, or <code>ExgDisconnect</code>, to disconnect. You may need to call <code>ExgSend</code> multiple times to send all the data.</dl><a name="925275"> </a><h4>Compatibility </h4><dl><a name="925279"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl><a name="925280"> </a><h4>See Also </h4><dl><a name="925287"> </a><p></p><dt><code><a href="ExchangeManager.html#925170"></code>ExgDisconnect<code></a></code>, <code><a href="ExchangeManager.html#925348"></code>ExgSend<code></a></code></dl></dl></dl><a name="925290"> </a><br> <br> <br><h3> ExgReceive</h3><dl><dl><a name="925291"> </a><h4>Purpose </h4><dl><a name="925292"> </a><p></p><dt>Receives data from a remote device.</dl><a name="925293"> </a><h4>Prototype </h4><dl><a name="925294"> </a><dt><code>UInt32 ExgReceive (ExgSocketPtr&nbsp;socketP, void&nbsp;*bufP, const&nbsp;UInt32&nbsp;bufLen, Err * err)</code></dl></dl><dl><a name="925295"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925296"> </a><CODE>-&gt; <code>socketP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the socket structure.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925297"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the buffer to receive the data.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925298"> </a><CODE>-&gt; <code>bufLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to receive.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925299"> </a><CODE>&lt;- <code>err</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to an error code result.<br></TD></TR></TABLE></dl><dl><a name="925300"> </a><h4>Result </h4><dl><a name="925301"> </a><p></p><dt>Returns the number of bytes actually received. A zero result indicates the end of the transmission. An error code is returned in the address indicated by <code>err</code>. The error code <code>exgErrUserCancel</code> is returned if the user cancels the operation.</dl></dl><dl><a name="925302"> </a><h4>Comments </h4><dl><a name="925303"> </a><p></p><dt>Call this function one or more times to receive all the data, following a successful call to <code>ExgAccept</code>. After receiving the data, call <code>ExgDisconnect</code> to terminate the connection.<a name="925304"> </a><p></p><dt>This function blocks the application until the end of the transmission or until the requested number of bytes has been received. However, it does provide its own user interface that will be updated as necessary and will allow the user to cancel the operation in progress. </dl><a name="925305"> </a><h4>Compatibility </h4><dl><a name="925309"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl><a name="925310"> </a><h4>See Also </h4><dl><a name="925317"> </a><p></p><dt><code><a href="ExchangeManager.html#941095"></code>ExgAccept<code></a></code>, <code><a href="ExchangeManager.html#925170"></code>ExgDisconnect<code></a></code></dl></dl></dl><a name="925320"> </a><br> <br> <br><h3> ExgRegisterData</h3><dl><dl><a name="925321"> </a><h4>Purpose </h4><dl><a name="925322"> </a><p></p><dt>Registers an application to receive a specific type of data.</dl><a name="925323"> </a><h4>Prototype </h4><dl><a name="925324"> </a><dt><code>Err ExgRegisterData (const&nbsp;UInt32&nbsp;creatorID, const&nbsp;UInt16&nbsp;id, const&nbsp;Char&nbsp;*&nbsp;const&nbsp;dataTypesP)</code></dl></dl><dl><a name="925325"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925326"> </a><CODE>-&gt; <code>creatorID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Creator ID of the registering application.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925327"> </a><CODE>-&gt; <code>id</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Registry ID identifying the type of the items being registered. Specify <code>exgRegExtensionID</code> or <code>exgRegTypeID</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925328"> </a><CODE>-&gt; <code>dataTypesP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a tab-delimited, null-terminated string listing the items to register. (Use /t for the tab character.) These include file extensions or MIME types. To unregister, pass a <code>NULL</code> value.<br></TD></TR></TABLE></dl><dl><a name="925329"> </a><h4>Result </h4><dl><a name="925330"> </a><p></p><dt>Returns <code>errNone</code> if successful, otherwise, one of the data manager error codes (<code>dmErr</code>...).</dl></dl><dl><a name="925331"> </a><h4>Comments </h4><dl><a name="925332"> </a><p></p><dt>Applications that wish to receive data from anything other than another Palm OS device running the same application must use this function to register for the kinds of data they can receive. Call this function when your application is loaded on the device.<a name="925333"> </a><p></p><dt>Specify <code>exgRegExtensionID</code> to register to receive data that has a filename with a particular extension. For example, if your application wants to receive files with a .TXT extension, it could register like this:</dl></dl><dl><a name="925334"> </a><br><code><code>ExgRegisterData(myCreator, exgRegExtensionID, "TXT");</code></code><br><dl><a name="925335"> </a><p></p><dt>If the application wants to receive files with a .TXT extension or with a .DOC extension, it could register like this: </dl><a name="945913"> </a><br><code><code>ExgRegisterData(myCreator, exgRegExtensionID, "TXT/tDOC");</code></code><br><dl><a name="945762"> </a><p></p><dt>Specify <code>exgRegTypeID</code> to register to receive data with a specific MIME type. For example, if your application wants to receive "setext" text files, it could register like this:</dl><a name="925336"> </a><br><code><code>ExgRegisterData(myCreator, exgRegTypeID, <br>"text/x-setext");</code></code><br><dl><a name="946096"> </a><p></p><dt>Note that in the current implementation of the IR library, registering for a MIME type has no effect because the IR library does not send data type information. Therefore, the type is always received as <code>NULL</code> and will not match "setext." However, applications may choose to register for a type anyway because this limitation may be removed in the future. <a name="925338"> </a><p></p><dt>Registrations are active until a hard reset or until the application is removed. The registration information is backed up and restored across a soft reset. When an application is removed, its registry information is also automatically removed from the registry, so there is not normally a need to unregister. If you want to unregister, you can register with a <code>NULL</code> value.</dl></dl><dl><a name="925341"> </a><h4>Compatibility </h4><dl><a name="925345"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl></dl></dl><a name="925348"> </a><br> <br> <br><h3> ExgSend</h3><dl><dl><a name="925349"> </a><h4>Purpose </h4><dl><a name="925350"> </a><p></p><dt>Sends data to the destination device.</dl><a name="925351"> </a><h4>Prototype </h4><dl><a name="925352"> </a><dt><code>UInt32 ExgSend (ExgSocketPtr&nbsp;socketP, const&nbsp;void&nbsp;*&nbsp;const&nbsp;bufP, const&nbsp;UInt32&nbsp;bufLen, Err&nbsp;*&nbsp;err)</code></dl></dl><dl><a name="925353"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925354"> </a><CODE>-&gt; <code>socketP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the socket structure.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925355"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the data to send.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925356"> </a><CODE>-&gt; <code>bufLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to send.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925357"> </a><CODE>&lt;- <code>err</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to an error code result.<br></TD></TR></TABLE></dl><dl><a name="925358"> </a><h4>Result </h4><dl><a name="925359"> </a><p></p><dt>Returns the number of bytes sent, normally the same number as specified in <code>bufLen</code>. An error code is returned in the address indicated by <code>err</code>. The error code <code>exgErrUserCancel</code> is returned if the user cancels the operation.</dl></dl><dl><a name="925360"> </a><h4>Comments </h4><dl><a name="925361"> </a><p></p><dt>Call this function one or more times to send all the data, following a successful call to <code>ExgPut</code>. After sending the data, call <code>ExgDisconnect</code> to terminate the connection.<a name="925362"> </a><p></p><dt>The lower level protocol may break large amounts of data into multiple packets or assemble small send commands together into larger packets, but the application will not be aware of these transport level details.<a name="925363"> </a><p></p><dt>This function blocks the application until all the data is sent. However, it does provide its own user interface that will be updated as necessary and will allow the user to cancel the operation in progress.</dl><a name="925364"> </a><h4>Compatibility </h4><dl><a name="925368"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483537">3.0 New Feature Set</a> is present.</dl><a name="925369"> </a><h4>See Also </h4><dl><a name="925376"> </a><p></p><dt><code><a href="ExchangeManager.html#925170"></code>ExgDisconnect<code></a></code>, <code><a href="ExchangeManager.html#925246"></code>ExgPut<code></a></code></dl></dl></dl><a name="925378"> </a><h2> Application-Defined Functions</h2><dl><a name="925379"> </a><p></p><dt>The functions in this section are supplied by you and can be named anything. You supply pointers to the functions in exchange manager functions that you call (<code><a href="ExchangeManager.html#925101"></code>ExgDBRead<code></a></code> and <code><a href="ExchangeManager.html#925138"></code>ExgDBWrite<code></a></code>).</dl><a name="925388"> </a><br> <br> <br><h3> DeleteProc</h3><dl><dl><a name="925389"> </a><h4>Purpose </h4><dl><a name="925393"> </a><p></p><dt>Handle the case where a database with an identical name already exists on the device. </dl><a name="925394"> </a><h4>Prototype </h4><dl><a name="925395"> </a><dt><code>Boolean DeleteProc (const&nbsp;char*&nbsp;nameP, UInt16&nbsp;version, UInt16&nbsp;cardNo, LocalID&nbsp;dbID, void*&nbsp;userDataP)</code></dl></dl><dl><a name="925396"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925397"> </a><CODE>-&gt; <code>nameP</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>A pointer to the name of the identical database that already exists.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925398"> </a><CODE>-&gt; <code>version</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The version of the identical database that already exists.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925399"> </a><CODE>-&gt; <code>cardNo</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The card number of the identical database that already exists.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925400"> </a><CODE>-&gt; <code>dbID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The database ID of the identical database that already exists.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925401"> </a><CODE>-&gt; <code>userDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The <code>userDataP</code> parameter passed to <code><a href="ExchangeManager.html#925101"></code>ExgDBRead<code></a></code> is simply passed on to the delete function. You can use it for application-specific data.<br></TD></TR></TABLE></dl><dl><a name="925402"> </a><h4>Result </h4><dl><a name="925403"> </a><p></p><dt>Returns a Boolean value. <code>true</code> means that this function handled the situation successfully; that is, it deleted, renamed, or moved the database so there would no longer be a conflict with the one that <code>ExgDBRead</code> is writing. <code>false</code> means that this function did not handle the situation successfully; in this case, <code>ExgDBRead</code> exits with no error (same as if the user cancelled the operation).</dl></dl><dl><a name="925404"> </a><h4>Comments </h4><dl><a name="925405"> </a><p></p><dt>This delete callback function gives you a chance to delete the existing database, or take some other action (such as changing the database name, if appropriate).</dl></dl></dl><a name="925408"> </a><br> <br> <br><h3> ReadProc</h3><dl><dl><a name="925409"> </a><h4>Purpose </h4><dl><a name="925413"> </a><p></p><dt>Read in the database and pass it to <code><a href="ExchangeManager.html#925101"></code>ExgDBRead<code></a></code>.</dl><a name="925414"> </a><h4>Prototype </h4><dl><a name="925415"> </a><dt><code>Err ReadProc (void*&nbsp;dataP, UInt32*&nbsp;sizeP, void*&nbsp;userDataP)</code></dl></dl><dl><a name="925416"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925417"> </a><CODE>-&gt; <code>dataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to a buffer where this function should place the database data.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925418"> </a><CODE>&lt;-&gt; <code>sizeP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The size of <code>dataP</code>. This value is set by <code>ExgDBRead</code> to the number of bytes it expects to receive in <code>dataP</code>. You must set this value to the number of bytes you return in <code>dataP</code> (if it's not the same).<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925419"> </a><CODE>-&gt;<code> userDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The <code>userDataP</code> parameter passed to <code>ExgDBRead</code> is simply passed on to the read function. You can use it for application-specific data.<br></TD></TR></TABLE></dl><dl><a name="925420"> </a><h4>Result </h4><dl><a name="925421"> </a><p></p><dt>Returns an error number, or <code>errNone</code> if there is no error. If this function returns an error, <code>ExgDBRead</code> deletes the database it was creating, cleans up any memory it allocated, then exits, returning the error passed back from this function.</dl></dl></dl><a name="925424"> </a><br> <br> <br><h3> WriteProc</h3><dl><dl><a name="925425"> </a><h4>Purpose </h4><dl><a name="925429"> </a><p></p><dt>Writes out the database.</dl><a name="925430"> </a><h4>Prototype </h4><dl><a name="925431"> </a><dt><code>Err WriteProc (const&nbsp;void*&nbsp;dataP, UInt32*&nbsp;sizeP, void*&nbsp;userDataP)</code></dl></dl><dl><a name="925432"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925433"> </a><CODE>-&gt; <code>dataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A pointer to a buffer containing the database data, placed there by <code><a href="ExchangeManager.html#925138"></code>ExgDBWrite<code></a></code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925434"> </a><CODE>&lt;-&gt; <code>sizeP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The number of bytes placed in <code>dataP</code> by <code>ExgDBWrite</code>. If you were unable to write out or send all of the data in this chunk, on exit, you should set <code>sizeP</code> to the number of bytes you did write.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925435"> </a><CODE>-&gt; <code>userDataP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The <code>userDataP</code> parameter passed to <code>ExgDBWrite</code> is simply passed on to the write function. You can use it for application-specific data.<br></TD></TR></TABLE></dl><dl><a name="925436"> </a><h4>Result </h4><dl><a name="925437"> </a><p></p><dt>Returns an error number, or <code>errNone</code> if there is no error. If this function returns an error, <code>ExgDBWrite</code> closes the database it was reading, cleans up any memory it allocated, then exits, returning the error passed back from this function.<dl><a name="927795"> </a><p></p><dt><strong></strong></dl></dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="ConnectionMgr.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="IRLib.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 53 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:28:56 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/ExchangeManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
</html>