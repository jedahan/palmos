<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/Localization.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:17 GMT -->
<head><title>Localized Applications</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="InternetApps.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="DebuggingStrats.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS Programmer's Companion</B></center><hr><br><a name="924904"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924902"> </a>13 Localized Applications</h1><dl><a name="924906"> </a><p></p><dt>When you write an application (or any other type of software) that is going to be localized, you need to take special care when working with characters, strings, numbers, and dates, as different countries represent these items in different ways. This chapter describes how to write code for localized applications, focusing on the text manager and international manager, which were introduced in Palm OS<sup>&#174;</sup> version 3.1, and the overlay manager, which is introduced in Palm OS version 3.5. The chapter covers:<ul type="SQUARE"><a name="924913"> </a><br><li><a href="Localization.html#924948">Localization Guidelines</a><br><a name="930066"> </a><br><li><a href="Localization.html#930283">Using Overlays to Localize Resources</a><br><a name="924917"> </a><br><li><a href="Localization.html#924972">Text Manager and International Manager</a><br><a name="924921"> </a><br><li><a href="Localization.html#924998">Characters</a><br><a name="924925"> </a><br><li><a href="Localization.html#925137">Strings</a><br><a name="924929"> </a><br><li><a href="Localization.html#925456">Dates</a><br><a name="924933"> </a><br><li><a href="Localization.html#925510">Numbers</a><br><a name="924937"> </a><br><li><a href="Localization.html#925549">Compatibility Information</a><br><a name="924941"> </a><br><li><a href="Localization.html#925587">Notes on the Japanese Implementation</a><br><a name="924945"> </a><br><li><a href="Localization.html#925642">Summary of Localization</a><br></ul><a name="924946"> </a><p></p><dt>This chapter does not cover how to actually perform localization of resources. For more information on this subject, see your tools documentation.</dl><a name="924948"> </a><h2> Localization Guidelines</h2><dl><a name="924951"> </a><p></p><dt>When you start planning for the localized version of your application, follow these guidelines: <ul type="SQUARE"><a name="924952"> </a><br><li>If you use the English language version of the software as a guide when designing the layout of the screen, try to allow:<br><p></p><ul type="CIRCLE"><a name="924953"> </a><li>extra space for strings <a name="924954"> </a><li>larger dialogs than the English version requires</ul><a name="924955"> </a><br><li>Don't put language-dependent strings in code. If you have to display text directly on the screen, remember that a one-line warning or message in one language may need more than one line in another language. See the section <a href="Localization.html#925137">"Strings"</a> in this chapter for further discussion. <br><a name="924959"> </a><br><li>Don't depend on the physical characteristics of a string, such as the number of characters, the fact that it contains a particular substring, or any other attribute that might disappear in translation. <br><a name="924960"> </a><br><li>Use the functions described in this chapter when working with characters, strings, numbers, and dates. <br><a name="924961"> </a><br><li>Consider using string templates as described in the section <a href="Localization.html#925385">"Dynamically Determining a String's Contents"</a> in this chapter. Use as many parameters as possible to give localizers greater flexibility. Avoid building sentences by concatenating substrings together, as this often causes translation problems. <br><a name="924965"> </a><br><li>Abbreviations may be the best way to accommodate the particularly scarce screen real estate on the Palm OS device. <br><a name="924966"> </a><br><li>Remember that user interface elements such as lists, fields, and tips scroll if you need more space. <br></ul><a name="924970"> </a><p></p><dt>The chapter <a href="Design.html#924905">"Good Design Practices"</a> provides further user interface guidelines. </dl><a name="930283"> </a><h2> Using Overlays to Localize Resources</h2><dl><a name="930284"> </a><p></p><dt>Palm OS version 3.5 adds support for localizing resource databases through <strong>overlays</strong>. Localization overlays provide a method for localizing a software module without requiring a recompile or modification of the software. Each overlay database is a separate resource database that provides an appropriately localized set of resources for a single software module (the PRC file, or <strong>base database</strong>) and a single target <strong>locale</strong> (language and country). Note that each Palm OS device supports a single locale. <a name="929547"> </a><p></p><dt>No requirements are placed on the base database, so for example, third parties can construct localization overlays for existing applications without forcing any modifications by the original application developer. In rare cases, you might want to disable the use of overlays to prevent third parties from creating overlays for your application. To do so, you should include an <code>'xprf'=0</code> resource (symbolically named <code>sysResTExtPrefs</code>) in the database and set its <code>disableOverlays</code> flag. This resource is defined in <code>UIResources.r</code>. <a name="929126"> </a><p></p><dt>An overlay database has the same creator as the base database, but its type is <code>'ovly'</code>, and a suffix identifying the target locale is appended to its name. For example, <code>Datebook.prc</code> might be overlaid with a database named <code>Datebook_jpJP</code>, which indicates that this overlay is for Japan. Each overlay database has an <code>'ovly'</code>=1000 resource specifying the base database's type, the target locale, and information necessary to identify the correct version of the base database for which it was designed. <a name="929137"> </a><p></p><dt>The Palm OS SDK provides tools that you can use to create overlays. See <em>Using the PRC to Overlay Tool </em>for more information on creating overlays. <a name="929684"> </a><p></p><dt>When a PRC file is opened on a system that supports overlays, the overlay manager determines what the locale is for this device and it looks for an overlay matching the base database and the locale. The overlay database's name must match the base database's name, its suffix must match the locale's suffix, and it must have an <code>'ovly'</code>=1000 resource that matches the base database. If the name, suffix, and overlay resource are all correct, the overlay is opened in addition to the PRC file. When the PRC file is closed, its overlay is closed as well. <a name="929832"> </a><p></p><dt>The overlay is opened in read-only mode and is hidden from the programmer. When you request a database pointer, you'll receive a pointer to the base database, not the overlay. You can simply make resource manager calls like you normally would, and the resource manager accesses the overlay where appropriate. <a name="929965"> </a><p></p><dt>When accessing a localizable resource, do not use functions that search for a resource only in the database you specify. For example: <dl><a name="929225"> </a><br><code>// WRONG! searches only one database. </code><br></dl><dl><a name="929229"> </a><code>DmOpenRef dbP = DmNextOpenResDatabase(NULL);</code><br><a name="929226"> </a><code>UInt16 resIndex = DmFindResource(dpP, strRsc, </code><br><a name="929230"> </a><code>&nbsp&nbsp&nbsp strRscID);</code><br><a name="929380"> </a><code>MemHandle resH = DmGetResourceIndex(dbP, </code><br><a name="929395"> </a><code>&nbsp&nbsp&nbsp resIndex);</code><br><dl><a name="929233"> </a><p></p><dt>In the example above, <code>dbP</code> is a pointer to the most recently opened database, which is typically the overlay version of the database. Passing this pointer to <code>DmFindDatabase</code> means that you are searching only the overlay database for the resource. If you're searching for a non-localized resource, <code>DmFindResource</code> won't be able to locate it. Instead, you should use <code>DmGet1Resource</code>, which searches the most recently opened database and its overlay for a resource, or <code>DmGetResource</code>, which searches all open databases and their overlays. </dl></dl><dl><a name="929378"> </a><br><code>// Right. DmGet1Resource searches both </code><br></dl><dl><a name="931793"> </a><code>// databases. </code><br><a name="929379"> </a><code>MemHandle resH = DmGet1Resource(strRsc, </code><br><a name="929404"> </a><code>&nbsp&nbsp&nbsp strRscID);</code><br></dl><dl><a name="929405"> </a><br><code>// Or use DmGetResource to search all open </code><br></dl><dl><a name="931847"> </a><code>// databases.</code><br><a name="929423"> </a><code>MemHandle resH = DmGetResource(strRsc, </code><br><a name="931376"> </a><code>&nbsp&nbsp&nbsp strRscID);</code><br><dl><a name="929469"> </a><p></p><dt>The data manager only opens an overlay if the resource database is opened in read-only mode. If you open a resource database in read-write mode, the associated overlay is not opened. What's more, if you modify the an overlaid resource in the base database, the checksum in the overlay's <code>'ovly'</code> resource becomes invalid, which prevents the overlay from being used at all. Thus if you change the resource database, you must also change the overlay database. <a name="930955"> </a><p></p><dt>You typically don't work with the overlay manager directly although it does provide a few public functions. One potentially useful function is <code><a href="OverlayMgr.html#993255"></code>OmGetCurrentLocale<code></a></code>, which returns a structure identifying the locale on this device. </dl></dl></dl><a name="924972"> </a><h2> Text Manager and International Manager</h2><dl><a name="924973"> </a><p></p><dt>The Palm OS provides two managers that help you work with localized strings and characters. These managers are called the text manager and the international manager. <a name="924974"> </a><p></p><dt>Computers represent the characters in an alphabet with a numeric code. The set of numeric codes for a given alphabet is called a <strong>character encoding</strong>. Of course, a character encoding contains more than codes for the letters of an alphabet. It also encodes punctuation, numbers, control characters, and any other characters deemed necessary. The set of characters that a character encoding represents is called, appropriately enough, a <strong>character set</strong>. <a name="924975"> </a><p></p><dt>As you know, different languages use different alphabets. Most European languages use the Latin alphabet. The Latin alphabet is relatively small, so its characters can be represented using a single-byte encoding ranging from 32 to 255. On the other hand, Asian languages such as Chinese, Korean, and Japanese require their own alphabets, which are much larger. These larger character sets are represented by a combination of single-byte and double-byte numeric codes ranging from 32 to 65,535. <a name="924976"> </a><p></p><dt>A given Palm OS device supports one language and one character encoding to represent the characters required by that language. Although the Palm OS supports multiple character encodings, a given device uses only one of those encodings. For example, a French device would probably use a character encoding similar to the Microsoft<sup>&#174;</sup> Windows<sup>&#174;</sup> code page 1252 character encoding (an extension of ISO Latin 1), while a Japanese device would use a character encoding similar to Microsoft Windows code page 932 (an extension of Shift JIS). Code page 932 is not supported on the French device, and code page 1252 is not supported on the Japanese device even though they both use the same version of Palm OS. No matter what the encoding is on a device, Palm guarantees that the low ASCII characters (0 to 0x7F) are the same. The exception to this rule is 0x5C, which is a yen symbol on Japanese devices and a backslash on all others.<a name="924977"> </a><p></p><dt>The text manager allows you to work with text, strings, and characters independent of the character encoding. If you use text manager routines and don't work directly with string data, your code should work on any system, regardless of which language and character encoding the device supports (as long as it supports the text manager). <a name="924978"> </a><p></p><dt>The international manager's job is to detect which character encoding a device uses and initialize the corresponding version of the text manager. The international manager also sets system features that identify which encoding and fonts are used. For the most part, you don't work with the international manager directly. <a name="924979"> </a><p></p><dt>The text manager and international manager are supported starting in Palm OS version 3.1. If your application should work on older systems, you should test for the presence of these managers before using text manager calls. <a href="Localization.html#924987">Listing 13.1</a> shows how. </dl><a name="924987"> </a><h4>Listing 13.1	 Testing for text and international managers</h4><a name="924988"> </a><hr><code>UInt32 intlMgrAttr; </code><br><a name="924989"> </a><code>if (FtrGet(sysFtrCreator, sysFtrNumIntlMgr, </code><br><a name="930307"> </a><code>&nbsp&nbsp&nbsp &amp;intlMgrAttr) != 0)<br>	 	 intlMgrAttr = 0;</code><br><a name="924990"> </a><code>if (intlMgrAttr &amp; intlMgrExists) {</code><br><a name="924991"> </a><code>&nbsp&nbsp&nbsp // If international manager exists, so does the </code><br><a name="927744"> </a><code>&nbsp&nbsp&nbsp // text manager.<br>	 // Use text manager calls. </code><br><a name="924992"> </a><code>} </code><br><hr><br><a name="928948"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>You can still use the text manager and be compatible with earlier releases if you link your application with the PalmOSGlue library. See the section <a href="Localization.html#925549">"Compatibility Information"</a> for more information.<hr><br></blockquote><a name="924998"> </a><h2> Characters</h2><dl><a name="924999"> </a><p></p><dt>Depending on the device's supported language, the Palm OS may encode characters using either a single-byte encoding or a multi-byte encoding. Because you do not know which character encoding is used until runtime, <strong>you should never make an assumption about the size of a character</strong>. <a name="925000"> </a><p></p><dt>For the most part, your application does not need to know which character encoding is used, and in fact, it should make no assumptions about the encoding or about the size of characters. Instead, your code should use text manager functions to manipulate characters. This section describes how to work with characters correctly in a localized application. It covers: <ul type="SQUARE"><a name="925004"> </a><br><li><a href="Localization.html#925026">Declaring Character Variables</a><br><a name="925008"> </a><br><li><a href="Localization.html#925039">Using Character Constants</a><br><a name="925012"> </a><br><li><a href="Localization.html#925048">Missing and Invalid Characters</a><br><a name="925016"> </a><br><li><a href="Localization.html#925080">Retrieving a Character's Attributes</a><br><a name="925020"> </a><br><li><a href="Localization.html#925085">Virtual Characters</a><br><a name="925024"> </a><br><li><a href="Localization.html#925116">Retrieving the Character Encoding</a><br></ul></dl><a name="925026"> </a><h3> Declaring Character Variables</h3><dl><a name="925028"> </a><p></p><dt>Declare all character variables to be of type <code>WChar</code>. <code>WChar</code> is a 16-bit unsigned type that can accommodate characters of any encoding. Don't use <code>Char</code>. <code>Char</code> is an 8-bit variable that cannot accommodate larger character encodings. The only time you should ever use <code>Char</code> is to pass a parameter to an older Palm OS function. <dl><a name="925030"> </a><br><code>WChar ch; // Right. 16-bit character. </code><br></dl><dl><a name="925031"> </a><code>Char ch; // Wrong. 8-bit character. </code><br><dl><a name="925033"> </a><p></p><dt>When you receive input characters through the <code>keyDownEvent</code>, you'll receive a <code>WChar</code> value. (That is, the <code>data.keyDown.chr</code> field is a <code>WChar</code>.)<a name="925034"> </a><p></p><dt>Even though character variables are now declared as <code>WChar</code>, string variables are still declared as <code>Char *</code>, even though they may contain multi-byte characters. See the section <a href="Localization.html#925137">"Strings"</a> for more information on strings. </dl></dl></dl><a name="925039"> </a><h3> Using Character Constants</h3><dl><a name="925040"> </a><p></p><dt>Character constants are defined in several header files. The header file <code>Chars.h</code> contains characters that are guaranteed to be supported on all systems regardless of the encoding. Other header files exist for each supported character encoding and contain characters specific to that encoding. The character encoding-specific header files are not included in the <code>PalmOS.h</code> header by default because they define characters that are not available on every system. <a name="925042"> </a><p></p><dt>To make it easier for the compiler to find character encoding problems with your project, make a practice of using the character constants defined in these header files rather than directly assigning a character variable to a value. For example, suppose your code contained this statement: <dl><a name="925043"> </a><br><code>WChar ch = '&aring;'; // WRONG! Don't use. </code><br><dl><a name="925044"> </a><p></p><dt>This statement may work on a Latin system, but it would cause problems on an Asian-language system because the &aring; character does not exist. If you instead assign the value this way:</dl><a name="925045"> </a><br><code>WChar ch = chrSmall_A_RingAbove; </code><br><dl><a name="925046"> </a><p></p><dt>you'll find the problem at compile time because the <code>chrSmall_A_RingAbove</code> constant is defined in <code>CharLatin.h</code>, which is not included by default. </dl></dl></dl><a name="925048"> </a><h3> Missing and Invalid Characters</h3><dl><a name="925049"> </a><p></p><dt>If during application testing, you see an open rectangle, a shaded rectangle, or a gray square displayed on the screen, you have a missing character. <a name="925050"> </a><p></p><dt>A <strong>missing character</strong> is one that is valid within the character encoding but the current font is not able to display it. In this case, nothing is wrong with your code other than you have chosen the wrong font. The system displays a gray square in place of a missing double-byte character and an open rectangle in place of a missing single-byte rectangle (see <a href="Localization.html#925055">Figure 13.1</a>). </dl><a name="925055"> </a><h4>Figure 13.1	 Missing/invalid characters</h4><p><a name="925063"> </a><img src="images/Localizationa.gif" height="93" width="624"></p><dl><a name="925064"> </a><p></p><dt>In multi-byte character encodings, a character may be missing as described above, or it may be invalid. In single-byte character encodings, there's a one-to-one correspondence between numeric values and characters to represent. This is not the case with multi-byte character encodings. In multi-byte character encodings, there are more possible values than there are characters to represent. Thus, a character variable could end up containing an <strong>invalid character</strong>--a value that doesn't actually represent a character. <a name="925065"> </a><p></p><dt>If the system is asked to display an invalid character, it prints an open rectangle for the first invalid byte. Then it starts over at the next byte. Thus, the next character displayed and possibly even the remaining text displayed is probably not what you want. Check your code for the following: <ul type="SQUARE"><a name="925066"> </a><br><li>Truncating strings. You might have truncated a string in the middle of a multi-byte character.<br><a name="925067"> </a><br><li>Appending characters from one encoding set to a string in a different encoding. <br><a name="925068"> </a><br><li>Arithmetic on character variables that could result in an invalid character value. <br><a name="925069"> </a><br><li>Arithmetic on a string pointer that could result in pointing to an intra-character boundary. See <a href="Localization.html#925216">"Performing String Pointer Manipulation"</a> for more information. <br><a name="925073"> </a><br><li>Assumptions that a character is always a single byte long. <br></ul><a name="925078"> </a><p></p><dt>Use the text manager function <code><a href="TextMgr.html#925509"></code>TxtCharIsValid<code></a></code> to determine whether a character is valid or not. </dl><a name="925080"> </a><h3> Retrieving a Character's Attributes</h3><dl><a name="925081"> </a><p></p><dt>The text manager defines certain functions that retrieve a character's attributes, such whether the character is alphanumeric, etc. You can use these functions on any character, regardless of its size and encoding. <a name="925082"> </a><p></p><dt>A character also has attributes unique to its encoding. Functions to retrieve those attributes are defined in the header files specific to the encoding. <a name="925083"> </a><blockquote><hr><em><strong>WARNING!</strong></em><p></p>In previous versions of the Palm OS, the header file <code>CharAttr.h</code> defined character attribute macros such as <code>IsAscii</code>. Using these macros on double-byte characters produces incorrect results. Use the text manager macros instead of the <code>CharAttr.h</code> macros. <hr><br></blockquote></dl><a name="925085"> </a><h3> Virtual Characters</h3><dl><a name="925086"> </a><p></p><dt>Virtual characters are nondisplayable characters that trigger special events in the operating system, such as displaying low battery warnings or displaying the keyboard dialog. Virtual characters should never occur in any data and should never appear on the screen. <a name="925087"> </a><p></p><dt>The Palm OS uses character codes 256 decimal and greater for virtual characters. The range for these characters may actually overlap the range for "real" characters (characters that should appear on the screen). The <code>keyDownEvent</code> distinguishes a virtual character from a displayable character by setting the command bit in the event record. <a name="927819"> </a><p></p><dt>The best way to check for virtual characters, including virtual characters that represent the hard keys, is to use the <code><a href="PalmOSGlueLib.html#925303"></code>TxtGlueCharIsVirtual<code></a></code> function defined in the PalmOSGlue library. (See <a href="Localization.html#925549">"Compatibility Information"</a> for more information on the PalmOSGlue library.)<a name="925088"> </a><p></p><dt>Therefore, when you check for a virtual character, first check the command bit in the event record. If the command bit is set, then the character is virtual. See <a href="Localization.html#925093">Listing 13.2</a>. </dl><a name="925093"> </a><h4>Listing 13.2	 Checking for virtual characters</h4><a name="925094"> </a><hr><code>if (TxtGlueCharIsVirtual</code><br><a name="927844"> </a><code>&nbsp&nbsp&nbsp (eventP-&gt;data.keyDown.modifiers, </code><br><a name="927845"> </a><code>&nbsp&nbsp&nbsp eventP-&gt;data.keyDown.chr)) {</code><br><a name="927847"> </a><code>&nbsp&nbsp&nbsp if (TxtCharIsHardKey</code><br><a name="927863"> </a><code>&nbsp&nbsp&nbsp 	 (event-&gt;data.keyDown.modifiers, </code><br><a name="927848"> </a><code>&nbsp&nbsp&nbsp 	 event-&gt;data.keyDown.chr)) {</code><br><a name="925096"> </a><code>&nbsp&nbsp&nbsp 	 // Handle hard key virtual character.</code><br><a name="927866"> </a><code>&nbsp&nbsp&nbsp } else {</code><br><a name="927873"> </a><code>&nbsp&nbsp&nbsp 	 // Handle standard virtual character.</code><br><a name="927874"> </a><code>&nbsp&nbsp&nbsp }</code><br><a name="927875"> </a><code>} else {</code><br><a name="927876"> </a><code>&nbsp&nbsp&nbsp // Handle regular character.</code><br><a name="927877"> </a><code>}</code><br><hr><br><a name="925116"> </a><h3> Retrieving the Character Encoding</h3><dl><a name="925117"> </a><p></p><dt>Occasionally, you may need to determine which character encoding is being used. For example, your application may need to do some unique text manipulation if it is being run on a European device. You can retrieve the character encoding from the system feature set using the <code>FtrGet</code> function as shown in <a href="Localization.html#925123">Listing 13.3</a>. </dl><a name="925123"> </a><h4>Listing 13.3	 Retrieving the character encoding</h4><a name="925124"> </a><hr><code>UInt32 encoding; </code><br><a name="925125"> </a><code>Char* encodingName;</code><br><a name="925126"> </a><code>if (FtrGet(sysFtrCreator, sysFtrNumEncoding, </code><br><a name="927905"> </a><code>&nbsp&nbsp&nbsp &amp;encoding) != 0)<br>	 encoding = charEncodingPalmLatin; </code><br><a name="927933"> </a><code>&nbsp&nbsp&nbsp 	 //default encoding</code><br><a name="925127"> </a><code>if (encoding == charEncodingPalmSJIS) {</code><br><a name="925128"> </a><code>&nbsp&nbsp&nbsp // encoding for Palm Shift-JIS</code><br><a name="925129"> </a><code>} else if (encoding == charEncodingPalmLatin) {</code><br><a name="925130"> </a><code>&nbsp&nbsp&nbsp // extension of ISO Latin 1</code><br><a name="925131"> </a><code>}</code><br><a name="925132"> </a><code></code><br><a name="925133"> </a><code>// The following text manager function returns the </code><br><a name="927950"> </a><code>// official name of the encoding as required by </code><br><a name="927975"> </a><code>// Internet applications. </code><br><a name="925135"> </a><code>encodingName = TxtEncodingName(encoding);</code><br><hr><br><a name="925137"> </a><h2> Strings</h2><dl><a name="925138"> </a><p></p><dt>On systems that support the international manager and the text manager, strings are made up of characters that are either a single-byte long or multiple bytes long, up to four bytes. As stated previously, character variables are always two bytes long. However, when you add a character to a string, the operating system may shrink it down to a single byte if it's a low ASCII character. Thus, any string that you work with may contain a mix of single-byte and multi-byte characters. <a name="925139"> </a><p></p><dt>Using characters of different sizes in a string has implications for manipulating strings, searching strings, and implementing the global find facility in your application. This section describes how to perform all of these tasks using text manager functions. It also describes how to create and display dynamically computed strings and how to display error messages. <ul type="SQUARE"><a name="925143"> </a><br><li><a href="Localization.html#925166">Manipulating Strings</a><br><a name="925147"> </a><br><li><a href="Localization.html#925216">Performing String Pointer Manipulation</a><br><a name="925151"> </a><br><li><a href="Localization.html#925230">Truncating Displayed Text</a><br><a name="925155"> </a><br><li><a href="Localization.html#925241">Comparing Strings</a><br><a name="925159"> </a><br><li><a href="Localization.html#925254">Global Find</a><br><a name="925163"> </a><br><li><a href="Localization.html#925385">Dynamically Determining a String's Contents</a><br><a name="925164"> </a><blockquote><br><hr><br><em>TIP:  </em>Many of the existing Palm OS functions have been modified to work with strings containing multi-byte characters. All Palm OS functions that return the length of a string, such as <code>FldGetTextLength</code> and <code>StrLen</code>, always return the size of the string in bytes, not the number of characters in the string. <br><hr><br></blockquote></ul></dl><a name="925166"> </a><h3> Manipulating Strings</h3><dl><a name="925167"> </a><p></p><dt>Any time that you want to work with character pointers, you need to be careful not to point to an intra- character boundary (a middle or end byte of a multi-byte character). For example, any time that you want to set the insertion point position in a text field or set the text field's selection, you must make sure that you use byte offsets that point to inter-character boundaries. (The <strong>inter-character boundary</strong> is both the start of one character and the end of the previous character, except when the offset points to the very beginning or very end of a string.) <a name="925168"> </a><p></p><dt>Suppose you want to iterate through a string character by character. Traditionally, C code uses a character pointer or byte counter to iterate through a string a character at a time. Such code will not work properly on systems with multi-byte characters. Instead, if you want to iterate through a string a character at a time, use text manager functions: <ul type="SQUARE"><a name="925173"> </a><br><li><code><a href="TextMgr.html#925784"></code>TxtGetNextChar<code></a></code> retrieves the next character in a string. <br><a name="925178"> </a><br><li><code><a href="TextMgr.html#925818"></code>TxtGetPreviousChar<code></a></code> retrieves the previous character in a string. <br><a name="925183"> </a><br><li><code><a href="TextMgr.html#926006"></code>TxtSetNextChar<code></a></code> changes the next character in a string and can be used to fill a string buffer. <br></ul><a name="925184"> </a><p></p><dt>Each of these three functions returns the size of the character in question, so you can use it to determine the offset to use for the next character. For example, <a href="Localization.html#925189">Listing 13.4</a> shows how to iterate through a string character by character until a particular character is found. </dl><a name="925189"> </a><h4>Listing 13.4	 Iterating through a string or text</h4><a name="925190"> </a><hr><code>Char* buffer; // assume this exists</code><br><a name="925191"> </a><code>Int16 bufLen = StrLen(buffer); </code><br><a name="927978"> </a><code>// Length of the input text. </code><br><a name="925192"> </a><code>WChar ch = 0;</code><br><a name="925193"> </a><code>UInt16 i = 0;</code><br><a name="925194"> </a><code>while ((i &lt; bufLen) &amp;&amp; (ch != chrAsterisk))</code><br><a name="925195"> </a><code>&nbsp&nbsp&nbsp i+= TxtGetNextChar(buffer, i, &amp;ch));</code><br><hr><br><dl><a name="925196"> </a><p></p><dt>The text manager also contains functions that let you determine the size of a character without iterating through the string: <ul type="SQUARE"><a name="925201"> </a><br><li><code><a href="TextMgr.html#925534"></code>TxtCharSize<code></a></code> returns how much space a given character will take up inside of a string. <br><a name="925206"> </a><br><li><code><a href="TextMgr.html#925151"></code>TxtCharBounds<code></a></code> determines the boundaries of a given character within a given string. <br></ul></dl><a name="925208"> </a><h4>Listing 13.5	 Working with arbitrary limits</h4><a name="925209"> </a><hr><code>UInt32* charStart, charEnd;</code><br><a name="925210"> </a><code>Char* fldTextP = FldGetTextPtr(fld);</code><br><a name="925211"> </a><code>TxtCharBounds(fldTextP, min(kMaxBytesToProcess,</code><br><a name="925212"> </a><code>&nbsp&nbsp&nbsp FldGetTextLength(fld)), &amp;charStart, &amp;charEnd);</code><br><a name="925213"> </a><code>// process only the first charStart bytes of text.</code><br><a name="925214"> </a><code></code><br><hr><br><a name="925216"> </a><h3> Performing String Pointer Manipulation</h3><dl><a name="925217"> </a><p></p><dt>Never perform any pointer manipulation on strings you pass to the text manager unless you use text manager calls to do the manipulation. For text manager functions to work properly, the string pointer must point to the first byte of a character. If you use text manager functions when manipulating a string pointer, you can be certain that your pointer always points to the beginning of a character. Otherwise, you run the risk of pointing to an inter-character boundary. <dl><a name="925218"> </a><br><code>// WRONG! buffer + kMaxStrLength is not </code><br></dl><dl><a name="927979"> </a><code>// guaranteed to point to start of character.</code><br><a name="925220"> </a><code>buffer[kMaxStrLength] = '\0';</code><br><a name="925222"> </a><code></code><br></dl><dl><a name="925223"> </a><br><code>// Right. Truncate at a character boundary.</code><br></dl><dl><a name="925226"> </a><code>UInt32 charStart, charEnd;</code><br><a name="925227"> </a><code>TxtCharBounds(buffer, kMaxStrLength, </code><br><a name="927990"> </a><code>&nbsp&nbsp&nbsp &amp;charStart, &amp;charEnd);</code><br><a name="925228"> </a><code>TxtSetNextChar(buffer, charStart, chrNull);</code><br></dl></dl><a name="925230"> </a><h3> Truncating Displayed Text</h3><dl><a name="925231"> </a><p></p><dt>If you're performing drawing operations, you often have to determine where to truncate a string if it's too long to fit in the available space. Two functions help you perform this task on strings with multi-byte characters:<ul type="SQUARE"><a name="925235"> </a><br><li><code><a href="Window.html#925685"></code>WinDrawTruncChars<code></a></code> - This function draws a string within a specified width, determining automatically where to truncate the string. If it can, it draws the entire string. If the string doesn't fit in the space, it draws one less than the number of characters that fit and then ends the string with an ellipsis (...). <br><a name="925239"> </a><br><li><code><a href="Font.html#925171"></code>FntWidthToOffset<code></a></code> - This function returns the byte offset of the character displayed at a given pixel position. It can also return the width of the text up to that offset. <br></ul></dl><a name="925241"> </a><h3> Comparing Strings</h3><dl><a name="925246"> </a><p></p><dt>Use the text manager functions <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code> and <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code> to perform comparisons of strings. <a name="925251"> </a><p></p><dt>In character encodings that use multi-byte characters, some characters are accurately represented as either single-byte characters or multi-byte characters. That is, a character might have both a single-byte representation and a double-byte representation. One string might use the single-byte representation and another might use the multi-byte representation. Users expect the characters to match regardless of how many bytes a string uses to store that character. <code>TxtCompare</code> and <code>TxtCaselessCompare</code> can accurately match single-byte characters with their multi-byte equivalents. <a name="925252"> </a><p></p><dt>Because a single-byte character might be matched with a multi-byte character, two strings might be considered equal even though they have different lengths. For this reason, <code>TxtCompare</code> and <code>TxtCaselessCompare</code> take two parameters in which they pass back the length of matching text in each of the two strings. See the function descriptions in the <em>Palm OS SDK Reference</em> for more information. <a name="928293"> </a><p></p><dt>Note that <code>StrCompare</code> and <code>StrCaselessCompare</code> are equivalent, but they do not pass back the length of the matching text. </dl><a name="925254"> </a><h3> Global Find</h3><dl><a name="925255"> </a><p></p><dt>A special case of performing string comparison is implementing the global system find facility. To implement this facility, you should call <code><a href="TextMgr.html#925718"></code>TxtFindString<code></a></code>. As with <code>TxtCompare</code> and <code>TxtCaselessCompare</code>, <code>TxtFindString</code> accurately matches single-byte characters with their corresponding multi-byte characters. Plus, it passes back the length of the matched text. You'll need this value to highlight the matching text when the system requests that you display the matching record. <a name="925264"> </a><p></p><dt>Older versions of Palm OS use the function <code><a href="Find.html#924952"></code>FindStrInStr<code></a></code>. <code>FindStrInStr</code> is not able to return the length of the matching text. Instead, it assumes that characters within the string are always one byte long. <a name="925271"> </a><p></p><dt><a href="Localization.html#925282">Listing 13.6</a> and <a href="Localization.html#925349">Listing 13.7</a> show how to implement a global find facility on all systems (whether the text manager exists or not), and how to implement a response to <code><a href="AppLaunchCodes.html#925328"></code>sysAppLaunchCmdGoto<code></a></code>, which is the system's request that the matching record be displayed. These two listings are only code excerpts. For the complete implementation of these two functions, see the example code in your development environment. </dl><a name="925282"> </a><h4>Listing 13.6	 Implementing global find </h4><a name="925283"> </a><hr><code>static void Search (FindParamsPtr findParams)</code><br><a name="925284"> </a><code>{</code><br><a name="925286"> </a><code>&nbsp&nbsp&nbsp UInt16 recordIndex = 0;</code><br><a name="925290"> </a><code>&nbsp&nbsp&nbsp DmOpenRef dbP;</code><br><a name="925291"> </a><code>&nbsp&nbsp&nbsp UInt16 cardNo = 0;</code><br><a name="925292"> </a><code>&nbsp&nbsp&nbsp LocalID dbID;</code><br><a name="925294"> </a><code>&nbsp&nbsp&nbsp MemoDBRecordPtr memoPadRecP;</code><br><a name="925298"> </a><code></code><br><a name="925299"> </a><code></code><br><a name="925305"> </a><code>&nbsp&nbsp&nbsp // Open the database to be searched.</code><br><a name="925306"> </a><code>&nbsp&nbsp&nbsp dbP = DmOpenDatabaseByTypeCreator(memoDBType, </code><br><a name="928310"> </a><code>&nbsp&nbsp&nbsp 	 sysFileCMemo, findParams-&gt;dbAccesMode);</code><br><a name="925309"> </a><code>&nbsp&nbsp&nbsp DmOpenDatabaseInfo(dbP, &amp;dbID, 0, 0, &amp;cardNo, </code><br><a name="928313"> </a><code>&nbsp&nbsp&nbsp 	 0);</code><br><a name="928550"> </a><code></code><br><a name="928551"> </a><code>&nbsp&nbsp&nbsp // Get first record to search. </code><br><a name="925311"> </a><code>&nbsp&nbsp&nbsp memoRecP = GetRecordPtr(dbP, recordIndex);</code><br><a name="925312"> </a><code>&nbsp&nbsp&nbsp while (memoRecP != NULL) {</code><br><a name="925313"> </a><code>&nbsp&nbsp&nbsp 	 Boolean done;</code><br><a name="928420"> </a><code>&nbsp&nbsp&nbsp 	 Boolean match;</code><br><a name="928421"> </a><code>&nbsp&nbsp&nbsp 	 UInt32 matchPos, matchLength;</code><br><a name="928554"> </a><code></code><br><a name="928558"> </a><code>&nbsp&nbsp&nbsp 	 // TxtGlueFindString calls TxtFindString if it</code><br><a name="928559"> </a><code>&nbsp&nbsp&nbsp 	 // exists, or else it implements the Latin</code><br><a name="928560"> </a><code>&nbsp&nbsp&nbsp 	 // equivalent of it. </code><br><a name="925328"> </a><code>&nbsp&nbsp&nbsp 	 match = TxtGlueFindString (&amp;(memoRecP-&gt;note), </code><br><a name="925329"> </a><code>&nbsp&nbsp&nbsp 	 	 findParams-&gt;strToFind, &amp;matchPos, </code><br><a name="928557"> </a><code>&nbsp&nbsp&nbsp 	 	 &amp;matchLength);</code><br><a name="925330"> </a><code>&nbsp&nbsp&nbsp 	 </code><br><a name="925331"> </a><code>&nbsp&nbsp&nbsp 	 if (match) {</code><br><a name="925332"> </a><code>&nbsp&nbsp&nbsp 	 	 done = FindSaveMatch (findParams, </code><br><a name="928565"> </a><code>&nbsp&nbsp&nbsp 	 	 	 recordIndex, matchPos, 0, matchLength,</code><br><a name="925333"> </a><code>&nbsp&nbsp&nbsp 	 	 	 cardNo, dbIDP);</code><br><a name="928576"> </a><code>&nbsp&nbsp&nbsp 	 }</code><br><a name="925341"> </a><code>&nbsp&nbsp&nbsp 	 MemPtrUnlock (memoRecP);</code><br><a name="925342"> </a><code></code><br><a name="925343"> </a><code>&nbsp&nbsp&nbsp 	 if (done) break;</code><br><a name="925344"> </a><code>&nbsp&nbsp&nbsp 	 recordIndex += 1;</code><br><a name="925345"> </a><code>&nbsp&nbsp&nbsp }</code><br><a name="925346"> </a><code>&nbsp&nbsp&nbsp DmCloseDatabase (dbP);</code><br><a name="925347"> </a><code>}</code><br><hr><br><a name="925349"> </a><h4>Listing 13.7	 Displaying the matching record</h4><a name="925350"> </a><hr><code>static void GoToRecord (GoToParamsPtr goToParams, Boolean launchingApp)</code><br><a name="925351"> </a><code>{</code><br><a name="925352"> </a><code>&nbsp&nbsp&nbsp UInt16 recordNum;</code><br><a name="925353"> </a><code>&nbsp&nbsp&nbsp EventType event;</code><br><a name="925356"> </a><code></code><br><a name="925360"> </a><code>&nbsp&nbsp&nbsp recordNum = goToParams-&gt;recordNum;</code><br><a name="925362"> </a><code>&nbsp&nbsp&nbsp ...</code><br><a name="925363"> </a><code></code><br><a name="925364"> </a><code>&nbsp&nbsp&nbsp // Send an event to goto a form and select the </code><br><a name="928601"> </a><code>&nbsp&nbsp&nbsp // matching text.</code><br><a name="925365"> </a><code>&nbsp&nbsp&nbsp MemSet (&amp;event, sizeof(EventType), 0);</code><br><a name="925366"> </a><code></code><br><a name="925367"> </a><code>&nbsp&nbsp&nbsp event.eType = frmLoadEvent;</code><br><a name="925368"> </a><code>&nbsp&nbsp&nbsp event.data.frmLoad.formID = EditView;</code><br><a name="925369"> </a><code>&nbsp&nbsp&nbsp EvtAddEventToQueue (&amp;event);</code><br><a name="925370"> </a><code> </code><br><a name="925371"> </a><code>&nbsp&nbsp&nbsp MemSet (&amp;event, sizeof(EventType), 0);</code><br><a name="928602"> </a><code>&nbsp&nbsp&nbsp event.eType = frmGotoEvent;</code><br><a name="925372"> </a><code>&nbsp&nbsp&nbsp event.data.frmGoto.recordNum = recordNum;</code><br><a name="925373"> </a><code>&nbsp&nbsp&nbsp event.data.frmGoto.matchPos = </code><br><a name="928607"> </a><code>&nbsp&nbsp&nbsp 	 goToParams-&gt;matchPos;</code><br><a name="925375"> </a><code>&nbsp&nbsp&nbsp event.data.formGoto.matchLen = </code><br><a name="925376"> </a><code>&nbsp&nbsp&nbsp 	 goToParams-&gt;matchCustom;</code><br><a name="925379"> </a><code>&nbsp&nbsp&nbsp event.data.frmGoto.matchFieldNum = </code><br><a name="930476"> </a><code>&nbsp&nbsp&nbsp 	 goToParams-&gt;matchFieldNum;</code><br><a name="925380"> </a><code>&nbsp&nbsp&nbsp event.data.frmGoto.formID = EditView;</code><br><a name="925381"> </a><code>&nbsp&nbsp&nbsp EvtAddEventToQueue (&amp;event);</code><br><a name="925382"> </a><code>&nbsp&nbsp&nbsp ...</code><br><a name="925383"> </a><code>}</code><br><hr><br><a name="925385"> </a><h3> Dynamically Determining a String's Contents</h3><dl><a name="925386"> </a><p></p><dt>When working with strings in a localized application, you never hard code them. Instead, you store strings in a resource and use the resource to display the text. If you need to create the contents of the string at runtime, store a template for the string as a resource and then substitute values as needed. <a name="925387"> </a><p></p><dt>For example, consider the Edit view of the Memo application. Its title bar contains a string such as "Memo 3 of 10." The number of the memo being displayed and the total number of memos cannot be determined until runtime. <a name="925388"> </a><p></p><dt>To create such a string, use a template resource and the text manager function <code><a href="TextMgr.html#935442"></code>TxtParamString<code></a></code>. <code>TxtParamString</code> allows you to search for the sequence ^0, ^1, up to ^3 and replace each of these with a different string. (If you need more parameters, you can use <code><a href="TextMgr.html#925982"></code>TxtReplaceStr<code></a></code>, which allows you to replace up to ^9; however, <code>TxtReplaceStr</code> only allows you to replace one of these sequences at a time.) The PalmOSGlue library defines a function <code>TxtGlueParamString</code>, which calls <code>TxtParamString</code> if it exists or else implements the Latin equivalent of it. <a name="928702"> </a><p></p><dt>In the Memo title bar example, you'd create a string resource that looks like this:<dl><a name="925393"> </a><br><code>Memo ^0 of ^1</code><br><dl><a name="925394"> </a><p></p><dt>And your code might look like this: </dl></dl></dl><a name="925395"> </a><h4>Listing 13.8	 Using string templates</h4><a name="925396"> </a><hr><code>static void EditViewSetTitle (void)</code><br><a name="925397"> </a><code>{</code><br><a name="925398"> </a><code>&nbsp&nbsp&nbsp Char* titleTemplateP;</code><br><a name="925399"> </a><code>&nbsp&nbsp&nbsp FormPtr frm;</code><br><a name="925400"> </a><code>&nbsp&nbsp&nbsp Char posStr [maxStrIToALen];</code><br><a name="925401"> </a><code>&nbsp&nbsp&nbsp Char totalStr [maxStrIToALen];</code><br><a name="925402"> </a><code>&nbsp&nbsp&nbsp UInt16 pos;</code><br><a name="928811"> </a><code>&nbsp&nbsp&nbsp UInt16 length;</code><br><a name="925404"> </a><code></code><br><a name="925406"> </a><code>&nbsp&nbsp&nbsp // Format as strings, the memo's postion within </code><br><a name="925407"> </a><code>&nbsp&nbsp&nbsp // its category, and the total number of memos </code><br><a name="928628"> </a><code>&nbsp&nbsp&nbsp // in the category.</code><br><a name="925408"> </a><code>&nbsp&nbsp&nbsp pos = DmPositionInCategory (MemoPadDB, </code><br><a name="925409"> </a><code>&nbsp&nbsp&nbsp 	 CurrentRecord, RecordCategory);</code><br><a name="925410"> </a><code>&nbsp&nbsp&nbsp StrIToA (posStr, pos+1);</code><br><a name="925411"> </a><code></code><br><a name="925412"> </a><code>&nbsp&nbsp&nbsp if (MemosInCategory == memosInCategoryUnknown)</code><br><a name="925413"> </a><code>&nbsp&nbsp&nbsp 	 MemosInCategory = DmNumRecordsInCategory </code><br><a name="928638"> </a><code>&nbsp&nbsp&nbsp 	 	 (MemoPadDB, RecordCategory);</code><br><a name="925415"> </a><code>&nbsp&nbsp&nbsp StrIToA (totalStr, MemosInCategory);</code><br><a name="925416"> </a><code></code><br><a name="925417"> </a><code>&nbsp&nbsp&nbsp // Get the title template string.  It contains </code><br><a name="925418"> </a><code>&nbsp&nbsp&nbsp // '^0' and '^1' chars which we replace with the </code><br><a name="928649"> </a><code>&nbsp&nbsp&nbsp // position of CurrentRecord within </code><br><a name="928650"> </a><code>&nbsp&nbsp&nbsp // CurrentCategory and with the total count of </code><br><a name="925420"> </a><code>&nbsp&nbsp&nbsp // records in CurrentCategory ().</code><br><a name="925421"> </a><code>&nbsp&nbsp&nbsp titleTemplateP = MemHandleLock (DmGetResource </code><br><a name="928651"> </a><code>&nbsp&nbsp&nbsp 	 (strRsc, EditViewTitleTemplateStringString));</code><br><a name="925423"> </a><code></code><br><a name="928737"> </a><code>&nbsp&nbsp&nbsp EditViewTitlePtr = </code><br><a name="928739"> </a><code>&nbsp&nbsp&nbsp 	 TxtGlueParamString(titleTemplateP, posStr, </code><br><a name="928738"> </a><code>&nbsp&nbsp&nbsp 	 totalStr, NULL, NULL);</code><br><a name="925426"> </a><code></code><br><a name="925450"> </a><code>&nbsp&nbsp&nbsp // Now set the title to use the new title </code><br><a name="928697"> </a><code>&nbsp&nbsp&nbsp // string.</code><br><a name="925451"> </a><code>&nbsp&nbsp&nbsp frm = FrmGetFormPtr (MemoPadEditForm);</code><br><a name="925452"> </a><code>&nbsp&nbsp&nbsp FrmSetTitle (frm, EditViewTitlePtr);</code><br><a name="925453"> </a><code>&nbsp&nbsp&nbsp MemPtrUnlock(titleTemplateP);</code><br><a name="925454"> </a><code>}</code><br><hr><br><a name="925456"> </a><h2> Dates</h2><dl><a name="925457"> </a><p></p><dt>If your application deals with dates and times, it should abide by the values the user has set in the system preference for date and time display. The default preferences at startup are different for the different languages, though they can be overridden. <a name="925462"> </a><p></p><dt>To check the system preferences call <code><a href="Preferences.html#924972"></code>PrefGetPreference<code></a></code> with one of the values listed in the second column of <a href="Localization.html#926500">Table 13.1</a>. The third column lists an enumerated type that helps you interpret the value. <p><a name="925498"> </a> </p><p><div> <table border="3"><caption><B><a name="926500"> </a><h4>Table 13.1	 Date and time preferences&nbsp;</h4></B></caption><tr><th><a name="925470"> </a><strong>Preference</strong></th><th><a name="925472"> </a><strong>Name</strong></th><th><a name="925474"> </a><strong>Returns a value of type</strong></th></tr><tr><td><a name="925476"> </a>Date formats (i.e., month first or day first)</td><td><a name="925479"> </a><code>prefDateFormat</code> </td><td><a name="925482"> </a><code>DateFormatType</code></td></tr><tr><td><a name="925484"> </a>Time formats (i.e., use a 12-hour clock or use a 24-hour clock)</td><td><a name="925487"> </a><code>prefTimeFormat</code> </td><td><a name="925490"> </a><code>TimeFormatType</code></td></tr><tr><td><a name="925492"> </a>Start day of week (i.e., Sunday or Monday)</td><td><a name="925495"> </a><code>prefWeekStartDay</code> </td><td><a name="925497"> </a>0 (Sunday) or 1&nbsp;(Monday)</td></tr></table><table><tr><td></table></div></p><a name="925499"> </a><p></p><dt>To work with dates in your code, use the Date and Time Manager API. It contains functions such as <code><a href="DateAndTimeManager.html#925000"></code>DateToAscii<code></a></code>, <code><a href="DateAndTimeManager.html#925066"></code>DayOfMonth<code></a></code>, <code><a href="DateAndTimeManager.html#925079"></code>DayOfWeek<code></a></code>, and <code><a href="DateAndTimeManager.html#925092"></code>DaysInMonth<code></a></code>, which allow you to work with dates independent of the user's preference settings. </dl><a name="925510"> </a><h2> Numbers</h2><dl><a name="925511"> </a><p></p><dt>If your application displays large numbers or floating-point numbers, you must check and make sure you are using the appropriate thousands separator and decimal separator for the device's country by doing the following (see <a href="Localization.html#925533">Listing 13.9</a>):</dl>  <a name="925515"> </a><font face="">Store numbers using US conventions, which means using a "," as the thousands separator and a decimal point (.) as the decimal separator. </font>  <a name="925517"> </a><font face="">Use <code>PrefGetPreference</code> and <code><a href="MiscSys.html#924921"></code>LocGetNumberSeparators<code></a></code> to retrieve information about how the number should be displayed.</font>  <a name="925526"> </a><font face="">Use <code><a href="StringManager.html#925144"></code>StrLocalizeNumber<code></a></code> to perform the localization. </font>  <a name="925527"> </a><font face="">If a user enters a number that you need to manipulate in some way, convert it to the US conventions using <code><a href="StringManager.html#925066"></code>StrDelocalizeNumber<code></a></code>. </font><a name="925533"> </a><h4>Listing 13.9	 Working with numbers</h4><a name="925534"> </a><hr><code>// store numbers using US conventions. </code><br><a name="925535"> </a><code>Char *jackpot = "20,000,000.00";</code><br><a name="925536"> </a><code>Char thou; // thousand separator</code><br><a name="925537"> </a><code>Char dp; // decimal separator</code><br><a name="925538"> </a><code></code><br><a name="925539"> </a><code>// Retrieve current country's preferences. </code><br><a name="925540"> </a><code>LocGetNumberSeparators((NumberFormatType)</code><br><a name="930485"> </a><code>&nbsp&nbsp&nbsp PrefGetPreference(prefNumberFormat), &amp;thou, </code><br><a name="930496"> </a><code>&nbsp&nbsp&nbsp 	 &amp;dp);</code><br><a name="925542"> </a><code>// Localize jackpot number. Converts "," to thou </code><br><a name="930501"> </a><code>// and "." to dp. </code><br><a name="925543"> </a><code>StrLocalizeNumber(jackpot, thou, dp);</code><br><a name="925544"> </a><code>// Display string. </code><br><a name="925545"> </a><code>// Assume inputString is a number user entered, </code><br><a name="925546"> </a><code>// convert it to US conventions this way. Converts </code><br><a name="930506"> </a><code>// thou to "," and dp to "."</code><br><a name="925547"> </a><code>StrDelocalizeNumber(inputNumber, thou, dp);</code><br><hr><br><a name="925549"> </a><h2> Compatibility Information</h2><dl><a name="925550"> </a><p></p><dt>If you want to maintain backward compatibility with earlier releases but you still want to use the localization features described in this chapter, you can link your application with the library PalmOSGlue (<code>PalmOSGlue.lib</code> or <code>libPalmOSGlue.a</code>). This library provides these features for versions 2.0 and 3.0. <a name="925552"> </a><p></p><dt>When you use PalmOSGlue, you use the text manager in the same way as described in this chapter, but the names of the functions are different. For example, <code>TxtFindString</code> is named <code>TxtGlueFindString</code> in the PalmOSGlue. (See the chapter <a href="PalmOSGlueLib.html#924904">"PalmOSGlue Library" </a> of the <em>Palm OS SDK Reference</em> for a complete mapping table.) When you make a call to a glue function (<code>TxtGlue</code><em>Func</em>, <code>FntGlue</code><em>Func</em>, or <code>WinGlue</code><em>Func</em>), the code in PalmOSGlue either uses the text manager or international manager on the ROM or, if the managers don't exist, executes a simple Latin equivalent of the function. <a name="925559"> </a><p></p><dt>PalmOSGlue is a linkable library that is bound to your project at link time. It is not a shared library. PalmOSGlue will increase your application's code size. The exact amount by which your code size increases depends on the number of library functions you call; the linker strips any unused routines and data. <a name="925563"> </a><p></p><dt>Palm OS version 3.1 contains the following changes from previous releases that affect strings, text, and localization. These changes may affect you if you're updating an application written to run on a prior release or if you want to maintain backward compatibility with prior releases: <ul type="SQUARE"><a name="925565"> </a><br><li>The <code>keyDownEvent</code> structure's <code>chr</code> field (which contains the input character) has been changed from a <code>Word</code> to a <code>WChar</code>. The <code>chr</code> field may contain a multi-byte character, so you should never copy the <code>chr</code> field into a <code>Char</code> variable or pass it to a function using a <code>Char</code> parameter. Always use <code>WChar</code>. <br><a name="925566"> </a><br><li>Some of the special Palm OS glyphs in the high ASCII range (such as the shortcut stroke and the command stroke) have been moved down into the control code range, and other characters (such as the numeric space and horizontal ellipsis) have been copied into the control range so that they're guaranteed to exist in every encoding. For the numeric space and horizontal ellipsis, you can use the macros <code><a href="CharacterAttributes.html#924950"></code>ChrNumericSpace<code></a></code> and <code><a href="CharacterAttributes.html#924910"></code>ChrHorizEllipsis<code></a></code> to return the appropriate character regardless of the character map. In PalmOSGlue, these two macros are named <code>TxtGlueGetNumericSpaceChar</code> and <code>TxtGlueGetHorizEllipsisChar</code>, respectively. <br><a name="925577"> </a><br><li>The four playing-card characters have been moved from the high ASCII range in the standard four fonts to the 9-point Symbol font. <br><a name="925578"> </a><br><li>Character attribute functions and macros are now obsolete and have been replaced by functions and macros in the text manager. <br><a name="925585"> </a><br><li>The String Manager functions <code><a href="StringManager.html#924980"></code>StrChr<code></a></code> and <code><a href="StringManager.html#925326"></code>StrStr<code></a></code> now treat buffers as characters, not arbitrary byte arrays. If you previously used these functions to search data buffers, your code may no longer work. <br></ul></dl><a name="925587"> </a><h2> Notes on the Japanese Implementation</h2><dl><a name="925588"> </a><p></p><dt>This section describes programming practices for applications that are to be localized for Japanese use. It covers:<ul type="SQUARE"><a name="925592"> </a><br><li><a href="Localization.html#925606">Japanese Character Encoding</a><br><a name="925596"> </a><br><li><a href="Localization.html#925609">Japanese Character Input</a><br><a name="925600"> </a><br><li><a href="Localization.html#925627">Displaying Japanese Strings on UI Objects</a><br><a name="925604"> </a><br><li><a href="Localization.html#925630">Displaying Error Messages</a><br></ul></dl><a name="925606"> </a><h3> Japanese Character Encoding</h3><dl><a name="925607"> </a><p></p><dt>The character encoding used on Japanese systems is based on Microsoft code page 932. The complete 932 character set (JIS level 1 and 2) is supported in both the standard and large font sizes. The bold versions of these two fonts contain bolded versions of the glyphs found in the 7-bit ASCII range, but the single-byte Katakana characters and the multi-byte characters are not bolded. </dl><a name="925609"> </a><h3> Japanese Character Input</h3><dl><a name="925610"> </a><p></p><dt>On current Japanese devices, users enter Japanese text using Latin (ASCII) characters, and special software called a front-end processor (FEP) transliterates this text into Hiragana or Katakana characters. The user can then ask the FEP to phonetically convert Hiragana characters into a mixture of Hiragana and Kanji (Kana-Kanji conversion).<a name="925611"> </a><p></p><dt>Four silkscreen buttons added to the Japanese device control the FEP transliteration and conversion process. These four FEP buttons are arranged vertically between the current left-most silkscreen buttons and the Graffiti<sup>&#174;</sup> area. The top-most FEP button tells the FEP to attempt Kana-Kanji conversion on the inline text. The next button confirms the inline text and terminates the inline conversion session. The third button toggles the transliteration mode between Hiragana and Katakana. The last button toggles the FEP on and off.<a name="925624"> </a><p></p><dt>Japanese text entry is always inline, which means that transliteration and conversion happen directly inside of a field. The field code passes events to the FEP, which then returns information about the appropriate text to display. <a name="925625"> </a><p></p><dt>During inline conversion, the Graffiti space stroke acts as a shortcut for the conversion FEP button and the Graffiti return stroke acts as a shortcut for the confirm FEP button. </dl><a name="925627"> </a><h3> Displaying Japanese Strings on UI Objects</h3><dl><a name="925628"> </a><p></p><dt>To conserve screen space, you should use half-width Katakana characters on user interface elements (such as buttons, menu items, labels, and pop-up lists) whenever the string contains only Katakana characters. If the string contains a mix of Katakana and either Hiragana, Kanji, or Romaji, then use the full-width Katakana characters instead. </dl><a name="925630"> </a><h3> Displaying Error Messages</h3><dl><a name="925635"> </a><p></p><dt>You may have code that uses the macros <code><a href="ErrorManager.html#925092"></code>ErrFatalDisplayIf<code></a></code> and <code><a href="ErrorManager.html#925117"></code>ErrNonFatalDisplayIf<code></a></code> to determine error conditions. If the error condition occurs, the system displays the file name and line number at which the error occurred along with the message that you passed to the macro. Often these messages are hard-coded strings. On Japanese systems, the Palm OS traps the messages passed to these two macros and displays a generic message explaining that an error has occurred. <a name="925640"> </a><p></p><dt>You should only use <code>ErrFatalDisplayIf</code> and <code>ErrNonFatalDisplayIf</code> for totally unexpected errors. Do not use them for errors that you believe your end users will see. If you wish to inform your users of an error, use a localizable resource to display the error message instead of <code>ErrFatalDisplayIf</code> or <code>ErrNonFatalDisplayIf</code>. </dl><a name="925642"> </a><h2> Summary of Localization</h2><p><a name="925830"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="930680"> </a><strong>Text Manager</strong></th><th><a name="930682"> </a><strong></strong></th></tr><tr><td colspan=2 rowspan=1><a name="930684"> </a><strong>Working With Multi-Byte Characters</strong></td></tr><tr><td><a name="930691"> </a><a href="TextMgr.html#925151">TxtCharBounds</a><br><a href="TextMgr.html#933936">TxtPreviousCharSize</a><br><a href="TextMgr.html#924987">TxtByteAttr</a></td><td><a name="930702"> </a><a href="TextMgr.html#925534">TxtCharSize</a><br><a href="TextMgr.html#934797">TxtNextCharSize</a></td></tr><tr><td><a name="930707"> </a><strong>Changing Text </strong></td><td><a name="930709"> </a></td></tr><tr><td><a name="930714"> </a><a href="TextMgr.html#925982">TxtReplaceStr</a><br><a href="TextMgr.html#925851">TxtGetTruncationOffset</a></td><td><a name="930722"> </a><a href="TextMgr.html#926006">TxtSetNextChar</a><br><a href="TextMgr.html#926071">TxtTransliterate</a></td></tr><tr><td><a name="930727"> </a><strong>Accessing Text</strong></td><td><a name="930729"> </a></td></tr><tr><td><a name="930734"> </a><a href="TextMgr.html#925784">TxtGetNextChar</a><br><a href="TextMgr.html#925756">TxtGetChar</a></td><td><a name="930741"> </a><a href="TextMgr.html#925818">TxtGetPreviousChar</a><br><a href="TextMgr.html#926128">TxtWordBounds</a></td></tr><tr><td colspan=2 rowspan=1><a name="930747"> </a><strong>Searching/Comparing Text</strong></td></tr><tr><td><a name="930753"> </a><a href="TextMgr.html#925029">TxtCaselessCompare</a><br><a href="TextMgr.html#925718">TxtFindString</a></td><td><a name="930763"> </a><a href="TextMgr.html#925610">TxtCompare</a></td></tr><tr><td colspan=2 rowspan=1><a name="930765"> </a><strong>Obtaining a Character's Attributes</strong></td></tr><tr><td><a name="930772"> </a><a href="TextMgr.html#925214">TxtCharIsAlNum</a><br><a href="TextMgr.html#925301">TxtCharIsDigit</a><br><a href="TextMgr.html#925398">TxtCharIsLower</a><br><a href="TextMgr.html#925467">TxtCharIsSpace</a><br><a href="TextMgr.html#925509">TxtCharIsValid</a><br><a href="TextMgr.html#925267">TxtCharIsCntrl</a><br><a href="TextMgr.html#925450">TxtCharIsPunct</a><br><a href="TextMgr.html#925558">TxtCharWidth</a></td><td><a name="930798"> </a><a href="TextMgr.html#925239">TxtCharIsAlpha</a><br><a href="TextMgr.html#925326">TxtCharIsGraph</a><br><a href="TextMgr.html#925423">TxtCharIsPrint</a><br><a href="TextMgr.html#925484">TxtCharIsUpper</a><br><a href="TextMgr.html#925579">TxtCharXAttr</a><br><a href="TextMgr.html#925376">TxtCharIsHex</a><br><a href="TextMgr.html#925079">TxtCharAttr</a></td></tr><tr><td colspan=2 rowspan=1><a name="930818"> </a><strong>Obtaining Character Encoding information</strong></td></tr><tr><td><a name="930825"> </a><a href="TextMgr.html#926036">TxtStrEncoding</a><br><a href="TextMgr.html#925870">TxtMaxEncoding</a></td><td><a name="930833"> </a><a href="TextMgr.html#925661">TxtEncodingName</a><br><a href="TextMgr.html#925175">TxtCharEncoding</a></td></tr></table><table><tr><td></table></div></p><p><a name="925849"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925833"> </a><strong>Localizing Numbers</strong></th><th><a name="925835"> </a><strong></strong></th></tr><tr><td><a name="925840"> </a><a href="StringManager.html#925144">StrLocalizeNumber</a><br><a href="MiscSys.html#924921">LocGetNumberSeparators</a></td><td><a name="925848"> </a><a href="StringManager.html#925066">StrDelocalizeNumber</a></td></tr></table><table><tr><td></table></div></p><p><a name="925862"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925852"> </a><strong>International Manager</strong></th><th><a name="925854"> </a><strong></strong></th></tr><tr><td><a name="925859"> </a><a href="MiscSys.html#925097">IntlGetRoutineAddress</a></td><td><a name="925861"> </a></td></tr></table><table><tr><td></table></div></p><p><a name="930088"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="930078"> </a><strong>Overlay Manager</strong></th><th><a name="930080"> </a><strong></strong></th></tr><tr><td><a name="930085"> </a><a href="OverlayMgr.html#993255">OmGetCurrentLocale</a><br><a href="OverlayMgr.html#993422">OmGetIndexedLocale</a><br><a href="OverlayMgr.html#993525">OmGetRoutineAddress</a><br><a href="OverlayMgr.html#992401">OmSetSystemLocale</a> </td><td><a name="930087"> </a><a href="OverlayMgr.html#993614">OmGetSystemLocale</a><br><a href="OverlayMgr.html#991828">OmLocaleToOverlayDBName</a><br><a href="OverlayMgr.html#992026">OmOverlayDBNameToLocale</a></td></tr></table><table><tr><td></table></div></p><dl><a name="925883"> </a><p></p><dt></dl><hr><br><center><B>Palm OS Programmer's Companion</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="InternetApps.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="DebuggingStrats.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 82 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:49 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/Localization.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:17 GMT -->
</html>