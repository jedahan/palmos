<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SerialCommunication.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:13 GMT -->
<head><title>Serial Communication</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="SystemFeatures.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="Beaming.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS Programmer's Companion</B></center><hr><br><a name="928031"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924902"> </a>9 Serial Communication</h1><dl><a name="928032"> </a><p></p><dt>The Palm OS<sup>&#174;</sup> serial communications software provides high-performance serial communications capabilities, including byte-level serial I/O, best-effort packet-based I/O with CRC-16, reliable data transport with retries and acknowledgments, connection management, and modem dialing capabilities.<a name="924906"> </a><p></p><dt>This chapter helps you understand the different parts of the serial communications system and explains how to use them, discussing these topics:<ul type="SQUARE"><a name="924910"> </a><br><li><a href="SerialCommunication.html#924939">Serial Hardware</a> describes the serial port hardware.<br><a name="924914"> </a><br><li><a href="SerialCommunication.html#924956">Byte Ordering</a> briefly explains the byte order used for all data.<br><a name="924918"> </a><br><li><a href="SerialCommunication.html#924961">Serial Communications Architecture Hierarchy</a> provides an overview of the hierarchy, including an illustration. <br><a name="924925"> </a><br><li><a href="SerialCommunication.html#925047">The Serial Manager</a> and the <a href="SerialCommunication.html#925247">The New Serial Manager</a> are responsible for byte-level serial I/O and control of the RS232 signals.<br><a name="924929"> </a><br><li><a href="SerialCommunication.html#925592">The Connection Manager</a> allows other applications to access, add, and delete connection pro\xde les contained in the Connection preferences panel.<br><a name="924933"> </a><br><li><a href="SerialCommunication.html#925615">The Serial Link Protocol</a> provides an efficient mechanism for sending and receiving packets. <br><a name="924937"> </a><br><li><a href="SerialCommunication.html#925750">The Serial Link Manager</a> is the Palm OS implementation of the serial link protocol.<br></ul></dl><a name="924939"> </a><h2> Serial Hardware</h2><dl><a name="924941"> </a><p></p><dt>The Palm Computing<sup>&#174;</sup> platform device serial port is used for implementing desktop PC connectivity or other external communication. The serial communication is fully interrupt-driven for receiving data. Currently, interrupt-driven transmission of data is not implemented in software, but the hardware does support it. Five external signals are used for this communication:<ul type="SQUARE"><a name="924942"> </a><br><li>SG (signal ground)<br><a name="924943"> </a><br><li>TxD (transmit data)<br><a name="924944"> </a><br><li>RxD (receive data) <br><a name="924945"> </a><br><li>CTS (clear to send)<br><a name="924946"> </a><br><li>RTS (request to send)<br></ul><a name="924948"> </a><p></p><dt>The Palm Computing platform device has an external connector that provides:<ul type="SQUARE"><a name="924949"> </a><br><li>Five serial communication signals<br><a name="924950"> </a><br><li>General-purpose output<br><a name="924951"> </a><br><li>General-purpose input<br><a name="924952"> </a><br><li>Cradle button input<br></ul><a name="924953"> </a><p></p><dt>Palm Computing publishes information designed to assist hardware developers in creating devices to interface with the serial communications port on Palm Computing platform products. You can obtain this information by joining the Solution Provider Program and enrolling in the Serial Port &amp; Modem Casing Program. For more information about this program and the serial port hardware, see the Palm developer web page at: <br><a href="http://www.palmos.com/dev/tech/hardware">http://www.palmos.com/dev/tech/hardware</a><code>.</code></dl><a name="924956"> </a><h2> Byte Ordering</h2><dl><a name="924957"> </a><p></p><dt>By convention, all data coming from and going to the Palm OS device use Motorola byte ordering. That is, data of compound types such as UInt16 (2 bytes) and UInt32 (4 bytes), as well as their integral counterparts, are packaged with the most-significant byte at the lowest address. This contrasts with Intel byte ordering.<a name="924959"> </a><p></p><dt></dl><a name="924961"> </a><h2> Serial Communications Architecture Hierarchy</h2><dl><a name="924962"> </a><p></p><dt>The serial communications software has multiple layers. Higher layers depend on more primitive functionality provided by lower layers. Applications can use functionality of all layers. The software consists of the following layers, described in more detail below:<ul type="SQUARE"><a name="924964"> </a><br><li>The serial manager, at the lowest layer, deals with the Palm device serial port and control of the RS232 signals, providing byte-level serial I/O. See <a href="SerialCommunication.html#925047">The Serial Manager</a>.<br><a name="924969"> </a><br><li>The modem manager provides modem dialing capabilities.<br><a name="924972"> </a><br><li>The Serial Link Protocol (SLP) provides best-effort packet send and receive capabilities with CRC-16. Packet delivery is left to the higher-level protocols; SLP does not guarantee it. See <a href="SerialCommunication.html#925615">The Serial Link Protocol</a>.<br><a name="924978"> </a><br><li>The Packet Assembly/Disassembly Protocol (PADP) sends and receives buffered data. PADP is an efficient protocol featuring variable-size block transfers with robust error checking and automatic retries. Applications don't need access to this part of the system.<br><a name="924981"> </a><br><li>The Connection Management Protocol (CMP) provides <br>connection-establishment capabilities featuring baud rate arbitration and exchange of communications software version numbers. <br><a name="924984"> </a><br><li>The Desktop Link Protocol (DLP) provides remote access to Palm OS data storage and other subsystems. <br><dl><a name="924985"> </a><p></p><dt>DLP facilitates efficient data synchronization between desktop (PC, Macintosh, etc.) and Palm OS applications, database backup, installation of code patches, extensions, applications, and other databases, as well as Remote Interapplication Communication (RIAC) and Remote Procedure Calls (RPC).</dl></ul><a name="924993"> </a><p></p><dt><a href="SerialCommunication.html#924995">Figure 9.1</a> illustrates the communications layers.</dl><a name="924995"> </a><h4>Figure 9.1	 Palm OS Serial Communications Architecture</h4><p><a name="925045"> </a><img src="images/SerialCommunicationa.gif" height="512" width="582"></p><a name="925047"> </a><h2> The Serial Manager</h2><dl><a name="925049"> </a><p></p><dt>The Palm OS serial manager is responsible for byte-level serial I/O and control of the RS232 signals.<a name="925052"> </a><p></p><dt>In order to prolong battery life, the serial manager must be very efficient in its use of processing power. To reach this goal, the serial manager receiver is interrupt-driven. In the present implementation, the serial manager uses the polling mode to send data. </dl><a name="925054"> </a><h3> Using the Serial Manager</h3><dl><a name="925059"> </a><p></p><dt>Before using the serial manager, call <code></code><a href="SystemManager.html#925491">SysLibFind</a>, passing <code>"Serial Library"</code> for the library name to get the serial library reference number. This reference number is used with all subsequent serial manager calls. The system software automatically installs the serial library during system initialization.<a name="925064"> </a><p></p><dt>To open the serial port, call <a href="SerialManager.html#925179">SerOpen</a>, passing the serial library reference number (returned by <code>SysLibFind</code>), 0 (zero) for the port number, and the desired baud rate. An error code of 0 (zero) or -<code>serErrAlreadyOpen</code> indicates that the port was successfully opened. <a name="925068"> </a><p></p><dt>If the serial port is already open when <code>SerOpen</code> is called, the port's open count is incremented and an error code of <code>serErrAlreadyOpen</code> is returned. This ability to open the serial port multiple times allows cooperating tasks to share the serial port. <a name="925070"> </a><p></p><dt>All other applications must refrain from sharing the serial port and close it by calling <a href="SerialManager.html#925054">SerClose</a> when <code>serErrAlreadyOpen</code> is returned. Error codes other than 0 (zero) or <code>serErrAlreadyOpen</code> indicate failure. The application must open the serial port before making other serial manager calls.<a name="925077"> </a><p></p><dt>To close the serial port, call <code>SerClose</code>. Every successful call to <code>SerOpen</code> must eventually be paired with a call to <code>SerClose</code>. Because an open serial port consumes more energy from the device's batteries, it is essential not to keep the port open any longer than necessary.<a name="925079"> </a><p></p><dt>To change serial port settings, such as the baud rate, CTS timeout, number of data and stop bits, parity options, and handshaking options, call <a href="SerialManager.html#925503">SerSetSettings</a>. For baud rates above 19200, use of hardware handshaking is advised.<a name="925087"> </a><p></p><dt>To retrieve the current serial port settings, call <a href="SerialManager.html#925146">SerGetStatus</a>.<a name="925091"> </a><p></p><dt>To retrieve the current line error status, call <a href="SerialManager.html#925146">SerGetStatus</a>, which returns the cumulative status of all line errors being monitored. This includes parity, hardware and software overrun, framing, break detection, and handshake errors.<a name="925096"> </a><p></p><dt>To reset the serial port error status, call <a href="SerialManager.html#925034">SerClearErr</a>, which resets the serial port's line error status. Other serial manager functions, such as <a href="SerialManager.html#925216">SerReceive</a>, immediately return with the error code <code>serErrLineErr</code> if any line errors are pending. Applications should therefore check the result of serial manager function calls and call <a href="SerialManager.html#925034">SerClearErr</a> if line error(s) occurred.<a name="925110"> </a><p></p><dt>To send a stream of bytes, call <a href="SerialManager.html#925364">SerSend</a>. In the present implementation, <code>SerSend</code> blocks until all data are transferred to the UART or a timeout error (if CTS handshaking is enabled) occurs. If your software needs to detect when all data has been transmitted, consider calling <a href="SerialManager.html#925457">SerSendWait</a>.<dl><a name="925114"> </a><h4> </h4><a name="925115"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>Both <code>SerSend</code> and <code>SerReceive</code> were enhanced in version 2.0 of the system. See the function descriptions for more information. The older versions are still available as <a href="SerialManager.html#925400">SerSend10</a> and <a href="SerialManager.html#925247">SerReceive10</a>.<hr><br></blockquote><dl><a name="925122"> </a><p></p><dt>To wait until all data queued up for transmission has been transmitted, call <code>SerSendWait</code>. <code>SerSendWait</code> blocks until all pending data is transmitted or a CTS timeout error occurs (if CTS handshaking is enabled).<a name="925127"> </a><p></p><dt>To flush all bytes from the transmission queue, call <a href="SerialManager.html#925437">SerSendFlush</a>. This routine discards any data not yet transferred to the UART for transmission.<a name="925128"> </a><p></p><dt>To receive a stream of bytes from the serial port, call <code>SerReceive</code>, specifying a buffer, the number of bytes desired, and the interbyte time out. This call blocks until all the requested data have been received or an error occurs. <a name="925133"> </a><p></p><dt>To read bytes already in the receive queue, call <a href="SerialManager.html#925281">SerReceiveCheck</a><code> </code>(see below) to get the number of bytes presently in the receive queue and then call <code>SerReceive</code>, specifying the number of bytes desired. Because <code>SerReceive</code> returns immediately without any data if line errors are pending, it is important to acknowledge the detection of line errors by calling <code>SerClearErr</code>.<a name="925134"> </a><p></p><dt>To wait for a specific number of bytes to be queued up in the receive queue, call <a href="SerialManager.html#925328">SerReceiveWait</a>, passing the desired number of bytes and an interbyte timeout. This call blocks until the desired number of bytes have accumulated in the receive queue or an error occurs. The desired number of bytes must be less than the current receive queue size. The default queue size is 512 bytes. Because this call returns immediately if line errors are pending, applications have to call <code>SerClearErr</code> to detect any line errors. See also <a href="SerialManager.html#925281">SerReceiveCheck</a> and <a href="SerialManager.html#925485">SerSetReceiveBuffer</a>.<a name="925145"> </a><p></p><dt>To check how many bytes are presently in the receive queue, call <code>SerReceiveCheck</code>.<a name="925146"> </a><p></p><dt>To discard all data presently in the receive queue and to flush bytes coming into the serial port, call <a href="SerialManager.html#925312">SerReceiveFlush</a>, specifying the interbyte timeout. This call blocks until a time out occurs waiting for the next byte to arrive.<a name="925155"> </a><p></p><dt>To replace the default receive queue, call <a href="SerialManager.html#925485">SerSetReceiveBuffer</a>, specifying the pointer to the buffer to be used for the receive queue and its size. The default receive queue must be restored before the serial port is closed. To restore the default receive queue, call <code>SerSetReceiveBuffer</code>, passing 0 (zero) for the buffer size. The serial manager does not free the custom receive queue.<a name="925157"> </a><p></p><dt>To avoid having the system go to sleep while it's waiting to receive data, an application should call <a href="SystemEventManager.html#925260">EvtResetAutoOffTimer</a> periodically. For example, the serial link manager automatically calls <code>EvtResetAutoOffTimer</code> each time a new packet is received. Note that this facility is not part of the serial manager but part of the event manager. For more information, see <a href="EventLoop.html#925314">"Auto-Off Control" </a>.<a name="925168"> </a><p></p><dt>To perform a control function, applications can call <a href="SerialManager.html#925082">SerControl</a>. This function performs one of the control operations specified by <code>SerCtlEnum</code>, whose elements are described in <a href="SerialCommunication.html#926679">Table 9.1</a>.<p><a name="925239"> </a> </p><p><div> <table border="3"><caption><B><a name="926679"> </a><h4>Table 9.1	 SerCtlEnum Elements&nbsp;</h4></B></caption><tr><th><a name="925177"> </a><strong>Element</strong></th><th><a name="925179"> </a><strong>Description</strong></th></tr><tr><td><a name="925182"> </a><code>serCtlFirstReserved</code> = 0</td><td><a name="925184"> </a>Reserve 0</td></tr><tr><td><a name="925187"> </a><code>serCtlStartBreak</code> </td><td><a name="925189"> </a>Turn RS232 break signal on. Applications have to make sure that the break is set long enough to generate a value BREAK! <a name="925190"> </a><code>valueP = 0; valueLenP = 0</code></td></tr><tr><td><a name="925193"> </a><code>serCtlStopBreak</code> </td><td><a name="925195"> </a>Turn RS232 break signal off: <a name="925196"> </a><code>valueP = 0; valueLenP = 0</code></td></tr><tr><td><a name="925199"> </a><code>serCtlBreakStatus</code> </td><td><a name="925201"> </a>Get RS232 break signal status (on or off):<a name="925202"> </a><code>valueP</code> = pointer to UInt16 for returning status<a name="925203"> </a>	 	 (0 = off, !0 = on)<p><a name="925204"> </a><code>*valueLenP = sizeof(UInt16)</code></p></td></tr><tr><td><a name="925207"> </a><code>serCtlStartLocalLoopback</code> </td><td><a name="925209"> </a>Start local loopback test;<a name="925210"> </a><code>valueP = 0, valueLenP = 0</code></td></tr><tr><td><a name="925213"> </a><code>serCtlStopLocalLoopback</code> </td><td><a name="925215"> </a>Stop local loopback test <a name="925216"> </a><code>valueP = 0, valueLenP = 0</code></td></tr><tr><td><a name="925219"> </a><code>serCtlMaxBaud</code> </td><td><a name="927343"> </a><code>valueP = </code>pointer to <code>UInt32</code> for returned baud <a name="925222"> </a><code>*valueLenP</code><code> = sizeof(UInt32)</code></td></tr><tr><td><a name="925225"> </a><code>serCtlHandshakeThreshold</code> </td><td><a name="925227"> </a>Retrieve HW handshake threshold; this is the maximum baud rate that does not require hardware handshaking<a name="925228"> </a><code>valueP</code> = pointer to UInt32 for returned baud <a name="925229"> </a><code>*valueLenP = sizeof(UInt32)</code></td></tr><tr><td><a name="925232"> </a><code>serCtlEmuSetBlockingHook</code> </td><td><a name="925234"> </a>Set a blocking hook routine.<a name="925235"> </a><blockquote><hr><em><strong>WARNING!</strong></em><p></p>For use with the Simulator on Mac OS only. NOT SUPPORTED ON THE PALM DEVICE. <hr><br></blockquote><a name="925236"> </a><code>valueP = </code>pointer to <code>SerCallbackEntryType </code><a name="925237"> </a><code>*valueLenP=sizeof(SerCallbackEntryType)</code><a name="925238"> </a>Returns the old settings in the first argument.</td></tr></table><table><tr><td></table></div></p></dl></dl></dl><a name="925247"> </a><h2> The New Serial Manager</h2><dl><a name="925249"> </a><p></p><dt>The new serial manager is capable of managing multiple serial connections within a Palm device.<a name="925250"> </a><p></p><dt>This section describes the new serial manager and the new capability to write serial drivers that it can use.<a name="925251"> </a><p></p><dt>The new serial manager is the preferred serial manager API and the Palm OS will eventually phase out support for the original serial manager API.<a name="925252"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>The new serial manager is not available on all Palm devices. It is available by flash ROM update on Palm III<sup>&#153;</sup> and upgraded PalmPilot<sup>&#153;</sup> devices and some later devices. Before making any new serial manager calls, you must ensure that it is present.<hr><br></blockquote></dl><a name="925254"> </a><h3> Checking for the New Serial Manager</h3><dl><a name="925255"> </a><p></p><dt>Because not all Palm devices will (or even can) have the new serial manager installed, it's important that you check for its existence before making any new serial manager calls. You can check by calling <code><a href="FeatureManager.html#924918"></code>FtrGet<code></a></code> as follows:<dl><a name="925259"> </a><br><code>err = FtrGet(sysFileCSerialMgr, sysFtrNewSerialPresent, &amp;value);</code><br><dl><a name="925260"> </a><p></p><dt>If the new serial manager is installed, the <code>value</code> parameter will be non-zero and the returned error should also be zero (for no error).<a name="925261"> </a><p></p><dt>If the new serial manager is installed, it replaces the original serial manager. However, it includes a compatibility layer so that applications that use the original serial manager functions will continue to operate as expected. The compatibility layer simply translates the original serial manager calls into equivalent new serial manager functions.<a name="925262"> </a><p></p><dt>If you are writing new application code, best performance is achieved by using the new serial library functions directly, assuming the new serial manager is installed on the unit on which your code is executing.</dl></dl></dl><a name="925263"> </a><h3> What's New About the New Serial Manager</h3><dl><a name="925264"> </a><p></p><dt>The main difference between the new serial manager and previous versions is that the new serial manager supports multiple physical serial hardware devices and virtual serial devices, the detailed operation of which is abstracted from the main serial management code. Physical serial drivers manage communication with the hardware as needed, and virtual drivers manage blocks of data to be sent to some sort of block-based serial code.<a name="925265"> </a><p></p><dt>In addition to this big change, a few new functions have been added and there are widespread, minor changes to data structures and API details.</dl><a name="925266"> </a><h3> About the New Serial Manager</h3><dl><a name="925267"> </a><p></p><dt>The new serial manager manages multiple serial devices with minimal duplication of hardware drivers and data structures. In older Palm systems, the serial library managed any and all connections to the serial hardware in the 68328 (Dragonball) processor, which was the only serial device in the system. Newer systems contain additional serial devices, such as an IR port.<a name="925268"> </a><p></p><dt>The figure below shows the layering of communication software with the new serial manager and hardware drivers.</dl><a name="925269"> </a><h4>Figure 9.2	 Serial Communications Architecture with New Serial Manager</h4><p><a name="925301"> </a><img src="images/SerialCommunication2.gif" height="338" width="605"></p><dl><a name="925302"> </a><p></p><dt>The new serial manager maintains a database of installed hardware and currently open connections. Applications, libraries, or other serial communication tasks open different pieces of serial hardware by specifying a logical port number or a four-character code identifying the exact piece of serial hardware that a task wishes to open a connection with. The new serial manager then performs the proper actions on the hardware via small hardware drivers that are opened dynamically when the port is needed. One hardware driver is needed for each serial communication hardware device available to the Palm unit.<a name="925303"> </a><p></p><dt>At system restart, the new serial manager searches for all serial drivers on the Palm device. Serial drivers are independent .prc files with a code resource and a version resource and are of type `sdrv' or `vdrv'. Once a driver is found, it is asked to locate its associated hardware and provide information on the capabilities of that hardware. This is done for each driver found and the new serial manager always maintains a list of hardware currently on the device.<a name="925304"> </a><p></p><dt>Once a port is opened, the new serial manager allocates a structure for maintaining the current information and settings of the particular port. The task or application that opens the port is returned a port ID and must supply the port ID to refer to this port when other new serial manager functions are called.<a name="925305"> </a><p></p><dt>Upon closing the port, the new serial manager deallocates the open port structure and unlocks the driver code resource to prevent memory fragmentation.<a name="925306"> </a><p></p><dt>Note that applications can use the connection manager to obtain the proper port ID and other serial port parameters that the user has stored in connection profiles for different connection types. For more information, see the section <a href="SerialCommunication.html#925592">"The Connection Manager" </a>.</dl><a name="925310"> </a><h3> Using the New Serial Manager</h3><dl><a name="925311"> </a><p></p><dt>The new serial manager is installed when the device is booted. Upon opening a new serial manager connection, the calling application receives a unique ID that must be used to refer to this specific connection for all subsequent calls to the new serial manager.</dl><a name="925312"> </a><h4> Opening a Connection</h4><dl><a name="925313"> </a><p></p><dt>Opening a serial connection requires that the application enable the serial hardware by calling the <code><a href="NewSerialManager.html#925513"></code>SrmOpen<code></a></code> function and specifying the port ID (logical number or port name) and the initial baud rate of the UART.<a name="925317"> </a><p></p><dt>The <code>SrmOpen</code> call returns a unique port ID for the open port. This port ID is required to perform any other new serial manager functions. If the returned port ID is <code>NULL</code> or an error is returned by the <code>SrmOpen</code> function, the returned port ID should be considered invalid. Once the <code>SrmOpen</code> call is made successfully, it indicates that the new serial manager has successfully allocated internal structures to maintain the port and has successfully loaded the serial driver for this port.<a name="925318"> </a><p></p><dt>A port may be opened with either a foreground connection (<code>SrmOpen</code>) or background connection (<code><a href="NewSerialManager.html#925558"></code>SrmOpenBackground<code></a></code>). A foreground connection makes an active connection to the port and controls usage of the port until the connection is closed. A background connection opens the port but relinquishes control to any other task requesting a foreground connection. Background connections are provided to support tasks (such as a keyboard driver) that want to use a serial device to receive data only when no other task is using the port.<a name="925322"> </a><p></p><dt>Note that background ports have limited functionality: they can only receive data and notify owning clients of what data has been received.</dl><a name="925324"> </a><h4> Specifying the portID Parameter</h4><dl><a name="925325"> </a><p></p><dt>With the new serial manager, ports must be specified using one of the following two methods:<ul type="SQUARE"><a name="925326"> </a><br><li>Logical port ID's (for physical ports only):<br><p><a name="925327"> </a> $8000 = Cradle Port, RS-232 serial</p><p><a name="925328"> </a> $8001 = IR Port</p><p><a name="925329"> </a> $800n = reserved for future types of ports</p><a name="925330"> </a><br><li>A four-character string specifying the port name:<br><p><a name="925331"> </a> `u328' specifies the cradle port using the 68328 UART</p><p><a name="925332"> </a> `u650' specifies the IR port on an upgraded Palm III device</p><p><a name="925333"> </a> `ircm' specifies the IRComm virtual port</p><p><a name="925334"> </a> Note that other four-character codes will be added in the future</p></ul><a name="925335"> </a><p></p><dt>Generally, it is best to use logical port ID's rather than specifying the port hardware directly. When you specify a logical port ID, the device selects the appropriate hardware.</dl><a name="925336"> </a><h4> Closing a Connection</h4><dl><a name="925337"> </a><p></p><dt>Once an application is finished with the serial port, it must close it using the <code><a href="NewSerialManager.html#925242"></code>SrmClose<code></a></code> function. If <code>SrmClose</code> returns no error, it indicates that the new serial manager has successfully closed the driver and deallocated the data structures used for maintaining the port.</dl><a name="925341"> </a><h4> Sending and Receiving Data</h4><dl><a name="925342"> </a><p></p><dt>Sending data is performed synchronously (for example, the process of writing bytes to the serial hardware's transmit FIFO). To send data, the application only needs to have an open connection with a port that has been configured properly and then specify a buffer to send. The larger the buffer to send, the longer the send function operates before returning to the calling application. The <code><a href="NewSerialManager.html#925893"></code>SrmSend<code></a></code> function returns the actual number of bytes that were sent.<a name="925349"> </a><p></p><dt>The <code><a href="NewSerialManager.html#925940"></code>SrmSendCheck<code></a></code> function can be used to check and determine if the FIFO is empty. The <code><a href="NewSerialManager.html#926019"></code>SrmSendWait<code></a></code> function can be used to wait for the UART to send the contents of its FIFO. The <code><a href="NewSerialManager.html#925983"></code>SrmSendFlush<code></a></code> function can be used to flush remaining bytes in the FIFO that have not been sent.<a name="925356"> </a><p></p><dt>Receiving data is a more involved process because it depends on the receiving application actually listening for data from the port. The <code><a href="NewSerialManager.html#925767"></code>SrmReceiveWait<code></a></code> function allows the application to periodically check the serial port to see if data has been received. In this function, you specify a number of bytes to wait for and a timeout value (in ticks). When <code>SrmReceiveWait</code> returns, you can call <code><a href="NewSerialManager.html#925644"></code>SrmReceive<code></a></code> to receive the data.<a name="925363"> </a><p></p><dt>Applications should not loop indefinitely on the <code><a href="NewSerialManager.html#925691"></code>SrmReceiveCheck<code></a></code> and <code>SrmReceiveWait</code> functions, waiting for serial data to arrive on the port, without allowing the Palm OS to obtain time to execute other tasks running in the same thread (by calling <code>EvtGetEvent</code> and <code>SysHandleEvent</code>). Virtual devices often run in the same thread as applications and this can prevent virtual devices and other serial related code from properly handling received data.</dl><a name="925367"> </a><h4> Receive Buffer Handling</h4><dl><a name="925368"> </a><p></p><dt>Functions are provided to support directly changing or accessing the new serial manager's receive queue. This allows substitution of a larger receive buffer to replace the 512-byte default buffer and allows fast access to this buffer to reduce buffer copying. These functions include <code><a href="NewSerialManager.html#926059"></code>SrmSetReceiveBuffer<code></a></code>, <code><a href="NewSerialManager.html#925850"></code>SrmReceiveWindowOpen<code></a></code>, and <code><a href="NewSerialManager.html#925817"></code>SrmReceiveWindowClose<code></a></code>.</dl><a name="925378"> </a><h4> Receive Data Notification</h4><dl><a name="925385"> </a><p></p><dt>The <code><a href="NewSerialManager.html#926092"></code>SrmSetWakeupHandler<code></a></code> and <code><a href="NewSerialManager.html#925605"></code>SrmPrimeWakeupHandler<code></a></code> functions are used to install a notification function (<code><a href="NewSerialManager.html#926137"></code>WakeupHandlerProc<code></a></code>) that gets called after some number of bytes are received by the new serial manager's interrupt function.<a name="925389"> </a><p></p><dt>Because wakeup handlers are called during interrupt time, they cannot call any Palm OS system functions that may block the system in any way. Wakeup handlers should also be very short so as to reduce interrupt latency.</dl><a name="925390"> </a><h4> Obtaining Information about Serial Hardware</h4><dl><a name="925397"> </a><p></p><dt>The <code><a href="NewSerialManager.html#925421"></code>SrmGetDeviceCount<code></a></code> and <code><a href="NewSerialManager.html#925447"></code>SrmGetDeviceInfo<code></a></code> functions can be used by applications to obtain information about all serial devices currently available to the OS. Applications can obtain the number of available serial hardware devices and then get information for those devices by iterating through the list using the <code>SrmGetDeviceInfo</code> call, until an error is returned.<a name="925401"> </a><p></p><dt>The <code><a href="NewSerialManager.html#925481"></code>SrmGetStatus<code></a></code> function can be used to get status information about the current hardware and return line errors. Typically, <code>SrmGetStatus</code> is called to retrieve the line errors for the port if some of the send and receive functions return a <code>serErrLineErr</code> error code. <code><a href="NewSerialManager.html#925221"></code>SrmClearErr<code></a></code> clears line errors.</dl><a name="925405"> </a><h4> Handling Custom Operations</h4><dl><a name="925406"> </a><p></p><dt>The new serial manager handles custom operations via the <code><a href="NewSerialManager.html#925280"></code>SrmControl<code></a></code> function. To extend this functionality to the serial drivers, an additional set of control functions has been added (see the <code><a href="SerialDriver.html#925554"></code>SdrvControl<code></a></code> and <code><a href="SerialDriver.html#925835"></code>VdrvControl<code></a></code> functions). These are unique to the serial driver and should be called only by the new serial manager itself. This allows functions that access the hardware directly to go through the same switching mechanism in the driver for both public and private control function operation codes.</dl><a name="925416"> </a><h3> New Serial Manager Example</h3><dl><a name="925420"> </a><p></p><dt>The example code in this section shows how to receive (<a href="SerialCommunication.html#925422">Listing 9.1</a>) large blocks of data using the new serial manager.</dl><a name="925422"> </a><h4>Listing 9.1	 Receiving Data Using the New Serial Manager</h4><a name="925423"> </a><hr><code>#include &lt;Pilot.h&gt; // all the system toolbox headers</code><br><a name="925424"> </a><code>#include &lt;SerialMgr.h&gt;</code><br><a name="925425"> </a><code>#define k2KBytes 2048</code><br><a name="925426"> </a><code>/************************************************************</code><br><a name="925427"> </a><code>*</code><br><a name="925428"> </a><code>* FUNCTION: RcvSerialData</code><br><a name="925429"> </a><code>*</code><br><a name="925430"> </a><code>* DESCRIPTION: An example of how to receive a large chunk of data</code><br><a name="925431"> </a><code>* from the Serial Manager. This function is useful if the app</code><br><a name="925432"> </a><code>* knows it must receive all this data before moving on. The</code><br><a name="925433"> </a><code>* YourDrainEventQueue() function is a chance for the application</code><br><a name="925434"> </a><code>* to call EvtGetEvent and handle other application events.</code><br><a name="925435"> </a><code>* Receiving data whenever it's available during idle events</code><br><a name="925436"> </a><code>* might be done differently than this sample.</code><br><a name="925437"> </a><code>*</code><br><a name="925438"> </a><code>* PARAMETERS: </code><br><a name="925439"> </a><code>* thePort -&gt; valid portID for an open serial port.</code><br><a name="925440"> </a><code>* rcvDataP -&gt; pointer to a buffer to put the received data.</code><br><a name="925441"> </a><code>* bufSize &lt;-&gt; pointer to the size of rcvBuffer and returns</code><br><a name="925442"> </a><code>*   the number of bytes read.</code><br><a name="925443"> </a><code>*</code><br><a name="925444"> </a><code> *************************************************************/</code><br><a name="925445"> </a><code>Err RcvSerialData(UInt16&nbsp;thePort, UInt8&nbsp;*rcvDataP, UInt32&nbsp;*bufSizeP)</code><br><a name="925446"> </a><code>{</code><br><a name="925447"> </a><code>UInt32 bytesLeft, maxRcvBlkSize, bytesRcvd, waitTime, totalRcvBytes = 0;</code><br><a name="925448"> </a><code>UInt8 *newRcvBuffer;</code><br><a name="925449"> </a><code>UInt16 dataLen = sizeof(UInt32);</code><br><a name="925450"> </a><code>Err* error;</code><br><a name="925451"> </a><code></code><br><a name="925452"> </a><code>&nbsp&nbsp&nbsp // The default receive buffer is only 512 bytes; increase it if </code><br><a name="925453"> </a><code>&nbsp&nbsp&nbsp // necessary. The following lines are just an example of how to </code><br><a name="925454"> </a><code>&nbsp&nbsp&nbsp // do it, but its necessity depends on the ability of the code</code><br><a name="925455"> </a><code>&nbsp&nbsp&nbsp // to retrieve data in a timely manner.</code><br><a name="925456"> </a><code>&nbsp&nbsp&nbsp newRcvBuffer = MemPtrNew(k2KBytes); // Allocate new rcv buffer.</code><br><a name="925457"> </a><code>&nbsp&nbsp&nbsp if (newRcvBuffer)</code><br><a name="925458"> </a><code>&nbsp&nbsp&nbsp 	 // Set new rcv buffer.</code><br><a name="925459"> </a><code>&nbsp&nbsp&nbsp 	 error = SrmSetReceiveBuffer(thePort, newRcvBuffer, k2KBytes);</code><br><a name="925460"> </a><code>&nbsp&nbsp&nbsp 	 if (error)</code><br><a name="925461"> </a><code>&nbsp&nbsp&nbsp 	 	 goto Exit;</code><br><a name="925462"> </a><code>&nbsp&nbsp&nbsp else</code><br><a name="925463"> </a><code>&nbsp&nbsp&nbsp 	 return memErrNotEnoughSpace;</code><br><a name="925464"> </a><code></code><br><a name="925465"> </a><code>&nbsp&nbsp&nbsp // Initialize the maximum bytes to receive at one time.</code><br><a name="925466"> </a><code>&nbsp&nbsp&nbsp maxRcvBlkSize = k2KBytes;</code><br><a name="925467"> </a><code>&nbsp&nbsp&nbsp // Remember how many bytes are left to receive.</code><br><a name="925468"> </a><code>&nbsp&nbsp&nbsp bytesLeft = *bufSizeP;</code><br><a name="925469"> </a><code>&nbsp&nbsp&nbsp // Only wait 1/5 of a second for bytes to arrive.</code><br><a name="925470"> </a><code>&nbsp&nbsp&nbsp waitTime = SysTicksPerSecond() / 5;</code><br><a name="925471"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925472"> </a><code>&nbsp&nbsp&nbsp // Now loop while getting blocks of data and filling the buffer.</code><br><a name="925473"> </a><code>&nbsp&nbsp&nbsp do {</code><br><a name="925474"> </a><code>&nbsp&nbsp&nbsp 	 // Is the max size larger then the number of bytes left?</code><br><a name="925475"> </a><code>&nbsp&nbsp&nbsp 	 if (bytesLeft &lt; maxRcvBlkSize)</code><br><a name="925476"> </a><code>&nbsp&nbsp&nbsp 	 	 // Yes, so change the rcv block amount.</code><br><a name="925477"> </a><code>&nbsp&nbsp&nbsp 	 	 maxRcvBlkSize = bytesLeft; </code><br><a name="925478"> </a><code>&nbsp&nbsp&nbsp 	 // Try to receive as much data as possible, </code><br><a name="925479"> </a><code>&nbsp&nbsp&nbsp 	 // but wait only one second for it.</code><br><a name="925480"> </a><code>&nbsp&nbsp&nbsp 	 bytesRcvd = SrmReceive(thePort,  rcvDataP, maxRcvBlkSize, waitTime, &amp;error);</code><br><a name="925481"> </a><code>&nbsp&nbsp&nbsp 	 // Remember the total number of bytes received.</code><br><a name="925482"> </a><code>&nbsp&nbsp&nbsp 	 totalRcvBytes += bytesRcvd;</code><br><a name="925483"> </a><code>&nbsp&nbsp&nbsp 	 // Figure how many bytes are left to receive.</code><br><a name="925484"> </a><code>&nbsp&nbsp&nbsp 	 bytesLeft -= bytesRcvd;</code><br><a name="925485"> </a><code>&nbsp&nbsp&nbsp 	 rcvDataP += bytesRcvd; // Advance the rcvDataP.</code><br><a name="925486"> </a><code>&nbsp&nbsp&nbsp 	 // If there was a timeout and no data came through...</code><br><a name="925487"> </a><code>&nbsp&nbsp&nbsp 	 if ((error == serErrTimeOut) &amp;&amp; (bytesRcvd == 0))</code><br><a name="925488"> </a><code>&nbsp&nbsp&nbsp 	 	 goto Exit; // ...bail out and report the error.</code><br><a name="925489"> </a><code>&nbsp&nbsp&nbsp 	 // If there's some other error, bail out.</code><br><a name="925490"> </a><code>&nbsp&nbsp&nbsp 	 if ((error) &amp;&amp; (error != serErrTimeOut))</code><br><a name="925491"> </a><code>&nbsp&nbsp&nbsp 	 	 goto Exit;</code><br><a name="925492"> </a><code></code><br><a name="925493"> </a><code>&nbsp&nbsp&nbsp 	 // Call a function to handle any pending events because</code><br><a name="925494"> </a><code>&nbsp&nbsp&nbsp 	 // someone might press the cancel button.</code><br><a name="925495"> </a><code>&nbsp&nbsp&nbsp 	 // YourDrainEventQueue();</code><br><a name="925496"> </a><code>&nbsp&nbsp&nbsp // Continue receiving data until all data has been received.</code><br><a name="925497"> </a><code>&nbsp&nbsp&nbsp } while (bytesLeft);</code><br><a name="925498"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925499"> </a><code>&nbsp&nbsp&nbsp // Clearing the receive buffer can also be done right before </code><br><a name="925500"> </a><code>&nbsp&nbsp&nbsp // the port is to be closed.</code><br><a name="925501"> </a><code>&nbsp&nbsp&nbsp // Set back the default buffer when we're done.</code><br><a name="925502"> </a><code>&nbsp&nbsp&nbsp SrmSetReceiveBuffer(thePort, 0L, 0);</code><br><a name="925503"> </a><code>&nbsp&nbsp&nbsp MemPtrFree(newRcvBuffer); // Free the space.</code><br><a name="925504"> </a><code></code><br><a name="925505"> </a><code>&nbsp&nbsp&nbsp Exit:</code><br><a name="925506"> </a><code>&nbsp&nbsp&nbsp 	 *bufSizeP = totalRcvBytes;</code><br><a name="925507"> </a><code>&nbsp&nbsp&nbsp 	 return error;</code><br><a name="925508"> </a><code>}</code><br><hr><br><a name="925510"> </a><h3> Writing a Serial or Virtual Device Driver</h3><dl><a name="925511"> </a><p></p><dt>The new serial manager supports the ability to add other serial hardware device drivers to the system. It also supports adding virtual device drivers, which transmit and receive data in blocks, instead of a byte at a time. The following sections discuss writing serial and virtual device drivers, which are installed as code resources on the Palm device.</dl><a name="925512"> </a><h4> Serial Driver (sdrv) Code Resources</h4><dl><a name="925513"> </a><p></p><dt>A serial driver (sdrv) is a code resource (ID = 0) that is independently compiled and installed on a Palm device. It provides a hardware abstraction layer (HAL) for the serial hardware (the UART). Serial driver .prc files are of file type `sdrv' and their creator type is chosen by the developer (and must be registered with Palm Computing) to denote the type of hardware (for example, the 68328 UART driver has creator `u328'). When the new serial manager is installed, it searches the database manager for code resources of the `sdrv' file type and then calls the driver's entry point function to determine if the hardware that the driver supports is present and, if so, to get information about the features and capabilities of the hardware.<a name="925514"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>Creator types with all lowercase letters are reserved by Palm Computing. For more information about assigning and registering creator types, see <a href="Design.html#925101">"Assigning a Creator ID" </a>.<hr><br></blockquote><a name="925518"> </a><p></p><dt>Serial drivers are responsible for installing and removing their interrupt handlers. In addition, they must be aware of other hardware that may share the IRQ line and be sure to pass along the interrupt to other installed handlers, if required. See the <code><a href="SerialDriver.html#925664"></code>SdrvOpen<code></a></code> function for details.</dl><a name="925522"> </a><h4> Serial Driver Functions</h4><dl><a name="925523"> </a><p></p><dt>There are eight functions that each serial driver must minimally support in order to work with the new serial manager. These functions are briefly described in this section. For details on the exact operations each function must perform, see the function descriptions in the <em>Palm OS SDK Reference</em>.<a name="925524"> </a><p></p><dt>The functions a serial driver must implement include:<ul type="SQUARE"><a name="925528"> </a><br><li><code><a href="SerialDriver.html#925490"></code>DrvEntryPoint<code></a></code> must be the first function defined in a serial driver code resource and must be marked as the <code>__Startup__</code> function of the code resource. When the code resource is loaded, the new serial manager jumps to the beginning of the code resource and begins execution at <code>DrvEntryPoint</code>. This function is called at system restart, when the new serial manager is building a database of installed drivers and their capabilities, and when a serial port is opened.<br><a name="925532"> </a><br><li>The <code><a href="SerialDriver.html#925664"></code>SdrvOpen<code></a></code> function is responsible for initializing the serial hardware to send and receive data, and installing an interrupt handler. <br><a name="925536"> </a><br><li>The <code><a href="SerialDriver.html#925531"></code>SdrvClose<code></a></code> function must handle all activities needed to power-down the UART and remove the interrupt handler.<br><a name="925540"> </a><br><li><code><a href="SerialDriver.html#925554"></code>SdrvControl<code></a></code> extends the <code>SrmControl</code> function to the level of the hardware. <br><a name="925544"> </a><br><li><code><a href="SerialDriver.html#925726"></code>SdrvStatus<code></a></code> returns a bitfield that describes the current state of the UART. <br><a name="925548"> </a><br><li><code><a href="SerialDriver.html#925747"></code>SdrvWriteChar<code></a></code> writes a byte to the appropriate UART register for transmission.<br><a name="925552"> </a><br><li><code><a href="SerialDriver.html#925706"></code>SdrvReadChar<code></a></code> reads a byte (if available) from the receive FIFO of the UART. It's best to implement the <code>SdrvrReadChar</code> function in assembly language.<br><a name="925556"> </a><br><li>The <code><a href="SerialDriver.html#925634"></code>SdrvISP<code></a></code> function is called when a hardware interrupt is generated on the IRQ line associated with the serial hardware. It determines if the interrupt is for this particular serial hardware. If so, it calls the <code>saveDataProc</code> function (passed to <code>SdrvOpen</code>), which handles reading the data from the UART by calling the <code>SdrvReadChar</code> function. It's best to implement the <code>SdrvISP</code> function in assembly language.<br></ul></dl><a name="925557"> </a><h4> Virtual Driver (vdrv) Code Resources</h4><dl><a name="925558"> </a><p></p><dt>A Virtual Driver is a code resource (ID=0) that is independently compiled and installed on a Palm device. Virtual driver .prc files are of file type `vdrv' and their creator type is chosen by the developer (and must be registered with Palm Computing). When the new serial manager is installed, it searches the database manager for code resources of the `vdrv' type and then calls the driver's entry point function to get information about the features and capabilities of this virtual device. Unlike serial device drivers, virtual device drivers send and receive data in blocks instead of transferring one byte at a time. Their purpose is to abstract a level of communication protocol away from serial devices without forcing applications to work through a different API than the serial manager that may already be used for normal RS-232 serial communication.</dl><a name="925559"> </a><h4> Virtual Driver Functions</h4><dl><a name="925560"> </a><p></p><dt>There are six functions that each virtual driver must minimally support in order to work with the new serial manager. These functions are briefly described in this section. For details on the exact operations each function must perform, see the function descriptions in the <em>Palm OS SDK Reference</em>.<a name="925561"> </a><p></p><dt>The functions a virtual driver must implement include:<ul type="SQUARE"><a name="925565"> </a><br><li><code><a href="SerialDriver.html#925490"></code>DrvEntryPoint<code></a></code> must be the first function defined in a virtual driver code resource and must be marked as the <code>__Startup__</code> function of the code resource. When the code resource is loaded, the new serial manager jumps to the beginning of the code resource and begins execution at <code>DrvEntryPoint</code>. This function is called at system restart, when the new serial manager is building a database of installed drivers and their capabilities, and when a virtual port is opened.<br><a name="925569"> </a><br><li>The <code><a href="SerialDriver.html#925926"></code>VdrvOpen<code></a></code> function is responsible for initializing the virtual device to begin communication. <br><a name="925573"> </a><br><li>The <code><a href="SerialDriver.html#925814"></code>VdrvClose<code></a></code> function must handle all activities needed to close the virtual device.<br><a name="925577"> </a><br><li><code><a href="SerialDriver.html#925835"></code>VdrvControl<code></a></code> extends the <code>SrmControl</code> function to the level of the virtual device.<br><a name="925581"> </a><br><li><code><a href="SerialDriver.html#925954"></code>VdrvStatus<code></a></code> returns a bitfield that describes the current state of the virtual device. <br><a name="925585"> </a><br><li><code><a href="SerialDriver.html#925975"></code>VdrvWrite<code></a></code> writes a block of bytes to the virtual device.<br></ul><a name="925586"> </a><p></p><dt>Note that there is no virtual read function in the current implementation. Virtual devices must save received data by using the functions provided in the <a href="SerialDriver.html#924992">DrvrRcvQType</a> when they are notified that data is available via some callback mechanism. <a name="925590"> </a><p></p><dt></dl><a name="925592"> </a><h2> The Connection Manager</h2><dl><a name="925594"> </a><p></p><dt>The connection manager allows other applications to access, add, and delete connection pro\xde les contained in the Connection preferences panel. The Connection panel replaces the original Modem panel on the Palm device. A connection profile includes information on the hardware port to be used for a particular connection and the port details (speed, flow control, modem initialization string, etc.).<a name="925595"> </a><p></p><dt>Because there are many more connection choices available to users (serial cable, IR, modem, network, etc.), the connection manager was developed to manage connection profiles that save preferences for various connection types.<a name="925596"> </a><p></p><dt>The connection manager provides functions that list the saved connection profiles (<code><a href="ConnectionMgr.html#925075"></code>CncGetProfileList<code></a></code>), return details for a specific profile (<code><a href="ConnectionMgr.html#925021"></code>CncGetProfileInfo<code></a></code>), add a profile (<code><a href="ConnectionMgr.html#924920"></code>CncAddProfile<code></a></code>), and delete a profile (<code><a href="ConnectionMgr.html#924978"></code>CncDeleteProfile<code></a></code>).<a name="925609"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>The connection manager is not available on all Palm devices. It is available by flash ROM update on Palm III and upgraded PalmPilot devices and some later devices. Before making any connection manager calls, you must ensure that it is present.<hr><br></blockquote><a name="925610"> </a><p></p><dt>Because not all Palm devices will (or even can) have the connection manager installed, it's important that you check for its existence before making any connection manager calls. You can check by checking for the existence of the new serial manager, as described in the section <a href="SerialCommunication.html#925254">"Checking for the New Serial Manager" </a>. These managers work together and so are always installed together.</dl><a name="925615"> </a><h2> The Serial Link Protocol</h2><dl><a name="925618"> </a><p></p><dt>The Serial Link Protocol (SLP) provides an efficient packet send and receive mechanism that is used by the Palm desktop software and debugger. SLP provides robust error detection with CRC-16. SLP is a best-effort protocol; it does not guarantee packet delivery (packet delivery is left to the higher-level protocols). For enhanced error detection and implementation convenience of higher-level protocols, SLP specifies packet type, source, destination, and transaction ID information as an integral part of its data packet structure.</dl><a name="925620"> </a><h3> SLP Packet Structures</h3><dl><a name="925621"> </a><p></p><dt>The following sections describe:<ul type="SQUARE"><a name="925625"> </a><br><li> <a href="SerialCommunication.html#925639">SLP Packet Format</a><br><a name="925629"> </a><br><li><a href="SerialCommunication.html#925660">Packet Type Assignment</a><br><a name="925633"> </a><br><li> <a href="SerialCommunication.html#925684">Socket ID Assignment</a><br><a name="925637"> </a><br><li> <a href="SerialCommunication.html#925717">Transaction ID Assignment</a><br></ul></dl><a name="925639"> </a><h4> SLP Packet Format</h4><dl><a name="925641"> </a><p></p><dt>Each SLP packet consists of a packet header, client data of variable size, and a packet footer, as shown in <a href="SerialCommunication.html#925647">Figure 9.3</a>.<p><a name="925645"> </a></p></dl><a name="925647"> </a><h4>Figure 9.3	 Structure of a Serial Link Packet</h4><p><a name="928180"> </a></p><p><a name="925652"> </a><img src="images/SerialCommunication3.gif" height="504" width="484"></p><ul type="SQUARE"><a name="925654"> </a><br><li>The <strong>packet header</strong> contains the packet signature, the destination socket ID, the source socket ID, packet type, client data size, transaction ID, and header checksum. The packet signature is composed of the three bytes 0xBE, 0xEF, 0xED, in that order. The header checksum is an 8-bit arithmetic checksum of the entire packet header, not including the checksum field itself.<br><a name="925655"> </a><br><li>The <strong>client data </strong>is a variable-size block of binary data specified by the user and is not interpreted by the Serial Link Protocol.<br><a name="925658"> </a><br><li>The <strong>packet footer</strong> consists of the CRC-16 value computed over the packet header and client data.<br></ul><a name="925660"> </a><h4> Packet Type Assignment</h4><dl><a name="925661"> </a><p></p><dt>Packet type values in the range of 0x00 through 0x7F are reserved for use by the system software. The following packet type assignments are currently implemented:<p><a name="925682"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925664"> </a>0x00</td><td><a name="925670"> </a>Remote Debugger, Remote Console, and System Remote Procedure Call packets.</td></tr><tr><td><a name="925673"> </a>0x02</td><td><a name="925676"> </a>PADP packets.</td></tr><tr><td><a name="925678"> </a>0x03</td><td><a name="925681"> </a>Loop-back test packets.</td></tr></table><table><tr><td></table></div></p></dl><a name="925684"> </a><h4> Socket ID Assignment</h4><dl><a name="925685"> </a><p></p><dt>Socket IDs are divided into two categories: static and dynamic. The static socket IDs are "well-known" socket ID values that are reserved by the components of the system software. The dynamic socket IDs are assigned at runtime when requested by clients of SLP. Static socket ID values in the ranges 0x00 through 0x03 and 0xE0 through 0xFF are reserved for use by the system software. The following static socket IDs are currently implemented or reserved:<p><a name="925715"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925688"> </a>0x00</td><td><a name="925691"> </a>Remote Debugger socket.</td></tr><tr><td><a name="925693"> </a>0x01</td><td><a name="925696"> </a>Remote Console socket.</td></tr><tr><td><a name="925698"> </a>0x02</td><td><a name="925701"> </a>Remote UI socket.</td></tr><tr><td><a name="925703"> </a>0x03</td><td><a name="925706"> </a>Desktop Link Server socket.</td></tr><tr><td><a name="925708"> </a>0x04 -0xCF</td><td><a name="925710"> </a>Reserved for dynamic assignment.</td></tr><tr><td><a name="925712"> </a>0xD0 - 0xDF</td><td><a name="925714"> </a>Reserved for testing.</td></tr></table><table><tr><td></table></div></p></dl><a name="925717"> </a><h4> Transaction ID Assignment</h4><dl><a name="925718"> </a><p></p><dt>Transaction ID values are not interpreted by the Serial Link Protocol and are for the sole benefit of the higher-level protocols. The following transaction ID values are currently reserved:<p><a name="925732"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925721"> </a>0x00 and 0xFF </td><td><a name="925723"> </a>Reserved for use by the system software.</td></tr><tr><td><a name="925725"> </a>0x00</td><td><a name="925727"> </a>Reserved by the Palm OS implementation of SLP to request automatic transaction ID generation. </td></tr><tr><td><a name="925729"> </a>0xFF</td><td><a name="925731"> </a>Reserved for the connection manager's WakeUp packets.</td></tr></table><table><tr><td></table></div></p></dl><a name="925733"> </a><h3> Transmitting an SLP Packet</h3><dl><a name="925735"> </a><p></p><dt>This section provides an overview of the steps involved in transmitting an SLP packet. The next section describes the implementation. <a name="925736"> </a><p></p><dt>Transmission of an SLP packet consists of these steps:</dl>  <a name="925737"> </a><font face="">Fill in the packet header and compute its checksum.</font>  <a name="925738"> </a><font face="">Compute the CRC-16 of the packet header and client data.</font>  <a name="925739"> </a><font face="">Transmit the packet header, client data, and packet footer.</font>  <a name="925740"> </a><font face="">Return an error code to the client.</font><a name="925741"> </a><h3> Receiving an SLP Packet</h3><dl><a name="925743"> </a><p></p><dt>Receiving an SLP packet consists of these steps:</dl>  <a name="925744"> </a><font face="">Scan the serial input until the packet header signature is matched.</font>  <a name="925745"> </a><font face="">Read in the rest of the packet header and validate its checksum.</font>  <a name="925746"> </a><font face="">Read in the client data.</font>  <a name="925747"> </a><font face="">Read in the packet footer and validate the packet CRC.</font>  <a name="925748"> </a><font face="">Dispatch/return an error code and the packet (if successful) to the client.</font><a name="925750"> </a><h2> The Serial Link Manager</h2><dl><a name="925753"> </a><p></p><dt>The serial link manager is the Palm OS implementation of the Serial Link Protocol.<a name="925754"> </a><p></p><dt>Serial link manager provides the mechanisms for managing multiple client sockets, sending packets, and receiving packets both synchronously and asynchronously. It also provides support for the Remote Debugger and Remote Procedure Calls (RPC).</dl><a name="925758"> </a><h3> Using the Serial Link Manager</h3><dl><a name="925759"> </a><p></p><dt>Before an application can use the services of the serial link manager, the application must open the manager by calling <a href="SerialLinkManager.html#924975">SlkOpen</a>. Success is indicated by error codes of 0 (zero) or <code>slkErrAlreadyOpen</code>. The return value <code>slkErrAlreadyOpen</code> indicates that the serial link manager has already been opened (most likely by another task). Other error codes indicate failure.<a name="925769"> </a><p></p><dt>When you finish using the serial link manager, call <a href="SerialLinkManager.html#924913">SlkClose</a>. <code>SlkClose</code> may be called only if <a href="SerialLinkManager.html#924975">SlkOpen</a> returned 0 (zero) or <code>slkErrAlreadyOpen</code>. When the open count reaches zero, <code>SlkClose</code> frees resources allocated by <code>SlkOpen</code>.<a name="925775"> </a><p></p><dt>To use the serial link manager socket services, open a Serial Link socket by calling <a href="SerialLinkManager.html#924995">SlkOpenSocket</a>. Pass a reference number or port ID (for the new serial manager) of an opened and initialized communications library (see <code>SlkClose</code>), a pointer to a memory location for returning the socket ID, and a Boolean indicating whether the socket is static or dynamic. If a static socket is being opened, the memory location for the socket ID must contain the desired socket number. If opening a dynamic socket, the new socket ID is returned in the passed memory location. Sharing of sockets is not supported. Success is indicated by an error code of 0 (zero). For information about static and dynamic socket IDs, see <a href="SerialCommunication.html#925684">"Socket ID Assignment" </a>.<a name="925783"> </a><p></p><dt>When you have finished using a Serial Link socket, close it by calling <a href="SerialLinkManager.html#924929">SlkCloseSocket</a>. This releases system resources allocated for this socket by the serial link manager.<a name="925788"> </a><p></p><dt>To obtain the communications library reference number for a particular socket, call <code>SlkSocketRefNum</code>. The socket must already be open. To obtain the port ID for a socket, if you are using the new serial manager, call <a href="SerialLinkManager.html#925107">SlkSocketPortID</a>.<a name="925797"> </a><p></p><dt>To set the interbyte packet receive timeout for a particular socket, call <a href="SerialLinkManager.html#925141">SlkSocketSetTimeout</a>.<a name="925802"> </a><p></p><dt>To flush the receive stream for a particular socket, call <a href="SerialLinkManager.html#924960">SlkFlushSocket</a>, passing the socket number and the interbyte timeout.<a name="925807"> </a><p></p><dt>To register a socket listener for a particular socket, call <a href="SerialLinkManager.html#925076">SlkSetSocketListener</a>, passing the socket number of an open socket and a pointer to the <code>SlkSocketListenType</code> structure. Because the serial link manager does not make a copy of the <code>SlkSocketListenType</code> structure but instead saves the pointer passed to it, the structure may not be an automatic variable (that is, allocated on the stack). The <code>SlkSocketListenType</code> structure may be a global variable in an application or a locked chunk allocated from the dynamic heap. The <code>SlkSocketListenType</code> structure specifies pointers to the socket listener procedure and the data buffers for dispatching packets destined for this socket. Pointers to two buffers must be specified: <ul type="SQUARE"><a name="925814"> </a><br><li>Packet header buffer (size of <code>SlkPktHeaderType</code>). <br><a name="925815"> </a><br><li>Packet body buffer, which must be large enough for the largest expected client data size.<br></ul><a name="925816"> </a><p></p><dt>Both buffers can be application global variables or locked chunks allocated from the dynamic heap. <a name="925817"> </a><p></p><dt>The socket listener procedure is called when a valid packet is received for the socket. Pointers to the packet header buffer and the packet body buffer are passed as parameters to the socket listener procedure. The serial link manager does not free the <code>SlkSocketListenType</code> structure or the buffers when the socket is closed; freeing them is the responsibility of the application. For this mechanism to function, some task needs to assume the responsibility to "drive" the serial link manager receiver by periodically calling <a href="SerialLinkManager.html#925022">SlkReceivePacket</a>.<a name="925826"> </a><p></p><dt>To send a packet, call <a href="SerialLinkManager.html#925056">SlkSendPacket</a>, passing a pointer to the packet header (<code>SlkPktHeaderType</code>) and a pointer to an array of <code>SlkWriteDataType</code> structures. <a href="SerialLinkManager.html#925056">SlkSendPacket</a> stuffs the signature, client data size, and the checksum fields of the packet header. The caller must fill in all other packet header fields. If the transaction ID field is set to 0 (zero), the serial link manager automatically generates and stuffs a new non-zero transaction ID. The array of <code>SlkWriteDataType</code> structures enables the caller to specify the client data part of the packet as a list of noncontiguous blocks. The end of list is indicated by an array element with the <code>size</code> field set to 0 (zero). Listing 3.1 incorporates the processes described in this section.<a name="925832"> </a><p></p><dt></dl><a name="925833"> </a><h4>Listing 9.2	 Sending a Serial Link Packet</h4><a name="925834"> </a><hr><code>Err	 	 	 	 	 	 	 	 	 err;</code><br><a name="925835"> </a><code>SlkPktHeaderType	 	 	 	 	 	 	 	 	 sendHdr;	 </code><br><a name="925836"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 	 	 	 //serial link packet header</code><br><a name="925837"> </a><code>SlkWriteDataType	 	 	 	 	 	 	 	 	 writeList[2];</code><br><a name="925838"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 	 	 	 //serial link write data segments</code><br><a name="925839"> </a><code>UInt8	 	 	 	 	 	 body[20];	 	 	 	 	 	 	 </code><br><a name="925840"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 	 	 	 //packet body(example packet body)</code><br><a name="925841"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925842"> </a><code>&nbsp&nbsp&nbsp 	 // Initialize packet body</code><br><a name="925843"> </a><code>&nbsp&nbsp&nbsp 	 ...</code><br><a name="925844"> </a><code></code><br><a name="925845"> </a><code>// Compose the packet header</code><br><a name="925846"> </a><code>sendHdr.dest = slkSocketDLP;</code><br><a name="925847"> </a><code>sendHdr.src = slkSocketDLP;</code><br><a name="925848"> </a><code>sendHdr.type = slkPktTypeSystem;</code><br><a name="925849"> </a><code>sendHdr.transId = 0;	 	 	 	 	 	 	 	 	 	 	 	 	 </code><br><a name="925850"> </a><code>&nbsp&nbsp&nbsp 	 	 	 // let Serial Link Manager set the transId</code><br><a name="925851"> </a><code>// Specify packet body	 </code><br><a name="925852"> </a><code>writeList[0].size = sizeof(body);	 	 	 	 	 	 	 	 	 	 	 	 	 </code><br><a name="925853"> </a><code>&nbsp&nbsp&nbsp 	 	 	 // first data block size</code><br><a name="925854"> </a><code>writeList[0].dataP = body;	 	 	 	 	 	 	 	 	 	 	 	 	 </code><br><a name="925855"> </a><code>&nbsp&nbsp&nbsp 	 	 	 // first data block pointer</code><br><a name="925856"> </a><code>writeList[1].size = 0;	 	 	 	 	 	 	 	 	 	 	 </code><br><a name="925857"> </a><code>&nbsp&nbsp&nbsp 	 	 	 // no more data blocks</code><br><a name="925858"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925859"> </a><code>// Send the packet</code><br><a name="925860"> </a><code>err = SlkSendPacket( &amp;sendHdr, writeList );</code><br><a name="925861"> </a><code>&nbsp&nbsp&nbsp ...</code><br><a name="925862"> </a><code>}</code><br><hr><br><a name="925863"> </a><h4>Listing 9.3	 Generating a New Transaction ID</h4><a name="925864"> </a><hr><code>//</code><br><a name="925865"> </a><code>// Example: Generating a new transaction ID given the previous </code><br><a name="925866"> </a><code>// transaction ID. Can start with any seed value.</code><br><a name="925867"> </a><code>//</code><br><a name="925868"> </a><code></code><br><a name="925869"> </a><code>UInt8 NextTransactionID (UInt8 previousTransactionID)</code><br><a name="925870"> </a><code>{</code><br><a name="925871"> </a><code>&nbsp&nbsp&nbsp UInt8	  nextTransactionID;</code><br><a name="925872"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925873"> </a><code>&nbsp&nbsp&nbsp // Generate a new transaction id, avoid the </code><br><a name="925874"> </a><code>&nbsp&nbsp&nbsp // reserved values (0x00 and 0xFF)</code><br><a name="925875"> </a><code>&nbsp&nbsp&nbsp if ( previousTransactionID &gt;= (UInt8)0xFE )</code><br><a name="925876"> </a><code>&nbsp&nbsp&nbsp 	 nextTransactionID = 1;	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 // wrap around</code><br><a name="925877"> </a><code>&nbsp&nbsp&nbsp else</code><br><a name="925878"> </a><code>&nbsp&nbsp&nbsp 	 nextTransactionID = previousTransactionID + 1;	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 </code><br><a name="925879"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 // increment</code><br><a name="925880"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925881"> </a><code>&nbsp&nbsp&nbsp return nextTransactionID;</code><br><a name="925882"> </a><code>}</code><br><hr><br><dl><a name="925888"> </a><p></p><dt>To receive a packet, call <a href="SerialLinkManager.html#925022">SlkReceivePacket</a>. You may request a packet for the passed socket ID only, or for any open socket that does not have a socket listener. The parameters also specify buffers for the packet header and client data, and a timeout. The timeout indicates how long the receiver should wait for a packet to begin arriving before timing out. A timeout value of (-1) means "wait forever." If a packet is received for a socket with a registered socket listener, the packet is dispatched via its socket listener procedure.</dl><a name="925891"> </a><h2> Summary of Serial Communications</h2><p><a name="926096"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925894"> </a><strong>Serial Manager Functions</strong></th><th><a name="925896"> </a><strong>New Serial Manager Functions</strong></th></tr><tr><td colspan=1 rowspan=22><a name="925901"> </a><a href="SerialManager.html#925034">SerClearErr</a><br><a href="SerialManager.html#925054">SerClose</a><br><a href="SerialManager.html#925082">SerControl</a><br><a href="SerialManager.html#925115">SerGetSettings</a><br><a href="SerialManager.html#925146">SerGetStatus</a><br><a href="SerialManager.html#925179">SerOpen</a><br><a href="SerialManager.html#925216">SerReceive</a><br><a href="SerialManager.html#925281">SerReceiveCheck</a><br><a href="SerialManager.html#925312">SerReceiveFlush</a><br><a href="SerialManager.html#925328">SerReceiveWait</a><br><a href="SerialManager.html#925364">SerSend</a><br><a href="SerialManager.html#925437">SerSendFlush</a><br><a href="SerialManager.html#925457">SerSendWait</a><br><a href="SerialManager.html#925485">SerSetReceiveBuffer</a><br><a href="SerialManager.html#925503">SerSetSettings</a></td><td colspan=1 rowspan=22><a name="925948"> </a><a href="NewSerialManager.html#925221">SrmClearErr</a><br><a href="NewSerialManager.html#925242">SrmClose</a><br><a href="NewSerialManager.html#925280">SrmControl</a><br><a href="NewSerialManager.html#925421">SrmGetDeviceCount</a><br><a href="NewSerialManager.html#925447">SrmGetDeviceInfo</a><br><a href="NewSerialManager.html#925481">SrmGetStatus</a><br><a href="NewSerialManager.html#925513">SrmOpen</a><br><a href="NewSerialManager.html#925558">SrmOpenBackground</a><br><a href="NewSerialManager.html#925605">SrmPrimeWakeupHandler</a><br><a href="NewSerialManager.html#925644">SrmReceive</a><br><a href="NewSerialManager.html#925691">SrmReceiveCheck</a><br><a href="NewSerialManager.html#925728">SrmReceiveFlush</a><br><a href="NewSerialManager.html#925767">SrmReceiveWait</a><br><a href="NewSerialManager.html#925817">SrmReceiveWindowClose</a><br><a href="NewSerialManager.html#925850">SrmReceiveWindowOpen</a><br><a href="NewSerialManager.html#925893">SrmSend</a><br><a href="NewSerialManager.html#925940">SrmSendCheck</a><br><a href="NewSerialManager.html#925983">SrmSendFlush</a><br><a href="NewSerialManager.html#926019">SrmSendWait</a><br><a href="NewSerialManager.html#926059">SrmSetReceiveBuffer</a><br><a href="NewSerialManager.html#926092">SrmSetWakeupHandler</a><br><a href="NewSerialManager.html#926137">WakeupHandlerProc</a></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr></table><table><tr><td></table></div></p><p><a name="926193"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="926099"> </a><strong>Serial Driver Functions</strong></th><th><a name="926101"> </a><strong>Virtual Driver Functions</strong></th></tr><tr><td colspan=1 rowspan=10><a name="926106"> </a><a href="SerialDriver.html#925490">DrvEntryPoint</a><br><a href="SerialDriver.html#925531">SdrvClose</a><br><a href="SerialDriver.html#925554">SdrvControl</a><br><a href="SerialDriver.html#925634">SdrvISP</a><br><a href="SerialDriver.html#925664">SdrvOpen</a><br><a href="SerialDriver.html#925706">SdrvReadChar</a><br><a href="SerialDriver.html#925726">SdrvStatus</a><br><a href="SerialDriver.html#925747">SdrvWriteChar</a></td><td colspan=1 rowspan=10><a name="926132"> </a><a href="SerialDriver.html#925773">DrvEntryPoint</a><br><a href="SerialDriver.html#926004">GetSize</a><br><a href="SerialDriver.html#926022">GetSpace</a><br><a href="SerialDriver.html#925835">VdrvControl</a><br><a href="SerialDriver.html#925926">VdrvOpen</a><br><a href="SerialDriver.html#925954">VdrvStatus</a><br><a href="SerialDriver.html#925975">VdrvWrite</a><br><a href="SerialDriver.html#926040">WriteBlock</a><br><a href="SerialDriver.html#926068">WriteByte</a></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr></table><table><tr><td></table></div></p><p><a name="926284"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="926196"> </a><strong>Connection Manager Functions</strong></th><th><a name="926198"> </a><strong>Serial Link Manager Functions</strong></th></tr><tr><td colspan=1 rowspan=10><a name="926203"> </a><a href="ConnectionMgr.html#924920">CncAddProfile</a><br><a href="ConnectionMgr.html#924978">CncDeleteProfile</a><br><a href="ConnectionMgr.html#925021">CncGetProfileInfo</a><br><a href="ConnectionMgr.html#925075">CncGetProfileList</a></td><td colspan=1 rowspan=10><a name="926217"> </a><a href="SerialLinkManager.html#924913">SlkClose</a><br><a href="SerialLinkManager.html#924929">SlkCloseSocket</a><br><a href="SerialLinkManager.html#924960">SlkFlushSocket</a><br><a href="SerialLinkManager.html#924975">SlkOpen</a><br><a href="SerialLinkManager.html#924995">SlkOpenSocket</a><br><a href="SerialLinkManager.html#925022">SlkReceivePacket</a><br><a href="SerialLinkManager.html#925056">SlkSendPacket</a><br><a href="SerialLinkManager.html#925076">SlkSetSocketListener</a><br><a href="SerialLinkManager.html#925107">SlkSocketPortID</a><br><code></code><a href="SerialLinkManager.html#925141">SlkSocketSetTimeout</a></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr></table><table><tr><td></table></div></p><p><a name="926310"> </a> <strong></strong></p><hr><br><center><B>Palm OS Programmer's Companion</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="SystemFeatures.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="Beaming.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 78 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:44 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SerialCommunication.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:14 GMT -->
</html>