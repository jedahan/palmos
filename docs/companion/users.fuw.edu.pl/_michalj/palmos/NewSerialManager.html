<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/NewSerialManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
<head><title>New Serial Manager</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="NetworkUtils.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="ScriptPlugin.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924904"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>56 New Serial Manager</h1><dl><a name="924905"> </a><p></p><dt>This chapter provides reference material for the new serial manager API:<ul type="SQUARE"><a name="924909"> </a><br><li><a href="NewSerialManager.html#924928">New Serial Manager Data Structures</a><br><a name="924913"> </a><br><li><a href="NewSerialManager.html#925102">New Serial Manager Constants</a><br><a name="924917"> </a><br><li><a href="NewSerialManager.html#925218">New Serial Manager Functions</a><br><a name="924921"> </a><br><li><a href="NewSerialManager.html#926134">New Serial Manager Application-Defined Function</a><br></ul><a name="924923"> </a><p></p><dt>The header file <code>SerialMgr.h</code> declares the serial manager API. For more information on the new serial manager, see the chapter <a href="SerialCommunication.html#928031">"Serial Communication"</a> in the <em>Palm OS Programmer's Companion</em>. </dl><a name="924928"> </a><h2> New Serial Manager Data Structures</h2><a name="924930"> </a><h3> DeviceInfoType</h3><dl><a name="924932"> </a><p></p><dt>The <code>DeviceInfoType</code> structure defines information about a serial device. This structure is returned by the <code><a href="NewSerialManager.html#925447"></code>SrmGetDeviceInfo<code></a></code> function.</dl><a name="924936"> </a><hr><code>typedef struct DeviceInfoType {</code><br><a name="924937"> </a><code>UInt32&nbsp;serDevCreator; </code><br><a name="924938"> </a><code>UInt32&nbsp;serDevFtrInfo; </code><br><a name="924939"> </a><code>UInt32&nbsp;serDevMaxBaudRate; </code><br><a name="924940"> </a><code>UInt32&nbsp;serDevHandshakeBaud; </code><br><a name="924941"> </a><code>Char&nbsp;*serDevPortInfoStr; </code><br><a name="924942"> </a><code>UInt8&nbsp;reserved[8]; // Reserved</code><br><a name="924943"> </a><code>} DeviceInfoType;</code><br><a name="924944"> </a><code>typedef DeviceInfoType *DeviceInfoPtr;</code><br><hr><br><a name="924945"> </a><h4> Value Descriptions</h4><p><a name="924970"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="924948"> </a><code>serDevCreator</code> </td><td><a name="924950"> </a>Four-character creator type for serial driver ('sdrv').</td></tr><tr><td><a name="924952"> </a><code>serDevFtrInfo</code> </td><td><a name="924954"> </a>Flags defining features of this serial hardware. Specify one of the flags described in <a href="NewSerialManager.html#925104">Serial Capabilities Constants</a>.</td></tr><tr><td><a name="924959"> </a><code>serDevMaxBaudRate</code> </td><td><a name="924961"> </a>Maximum baud rate for this device.</td></tr><tr><td><a name="924963"> </a><code>serDevHandshakeBaud</code> </td><td><a name="924965"> </a>Hardware handshaking is recommended for baud rates over this rate.</td></tr><tr><td><a name="924967"> </a><code>serDevPortInfoStr</code> </td><td><a name="924969"> </a>Description of serial hardware device or virtual device.</td></tr></table><table><tr><td></table></div></p><a name="924972"> </a><h3> SrmCtlEnum</h3><dl><a name="924974"> </a><p></p><dt>The <code>SrmCtlEnum</code> enumerated type specifies a serial control operation. Specify one of these enumerated types for the <code>op</code> parameter to the <code><a href="NewSerialManager.html#925280"></code>SrmControl<code></a></code> call.</dl><a name="924978"> </a><hr><code>typedef enum SrmCtlEnum {</code><br><a name="924979"> </a><code>srmCtlFirstReserved = 0, // RESERVE 0</code><br><a name="924980"> </a><code>srmCtlSetBaudRate, </code><br><a name="924981"> </a><code>srmCtlGetBaudRate, </code><br><a name="924982"> </a><code>srmCtlSetFlags, </code><br><a name="924983"> </a><code>srmCtlGetFlags, </code><br><a name="924984"> </a><code>srmCtlSetCtsTimeout, </code><br><a name="924985"> </a><code>srmCtlGetCtsTimeout, </code><br><a name="924986"> </a><code>srmCtlStartBreak, </code><br><a name="924987"> </a><code>srmCtlStopBreak, </code><br><a name="924988"> </a><code>srmCtlStartLocalLoopback, </code><br><a name="924989"> </a><code>srmCtlStopLocalLoopback, </code><br><a name="924990"> </a><code>srmCtlIrDAEnable, </code><br><a name="924991"> </a><code>srmCtlIrDADisable, </code><br><a name="924992"> </a><code>srmCtlRxEnable, </code><br><a name="924993"> </a><code>srmCtlRxDisable, </code><br><a name="924994"> </a><code>srmCtlEmuSetBlockingHook, </code><br><a name="924995"> </a><code>srmCtlUserDef, </code><br><a name="924996"> </a><code>srmCtlGetOptimalTransmitSize, </code><br><a name="924997"> </a><code>srmCtlLAST</code><br><a name="924998"> </a><code>} SrmCtlEnum;</code><br><hr><br><a name="924999"> </a><h4> Value Descriptions</h4><p><a name="925078"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925002"> </a><code>srmCtlSetBaudRate </code></td><td><a name="925004"> </a>Sets the current baud rate for the serial hardware.</td></tr><tr><td><a name="925006"> </a><code>srmCtlGetBaudRate </code></td><td><a name="925008"> </a>Gets the current baud rate for the serial hardware.</td></tr><tr><td><a name="925010"> </a><code>srmCtlSetFlags </code></td><td><a name="925012"> </a>Sets the current flag settings for the serial hardware. Specify flags from the set described in <a href="NewSerialManager.html#925130">Serial Settings Constants</a>.</td></tr><tr><td><a name="925017"> </a><code>srmCtlGetFlags </code></td><td><a name="925019"> </a>Gets the current flag settings for the serial hardware. </td></tr><tr><td><a name="925021"> </a><code>srmCtlSetCtsTimeout</code></td><td><a name="925023"> </a>Sets the current CTS timeout value for hardware handshaking.</td></tr><tr><td><a name="925025"> </a><code>srmCtlGetCtsTimeout</code></td><td><a name="925027"> </a>Gets the current CTS timeout value for hardware handshaking.</td></tr><tr><td><a name="925029"> </a><code>srmCtlStartBreak</code></td><td><a name="925031"> </a>Turn RS232 break signal on. Caller is responsible for turning this signal on and off and insuring it is on long enough to generate a viable break.</td></tr><tr><td><a name="925033"> </a><code>srmCtlStopBreak</code></td><td><a name="925035"> </a>Turn RS232 break signal off.</td></tr><tr><td><a name="925037"> </a><code>srmCtlStartLocalLoopback</code></td><td><a name="925039"> </a>Start local loopback test.</td></tr><tr><td><a name="925041"> </a><code>srmCtlStopLocalLoopback</code></td><td><a name="925043"> </a>Stop local loopback test.</td></tr><tr><td><a name="925045"> </a><code>srmCtlIrDAEnable</code></td><td><a name="925047"> </a>Enable IrDA connection on this serial port.</td></tr><tr><td><a name="925049"> </a><code>srmCtlIrDADisable</code></td><td><a name="925051"> </a>Disable IrDA connection on this serial port.</td></tr><tr><td><a name="925053"> </a><code>srmCtlRxEnable</code></td><td><a name="925055"> </a>Enable receiver (for IrDA).</td></tr><tr><td><a name="925057"> </a><code>srmCtlRxDisable</code></td><td><a name="925059"> </a>Disable receiver (for IrDA).</td></tr><tr><td><a name="925061"> </a><code>srmCtlEmuSetBlockingHook</code></td><td><a name="925063"> </a>Set a blocking hook routine for emulation mode only. Not supported on the Palm device.</td></tr><tr><td><a name="925065"> </a><code>srmCtlUserDef</code></td><td><a name="925067"> </a>This is a user-defined function that 3rd party hardware developers can use to set or retrieve hardware-specific information from the serial driver. This opCode invokes the <code><a href="SerialDriver.html#925554"></code>SdrvControl<code></a></code> (or <code><a href="SerialDriver.html#925835"></code>VdrvControl<code></a></code>) function with its user-defined opCode and the parameters are passed directly through to the serial driver. A serial driver that does not handle this function returns a <code>serErrBadParam</code> error.</td></tr><tr><td><a name="925075"> </a><code>srmCtlGetOptimalTransmitSize</code></td><td><a name="925077"> </a>Ask the port for the most efficient buffer size for transmitting data packets. This opCode returns an error (buffering not necessary), 0 (buffering requested, but application can choose buffer size), or a number &gt; 0 (recommended buffer size).</td></tr></table><table><tr><td></table></div></p><a name="925081"> </a><h3> SrmCallbackEntryType</h3><dl><a name="925082"> </a><p></p><dt>The <code>SrmCallbackEntryType</code> structure defines a callback function for the <code><a href="NewSerialManager.html#925280"></code>SrmControl<code></a></code> function's <code>srmCtlEmuSetBlockingHook</code> opCode.</dl><a name="925086"> </a><hr><code>typedef struct SrmCallbackEntryType {</code><br><a name="925087"> </a><code>BlockingHookProcPtr&nbsp;funcP;</code><br><a name="925088"> </a><code>UInt32&nbsp;userRef; // ref value to pass to callback</code><br><a name="925089"> </a><code>} SrmCallbackEntryType;</code><br><hr><br><a name="925090"> </a><h4> Value Descriptions</h4><p><a name="925100"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925093"> </a><code>funcP</code></td><td><a name="925095"> </a>Function pointer to the callback function. Pass <code>NULL</code> if you no longer want a callback function to be called.</td></tr><tr><td><a name="925097"> </a><code>userRef</code></td><td><a name="925099"> </a>User-defined reference value passed to the callback function.</td></tr></table><table><tr><td></table></div></p><a name="925102"> </a><h2> New Serial Manager Constants</h2><a name="925104"> </a><h3> Serial Capabilities Constants</h3><dl><a name="925106"> </a><p></p><dt>These constants describe serial hardware capabilities.<p><a name="925128"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925109"> </a><code>serDevCradlePort</code></td><td><a name="925111"> </a>Serial hardware controls RS-232 serial from cradle connector of Palm device.</td></tr><tr><td><a name="925113"> </a><code>serDevRS232Serial</code></td><td><a name="925115"> </a>Serial hardware has RS-232 line drivers</td></tr><tr><td><a name="925117"> </a><code>serDevIRDACapable</code></td><td><a name="925119"> </a>Serial hardware has IR line drivers and generates IrDA mode serial signals</td></tr><tr><td><a name="925121"> </a><code>serDevModemPort</code></td><td><a name="925123"> </a>Serial hardware drives modem connection</td></tr><tr><td><a name="925125"> </a><code>serDevCncMgrVisible</code></td><td><a name="925127"> </a>Serial device port name string is to be displayed in the Connection panel.</td></tr></table><table><tr><td></table></div></p></dl><a name="925130"> </a><h3> Serial Settings Constants</h3><dl><a name="925132"> </a><p></p><dt>These constants identify bit flags that correspond to various serial hardware settings.<p><a name="925191"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925135"> </a><code>srmSettingsFlagStopBitsM</code> </td><td><a name="925137"> </a>mask for stop bits field</td></tr><tr><td><a name="925139"> </a><code>srmSettingsFlagStopBits1</code> </td><td><a name="925141"> </a>1 stop bit</td></tr><tr><td><a name="925143"> </a><code>srmSettingsFlagStopBits2</code> </td><td><a name="925145"> </a>2 stop bits</td></tr><tr><td><a name="925147"> </a><code>srmSettingsFlagParityOnM</code> </td><td><a name="925149"> </a>mask for parity on</td></tr><tr><td><a name="925151"> </a><code>srmSettingsFlagParityEvenM</code> </td><td><a name="925153"> </a>mask for parity even</td></tr><tr><td><a name="925155"> </a><code>srmSettingsFlagXonXoffM</code> </td><td><a name="925157"> </a>mask for Xon/Xoff flow control (not implemented)</td></tr><tr><td><a name="925159"> </a><code>srmSettingsFlagRTSAutoM</code> </td><td><a name="925161"> </a>mask for RTS receive flow control</td></tr><tr><td><a name="925163"> </a><code>srmSettingsFlagCTSAutoM</code> </td><td><a name="925165"> </a>mask for CTS transmit flow control</td></tr><tr><td><a name="925167"> </a><code>srmSettingsFlagBitsPerCharM</code> </td><td><a name="925169"> </a>mask for bits per character</td></tr><tr><td><a name="925171"> </a><code>srmSettingsFlagBitsPerChar5</code> </td><td><a name="925173"> </a>5 bits per character</td></tr><tr><td><a name="925175"> </a><code>srmSettingsFlagBitsPerChar6</code> </td><td><a name="925177"> </a>6 bits per character</td></tr><tr><td><a name="925179"> </a><code>srmSettingsFlagBitsPerChar7</code> </td><td><a name="925181"> </a>7 bits per character</td></tr><tr><td><a name="925183"> </a><code>srmSettingsFlagBitsPerChar8</code> </td><td><a name="925185"> </a>8 bits per character</td></tr><tr><td><a name="925187"> </a><code>srmSettingsFlagFlowControl</code></td><td><a name="925189"> </a>Protect the receive buffer from software overruns. When this flag, and <code>srmSettingsFlagRTSAutoM</code> are set, it causes the new serial manager to assert RTS to prevent the transmitting device from continuing to send data when the receive buffer is full. Once the application receives data from the buffer, RTS is deasserted to allow data reception to resume.<a name="925190"> </a>Note that this feature effectively prevents software overrun line errors but may also cause CTS timeouts on the transmitting device if the RTS line is asserted longer than the defined CTS timeout value.</td></tr></table><table><tr><td></table></div></p></dl><a name="925193"> </a><h3> Status Constants</h3><dl><a name="925195"> </a><p></p><dt>These constants identify bit flags that correspond to the status of serial signals. They can be returned by the <code><a href="NewSerialManager.html#925481"></code>SrmGetStatus<code></a></code> function.<p><a name="925216"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925201"> </a><code>srmStatusCtsOn</code></td><td><a name="925203"> </a>CTS line is active.</td></tr><tr><td><a name="925205"> </a><code>srmStatusRtsOn</code></td><td><a name="925207"> </a>RTS line is active.</td></tr><tr><td><a name="925209"> </a><code>srmStatusDsrOn</code></td><td><a name="925211"> </a>DSR line is active.</td></tr><tr><td><a name="925213"> </a><code>srmStatusBreakSigOn</code></td><td><a name="925215"> </a>Break signal is active.</td></tr></table><table><tr><td></table></div></p></dl><a name="925218"> </a><h2> New Serial Manager Functions</h2><a name="925221"> </a><br> <br> <br><h3> SrmClearErr</h3><dl><dl><a name="925222"> </a><h4>Purpose </h4><dl><a name="925223"> </a><p></p><dt>Clears the port of any line errors.</dl><a name="925224"> </a><h4>Prototype </h4><dl><a name="925225"> </a><dt><code>Err SrmClearErr(UInt16&nbsp;portId)</code></dl></dl><dl><a name="925226"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925227"> </a><CODE>-&gt; <code>portID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE></dl><dl><a name="927446"> </a><h4>Result </h4><p><a name="927452"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="927449"> </a>0</td><td><a name="927451"> </a>No error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="927453"> </a><h4>Compatibility </h4><dl><a name="925239"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925242"> </a><br> <br> <br><h3> SrmClose</h3><dl><dl><a name="925243"> </a><h4>Purpose </h4><dl><a name="925244"> </a><p></p><dt>Closes a serial port and makes it available to other applications, regardless of whether the port is a foreground or background port. </dl><a name="925245"> </a><h4>Prototype </h4><dl><a name="925246"> </a><dt><code>Err SrmClose(UInt16&nbsp;portID)</code></dl></dl><dl><a name="925247"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925248"> </a><CODE>-&gt; <code>portID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID for port to be closed.<br></TD></TR></TABLE></dl><dl><a name="925249"> </a><h4>Result </h4><p><a name="925259"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925252"> </a>0</td><td><a name="925254"> </a>No error.</td></tr><tr><td><a name="925256"> </a><code>serErrBadPort</code></td><td><a name="925258"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925260"> </a><h4>Comments </h4><dl><a name="925261"> </a><p></p><dt>If a foreground port is being closed and a background port exists, the background will have access to the port as long as another foreground port is not opened (via <code><a href="NewSerialManager.html#925513"></code>SrmOpen<code></a></code>).</dl><a name="925265"> </a><h4>Compatibility </h4><dl><a name="925269"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925270"> </a><h4>See Also </h4><dl><a name="925277"> </a><p></p><dt><code><a href="NewSerialManager.html#925513"></code>SrmOpen<code></a></code>, <code><a href="NewSerialManager.html#925558"></code>SrmOpenBackground<code></a></code></dl></dl></dl><a name="925280"> </a><br> <br> <br><h3> SrmControl</h3><dl><dl><a name="925281"> </a><h4>Purpose </h4><dl><a name="925282"> </a><p></p><dt>Performs a serial control function.</dl><a name="925283"> </a><h4>Prototype </h4><dl><a name="925284"> </a><dt><code>Err SrmControl(UInt16&nbsp;portId, UInt16&nbsp;op, void&nbsp;*valueP, UInt16&nbsp;*valueLenP)</code></dl></dl><dl><a name="925285"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925286"> </a><CODE>-&gt; <code>portID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925287"> </a><CODE>-&gt; <code>op</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Control operation to perform. Specify one of the <code><a href="NewSerialManager.html#924972"></code>SrmCtlEnum<code></a></code> enumerated types.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925291"> </a><CODE>&lt;-&gt; <code>valueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a value to use for the operation. See Comments for details.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925292"> </a><CODE>&lt;-&gt; <code>valueLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the size of <code>*valueP</code>. See Comments for details.<br></TD></TR></TABLE></dl><dl><a name="925293"> </a><h4>Comments </h4><dl><a name="925297"> </a><p></p><dt><a href="NewSerialManager.html#926947">Table 56.1</a> shows what to pass for the <code>valueP</code> and <code>valueLenP</code> parameters for each of the operation codes. Control codes not listed do not use these parameters.<p><a name="925413"> </a> </p><p><div> <table border="3"><caption><B><a name="926947"> </a><h4>Table 56.1	 SrmControl Parameters&nbsp;</h4></B></caption><tr><th><a name="925302"> </a><strong>Operation Code</strong></th><th><a name="925304"> </a><strong>Parameters</strong></th></tr><tr><td colspan=1 rowspan=3><a name="925306"> </a><code>srmCtlSetBaudRate</code> </td><td colspan=1 rowspan=3><a name="925308"> </a>-&gt; <code>valueP</code> = Pointer to <code>Int32</code> (baud rate)<a name="925309"> </a>-&gt; <code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code></td></tr><tr></tr><tr></tr><tr><td colspan=1 rowspan=3><a name="925319"> </a><code>srmCtlGetBaud</code> </td><td colspan=1 rowspan=3><a name="925321"> </a>&lt;- <code>valueP</code> = Pointer to <code>Int32</code> (baud rate)<a name="925322"> </a>&lt;- <code>valueLenP</code> = Pointer to <code>Int16</code></td></tr><tr></tr><tr></tr><tr><td colspan=1 rowspan=3><a name="925332"> </a><code>srmCtlSetFlags</code> </td><td colspan=1 rowspan=3><a name="925334"> </a>-&gt; <code>valueP</code> = Pointer to <code>Uint32</code> (bitfield; see <a href="NewSerialManager.html#925130">Serial Settings Constants</a>)<a name="925338"> </a>-&gt; <code>valueLenP</code> = Pointer to <code>sizeof(UInt32)</code></td></tr><tr></tr><tr></tr><tr><td colspan=1 rowspan=3><a name="925348"> </a><code>srmCtlGetFlags</code> </td><td colspan=1 rowspan=3><a name="925350"> </a>&lt;- <code>valueP</code> = Pointer to <code>UInt32</code> (bitfield)<a name="925351"> </a>&lt;- <code>valueLenP</code> = Pointer to <code>Int16</code></td></tr><tr></tr><tr></tr><tr><td colspan=1 rowspan=3><a name="925361"> </a><code>srmCtlSetCtsTimeout</code> </td><td colspan=1 rowspan=3><a name="925363"> </a>-&gt; <code>valueP</code> = Pointer to <code>Int32</code> (timeout value)<a name="925364"> </a>-&gt; <code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code></td></tr><tr></tr><tr></tr><tr><td colspan=1 rowspan=3><a name="925374"> </a><code>srmCtlGetCtsTimeout</code> </td><td colspan=1 rowspan=3><a name="925376"> </a>&lt;- <code>valueP</code> = Pointer to <code>Int32</code> (timeout value)<a name="925377"> </a>&lt;- <code>valueLenP</code> = Pointer to <code>Int16</code></td></tr><tr></tr><tr></tr><tr><td><a name="925387"> </a><code>srmCtlEmuSetBlockingHook</code> </td><td><a name="925389"> </a>&lt;-&gt; <code>valueP</code> = Pointer to <code><a href="NewSerialManager.html#925081"></code>SrmCallbackEntryType<code></a></code> struct<a name="925393"> </a>&lt;-&gt; <code>valueLenP</code> = Pointer to <code>sizeof(SrmCallbackEntryType)</code><a name="925394"> </a>Returns the old settings in the first parameter.</td></tr><tr><td><a name="925396"> </a><code>srmCtlUserDef</code> </td><td><a name="925398"> </a>&lt;-&gt; <code>valueP</code> = Pointer passed to the serial or virtual driver<a name="925399"> </a>&lt;-&gt; <code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code><a name="925400"> </a>For a serial driver, these pointers are passed to the <code><a href="SerialDriver.html#925554"></code>SdrvControl<code></a></code> function's <code>sdrvOpCodeUserDef</code> opCode. For a virtual driver, these pointers are passed to the <code><a href="SerialDriver.html#925835"></code>VdrvControl<code></a></code> function's <code>vdrvOpCodeUserDef</code> opCode.</td></tr><tr><td><a name="925408"> </a><code>srmCtlGetOptimalTransmitSize</code> </td><td><a name="925410"> </a>&lt;- <code>valueP</code> = Pointer to Int32<a name="925411"> </a>&lt;- <code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code><a name="925412"> </a>If an error is returned by <code>SrmControl</code>, no buffering should be done. If <code>valueP</code> points to zero, buffering is requested, but the transmitting application can determine the buffer size. If <code>valueP</code> points to a number &gt; 0, then try to send data in blocks of this number of bytes, as this is the most efficient block size for this particular device.</td></tr></table><table><tr><td></table></div></p></dl><a name="925414"> </a><h4>Compatibility </h4><dl><a name="925418"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925421"> </a><br> <br> <br><h3> SrmGetDeviceCount</h3><dl><dl><a name="925422"> </a><h4>Purpose </h4><dl><a name="925423"> </a><p></p><dt>Returns the number of available serial devices.</dl><a name="925424"> </a><h4>Prototype </h4><dl><a name="925425"> </a><dt><code>Err SrmGetDeviceCount(UInt16*&nbsp;numOfDevicesP)</code></dl></dl><dl><a name="925426"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925427"> </a><CODE>&lt;- <code>numOfDevicesP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to address where the number of serial devices is returned.<br></TD></TR></TABLE></dl><dl><a name="925428"> </a><h4>Result </h4><p><a name="925434"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925431"> </a>0</td><td><a name="925433"> </a>No error.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925435"> </a><h4>Compatibility </h4><dl><a name="925439"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925440"> </a><h4>See Also </h4><dl><a name="925444"> </a><p></p><dt><code><a href="NewSerialManager.html#925447"></code>SrmGetDeviceInfo<code></a></code></dl></dl></dl><a name="925447"> </a><br> <br> <br><h3> SrmGetDeviceInfo</h3><dl><dl><a name="925448"> </a><h4>Purpose </h4><dl><a name="925449"> </a><p></p><dt>Returns information about a serial device.</dl><a name="925450"> </a><h4>Prototype </h4><dl><a name="925451"> </a><dt><code>Err SrmGetDeviceInfo(UInt32&nbsp;deviceID, DeviceInfoType*&nbsp;deviceInfoP)</code></dl></dl><dl><a name="925452"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925453"> </a><CODE>-&gt; <code>deviceID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>ID of serial device to get information for. You can pass a zero-based index (0, 1, 2, ...), a valid port ID returned from <code>SrmOpen</code>, or a 4-character port name (such as 'u328', 'u650', or 'ircm').<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925457"> </a><CODE>&lt;- <code>deviceInfoP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a <code><a href="NewSerialManager.html#924930"></code>DeviceInfoType<code></a></code> structure where information about the device is returned.<br></TD></TR></TABLE></dl><dl><a name="925458"> </a><h4>Result </h4><p><a name="925468"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925461"> </a>0</td><td><a name="925463"> </a>No error.</td></tr><tr><td><a name="925465"> </a><code>serErrBadPort</code></td><td><a name="925467"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925469"> </a><h4>Compatibility </h4><dl><a name="925473"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925474"> </a><h4>See Also </h4><dl><a name="925478"> </a><p></p><dt><code><a href="NewSerialManager.html#925421"></code>SrmGetDeviceCount<code></a></code></dl></dl></dl><a name="925481"> </a><br> <br> <br><h3> SrmGetStatus</h3><dl><dl><a name="925482"> </a><h4>Purpose </h4><dl><a name="925483"> </a><p></p><dt>Returns status information about the serial hardware.</dl><a name="925484"> </a><h4>Prototype </h4><dl><a name="925485"> </a><dt><code>Err SrmGetStatus(UInt16&nbsp;portId, UInt32*&nbsp;statusFieldP), UInt16*&nbsp;lineErrsP)</code></dl></dl><dl><a name="925486"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925487"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925488"> </a><CODE>&lt;- <code>statusFieldP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to address where hardware status information for the port is returned. This is a 32-bit field using the flags described in <a href="NewSerialManager.html#925193">Status Constants</a>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925492"> </a><CODE>&lt;- <code>lineErrsP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to address where the number of line errors for the port is returned.<br></TD></TR></TABLE></dl><dl><a name="925493"> </a><h4>Result </h4><p><a name="925503"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925496"> </a>0</td><td><a name="925498"> </a>No error.</td></tr><tr><td><a name="925500"> </a><code>serErrBadPort</code></td><td><a name="925502"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925504"> </a><h4>Comments </h4><dl><a name="925505"> </a><p></p><dt>Typically, <code>SrmGetStatus</code> is called to retrieve the line errors for the port if some of the send and receive functions return a <code>serErrLineErr</code> error code.</dl><a name="925506"> </a><h4>Compatibility </h4><dl><a name="925510"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="925513"> </a><br> <br> <br><h3> SrmOpen</h3><dl><dl><a name="925514"> </a><h4>Purpose </h4><dl><a name="925515"> </a><p></p><dt>Opens a foreground port connection with the specified port name or logical port number.</dl><a name="925516"> </a><h4>Prototype </h4><dl><a name="925517"> </a><dt><code>Err SrmOpen(UInt32&nbsp;port, UInt32&nbsp;baud, UInt16*&nbsp;newPortIdP)</code></dl></dl><dl><a name="925518"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925519"> </a><CODE>-&gt; <code>port</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port name or logical port number to be opened. For information about how to identify a port, see <a href="SerialCommunication.html#925324">"Specifying the portID Parameter" </a> in the <em>Palm OS Programmer's Companion</em>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925523"> </a><CODE>-&gt; <code>baud</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Initial baud rate of port.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925524"> </a><CODE>&lt;- <code>newPortIdP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to address where the port ID to be used with other new serial manager functions is returned.<br></TD></TR></TABLE></dl><dl><a name="925525"> </a><h4>Result </h4><p><a name="925543"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925528"> </a>0</td><td><a name="925530"> </a>No error.</td></tr><tr><td><a name="925532"> </a><code>serErrAlreadyOpen</code></td><td><a name="925534"> </a>This port already has an installed foreground owner.</td></tr><tr><td><a name="925536"> </a><code>serErrBadPort</code></td><td><a name="925538"> </a>This port doesn't exist.</td></tr><tr><td><a name="925540"> </a><code>memErrNotEnoughSpace</code></td><td><a name="925542"> </a>There was not enough memory available to open the port.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925544"> </a><h4>Comments </h4><dl><a name="925545"> </a><p></p><dt>Only one application or task may have access to a particular serial port at any time.</dl><a name="925546"> </a><h4>Compatibility </h4><dl><a name="925550"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925551"> </a><h4>See Also </h4><dl><a name="925555"> </a><p></p><dt><code><a href="NewSerialManager.html#925558"></code>SrmOpenBackground<code></a></code></dl></dl></dl><a name="925558"> </a><br> <br> <br><h3> SrmOpenBackground</h3><dl><dl><a name="925559"> </a><h4>Purpose </h4><dl><a name="925560"> </a><p></p><dt>Allows a task to open, initialize, and use the port, but always relinquishes control of the port when another task opens the port with the <code><a href="NewSerialManager.html#925513"></code>SrmOpen<code></a></code> call.</dl><a name="925564"> </a><h4>Prototype </h4><dl><a name="925565"> </a><dt><code>Err SrmOpenBackground(UInt32&nbsp;port, UInt32&nbsp;baud, UInt16*&nbsp;newPortIdP)</code></dl></dl><dl><a name="925566"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925567"> </a><CODE>-&gt; <code>port</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Physical or logical port number to be opened.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925568"> </a><CODE>-&gt; <code>baud</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Initial baud rate of port.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925569"> </a><CODE>&lt;- <code>newPortIdP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to address where the port ID to be used with other new serial manager functions is returned.<br></TD></TR></TABLE></dl><dl><a name="925570"> </a><h4>Result </h4><p><a name="925588"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925573"> </a>0</td><td><a name="925575"> </a>No error.</td></tr><tr><td><a name="925577"> </a><code>serErrAlreadyOpen</code></td><td><a name="925579"> </a>This port already has an installed background owner.</td></tr><tr><td><a name="925581"> </a><code>serErrBadPort</code></td><td><a name="925583"> </a>This port doesn't exist.</td></tr><tr><td><a name="925585"> </a><code>memErrNotEnoughSpace</code></td><td><a name="925587"> </a>There was not enough memory available to open the port.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925589"> </a><h4>Comments </h4><dl><a name="925590"> </a><p></p><dt>This function is provided to support tasks that want to use a serial device to receive data only when no other task is using the port.<a name="925591"> </a><p></p><dt>If a background port is forced to surrender control of the hardware as a result of another task opening a foreground connection, all buffers for the background port are flushed. After this active task closes the port, active control of the port is returned to the background task. Only one task can have background ownership of the port.<a name="925592"> </a><p></p><dt>Note that background ports have limited functionality: they can only receive data and notify owning clients of what data has been received.</dl><a name="925593"> </a><h4>Compatibility </h4><dl><a name="925597"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925598"> </a><h4>See Also </h4><dl><a name="925602"> </a><p></p><dt><code><a href="NewSerialManager.html#925513"></code>SrmOpen<code></a></code></dl></dl></dl><a name="925605"> </a><br> <br> <br><h3> SrmPrimeWakeupHandler</h3><dl><dl><a name="925606"> </a><h4>Purpose </h4><dl><a name="925607"> </a><p></p><dt>Sets the number of received bytes that triggers a call to the wakeup handler function.</dl><a name="925608"> </a><h4>Prototype </h4><dl><a name="925609"> </a><dt><code>Err SrmPrimeWakeupHandler(UInt16&nbsp;portId, UInt16&nbsp;minBytes)</code></dl></dl><dl><a name="925610"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925611"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925612"> </a><CODE>-&gt; <code>minBytes</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes that must be received before wakeup handler is called. Typically, this is set to 1.<br></TD></TR></TABLE></dl><dl><a name="925613"> </a><h4>Result </h4><p><a name="925623"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925616"> </a>0</td><td><a name="925618"> </a>No error.</td></tr><tr><td><a name="925620"> </a><code>serErrBadPort</code></td><td><a name="925622"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925624"> </a><h4>Comments </h4><dl><a name="925625"> </a><p></p><dt>This function primes a wakeup handler installed by <code><a href="NewSerialManager.html#926092"></code>SrmSetWakeupHandler<code></a></code>.</dl><a name="925629"> </a><h4>Compatibility </h4><dl><a name="925633"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925634"> </a><h4>See Also </h4><dl><a name="925641"> </a><p></p><dt><code><a href="NewSerialManager.html#926092"></code>SrmSetWakeupHandler<code></a></code>, <code><a href="NewSerialManager.html#926137"></code>WakeupHandlerProc<code></a></code></dl></dl></dl><a name="925644"> </a><br> <br> <br><h3> SrmReceive</h3><dl><dl><a name="925645"> </a><h4>Purpose </h4><dl><a name="925646"> </a><p></p><dt>Receives a specified number of bytes.</dl><a name="925647"> </a><h4>Prototype </h4><dl><a name="925648"> </a><dt><code>UInt32 SrmReceive(UInt16&nbsp;portId, void&nbsp;*rcvBufP, UInt32&nbsp;count, Int32&nbsp;timeout, Err* errP)</code></dl></dl><dl><a name="925649"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925650"> </a><CODE>-&gt; <code>PortId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925651"> </a><CODE>&lt;- <code>rcvBufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to buffer where received data is to be returned.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925652"> </a><CODE>-&gt; <code>count</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length of data buffer (in bytes). This specifies the number of bytes to receive.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925653"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The amount of time (in ticks) that the new serial manager waits to receive the requested block of data. At the end of the timeout, data received up to that time is returned.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925654"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Error code.<br></TD></TR></TABLE></dl><dl><a name="925655"> </a><h4>Result </h4><dl><a name="925656"> </a><p></p><dt>Number of bytes of data actually received.</dl></dl><dl><a name="925657"> </a><h4>Comments </h4><dl><a name="925658"> </a><p></p><dt>The following error codes can be returned in <code>*errP</code>:<p><a name="925672"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925661"> </a>0</td><td><a name="925663"> </a>No error.</td></tr><tr><td><a name="925665"> </a><code>serErrBadPort</code></td><td><a name="925667"> </a>This port doesn't exist.</td></tr><tr><td><a name="925669"> </a><code>serErrTimeoutErr</code></td><td><a name="925671"> </a>Unable to receive data within the specified <code>ctsTimeout</code> period.</td></tr></table><table><tr><td></table></div></p></dl><a name="925673"> </a><h4>Compatibility </h4><dl><a name="925677"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925678"> </a><h4>See Also </h4><dl><a name="925688"> </a><p></p><dt><code><a href="NewSerialManager.html#925691"></code>SrmReceiveCheck<code></a></code>, <code><a href="NewSerialManager.html#925728"></code>SrmReceiveFlush<code></a></code>, <code><a href="NewSerialManager.html#925767"></code>SrmReceiveWait<code></a></code></dl></dl></dl><a name="925691"> </a><br> <br> <br><h3> SrmReceiveCheck</h3><dl><dl><a name="925692"> </a><h4>Purpose </h4><dl><a name="925693"> </a><p></p><dt>Checks the receive FIFO and returns the number of bytes in the serial receive queue.</dl><a name="925694"> </a><h4>Prototype </h4><dl><a name="925695"> </a><dt><code>Err SrmReceiveCheck(UInt16&nbsp;portId, UInt32*&nbsp;numBytesP)</code></dl></dl><dl><a name="925696"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925697"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925698"> </a><CODE>&lt;- <code>numBytesP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes in the receive queue.<br></TD></TR></TABLE></dl><dl><a name="925699"> </a><h4>Result </h4><p><a name="925709"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925702"> </a>0</td><td><a name="925704"> </a>No error.</td></tr><tr><td><a name="925706"> </a><code>serErrBadPort</code></td><td><a name="925708"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925710"> </a><h4>Compatibility </h4><dl><a name="925714"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925715"> </a><h4>See Also </h4><dl><a name="925725"> </a><p></p><dt><code><a href="NewSerialManager.html#925644"></code>SrmReceive<code></a></code>, <code><a href="NewSerialManager.html#925728"></code>SrmReceiveFlush<code></a></code>, <code><a href="NewSerialManager.html#925767"></code>SrmReceiveWait<code></a></code></dl></dl></dl><a name="925728"> </a><br> <br> <br><h3> SrmReceiveFlush</h3><dl><dl><a name="925729"> </a><h4>Purpose </h4><dl><a name="925730"> </a><p></p><dt>Flushes the receive FIFOs.</dl><a name="925731"> </a><h4>Prototype </h4><dl><a name="925732"> </a><dt><code>Err SrmReceiveFlush(UInt16&nbsp;portId, Int32&nbsp;timeout)</code></dl></dl><dl><a name="925733"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925734"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925735"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Timeout value, in ticks.<br></TD></TR></TABLE></dl><dl><a name="925736"> </a><h4>Result </h4><p><a name="925746"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925739"> </a>0</td><td><a name="925741"> </a>No error.</td></tr><tr><td><a name="925743"> </a><code>serErrBadPort</code></td><td><a name="925745"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925747"> </a><h4>Comments </h4><dl><a name="925748"> </a><p></p><dt>The <code>timeout</code> value forces this function to wait a period of ticks after flushing the port to see if more data shows up to be flushed. If more data arrives within the timeout period, the port is flushed again and the timeout counter is reset and waits again. The function only exits after no more bytes are received by the port for the full timeout period since the last flush of the port. To avoid this waiting behavior, specify 0 for the timeout period.</dl><a name="925749"> </a><h4>Compatibility </h4><dl><a name="925753"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925754"> </a><h4>See Also </h4><dl><a name="925764"> </a><p></p><dt><code><a href="NewSerialManager.html#925644"></code>SrmReceive<code></a></code>, <code><a href="NewSerialManager.html#925691"></code>SrmReceiveCheck<code></a></code>, <code><a href="NewSerialManager.html#925767"></code>SrmReceiveWait<code></a></code></dl></dl></dl><a name="925767"> </a><br> <br> <br><h3> SrmReceiveWait</h3><dl><dl><a name="925768"> </a><h4>Purpose </h4><dl><a name="925769"> </a><p></p><dt>Waits until some number of bytes of data have arrived into the serial receive queue, then returns.</dl><a name="925770"> </a><h4>Prototype </h4><dl><a name="925771"> </a><dt><code>Err SrmReceiveWait(UInt16&nbsp;portId, UInt32&nbsp;bytes, Int32&nbsp;timeout)</code></dl></dl><dl><a name="925772"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925773"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925774"> </a><CODE>-&gt; <code>bytes</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes to wait for.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925775"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Timeout value, in ticks.<br></TD></TR></TABLE></dl><dl><a name="925776"> </a><h4>Result </h4><p><a name="925790"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925779"> </a>0</td><td><a name="925781"> </a>No error.</td></tr><tr><td><a name="925783"> </a><code>serErrBadPort</code></td><td><a name="925785"> </a>This port doesn't exist.</td></tr><tr><td><a name="925787"> </a><code>serErrTimeoutErr</code></td><td><a name="925789"> </a>Unable to receive data within the specified <code>timeout</code> period.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925791"> </a><h4>Comments </h4><dl><a name="925792"> </a><p></p><dt>If this function returns no error, the application can either check the number of bytes currently in the receive queue (using <code><a href="NewSerialManager.html#925691"></code>SrmReceiveCheck<code></a></code>) or it can just specify a buffer and receive the data by calling <code><a href="NewSerialManager.html#925644"></code>SrmReceive<code></a></code>.</dl><a name="925799"> </a><h4>Compatibility </h4><dl><a name="925803"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925804"> </a><h4>See Also </h4><dl><a name="925814"> </a><p></p><dt><code><a href="NewSerialManager.html#925644"></code>SrmReceive<code></a></code>, <code><a href="NewSerialManager.html#925691"></code>SrmReceiveCheck<code></a></code>, <code><a href="NewSerialManager.html#925728"></code>SrmReceiveFlush<code></a></code></dl></dl></dl><a name="925817"> </a><br> <br> <br><h3> SrmReceiveWindowClose</h3><dl><dl><a name="925818"> </a><h4>Purpose </h4><dl><a name="925819"> </a><p></p><dt>Closes direct access to the new serial manager's receive queue.</dl><a name="925820"> </a><h4>Prototype </h4><dl><a name="925821"> </a><dt><code>Err SrmReceiveWindowClose(UInt16&nbsp;portId, UInt32&nbsp;bytesPulled)</code></dl></dl><dl><a name="925822"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925823"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925824"> </a><CODE>-&gt; <code>bytesPulled</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes the application read from the receive queue.<br></TD></TR></TABLE></dl><dl><a name="925825"> </a><h4>Result </h4><p><a name="925835"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925828"> </a>0</td><td><a name="925830"> </a>No error.</td></tr><tr><td><a name="925832"> </a><code>serErrBadPort</code></td><td><a name="925834"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925836"> </a><h4>Comments </h4><dl><a name="925837"> </a><p></p><dt>Call this function when the application has read as many bytes as it needs out of the receive queue or it has read all the available bytes.</dl><a name="925838"> </a><h4>Compatibility </h4><dl><a name="925842"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925843"> </a><h4>See Also </h4><dl><a name="925847"> </a><p></p><dt><code><a href="NewSerialManager.html#925850"></code>SrmReceiveWindowOpen<code></a></code></dl></dl></dl><a name="925850"> </a><br> <br> <br><h3> SrmReceiveWindowOpen</h3><dl><dl><a name="925851"> </a><h4>Purpose </h4><dl><a name="925852"> </a><p></p><dt>Provides direct access to the new serial manager's receive queue.</dl><a name="925853"> </a><h4>Prototype </h4><dl><a name="925854"> </a><dt><code>Err SrmReceiveWindowOpen(UInt16&nbsp;portId, UInt8&nbsp;**bufPP, UInt32*&nbsp;sizeP)</code></dl></dl><dl><a name="925855"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925856"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925857"> </a><CODE>&lt;- <code>bufPP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a pointer to the receive buffer.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925858"> </a><CODE>&lt;- <code>sizeP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Available bytes in buffer.<br></TD></TR></TABLE></dl><dl><a name="925859"> </a><h4>Result </h4><p><a name="925873"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925862"> </a>0</td><td><a name="925864"> </a>No error.</td></tr><tr><td><a name="925866"> </a><code>serErrBadPort</code></td><td><a name="925868"> </a>This port doesn't exist.</td></tr><tr><td><a name="925870"> </a><code>serErrLineErr</code></td><td><a name="925872"> </a>The data in the queue contains line errors.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925874"> </a><h4>Comments </h4><dl><a name="925875"> </a><p></p><dt>This function lets applications directly access the new serial manager's receive queue to eliminate buffer copying by the serial manager. This access is a "back door" route to the received data. After retrieving data from the buffer, the application must call <code><a href="NewSerialManager.html#925817"></code>SrmReceiveWindowClose<code></a></code>.<a name="925879"> </a><p></p><dt>Applications that want to empty the receive buffer entirely should call the <code>SrmReceiveWindowOpen</code> and <code>SrmReceiveWindowClose</code> functions repeatedly until the buffer size returned is 0.<a name="925880"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Once an application calls <code>SrmReceiveWindowOpen</code>, it should not attempt to receive data via the normal method of calling <code>SrmReceive</code> or <code>SrmReceiveWait</code>, as these functions interfere with direct access to the receive queue.<br><hr><br></blockquote></dl><a name="925881"> </a><h4>Compatibility </h4><dl><a name="925885"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925886"> </a><h4>See Also </h4><dl><a name="925890"> </a><p></p><dt><code><a href="NewSerialManager.html#925817"></code>SrmReceiveWindowClose<code></a></code></dl></dl></dl><a name="925893"> </a><br> <br> <br><h3> SrmSend</h3><dl><dl><a name="925894"> </a><h4>Purpose </h4><dl><a name="925895"> </a><p></p><dt>Sends a block of data out the specified port.</dl><a name="925896"> </a><h4>Prototype </h4><dl><a name="925897"> </a><dt><code>UInt32 SrmSend(UInt16&nbsp;portId, void&nbsp;*bufP, UInt32&nbsp;count, Err*&nbsp;errP)</code></dl></dl><dl><a name="925898"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925899"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925900"> </a><CODE>-&gt; <code>bufp</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to data to send.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925901"> </a><CODE>-&gt; <code>count</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length of data buffer, in bytes.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925902"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Error code. See Comments section for details.<br></TD></TR></TABLE></dl><dl><a name="925903"> </a><h4>Result </h4><dl><a name="925904"> </a><p></p><dt>Number of bytes of data actually sent.</dl></dl><dl><a name="925905"> </a><h4>Comments </h4><dl><a name="925906"> </a><p></p><dt>If <code>*errP</code> is <code>NULL</code>, the result value should be the same as the <code>count</code> parameter. If <code>*errP</code> is not <code>NULL</code>, then the result equals the number of bytes sent before the error occurred.<a name="925907"> </a><p></p><dt>The following error codes can be returned in <code>*errP</code>:<p><a name="925921"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925910"> </a>0</td><td><a name="925912"> </a>No error.</td></tr><tr><td><a name="925914"> </a><code>serErrBadPort</code></td><td><a name="925916"> </a>This port doesn't exist.</td></tr><tr><td><a name="925918"> </a><code>serErrTimeoutErr</code></td><td><a name="925920"> </a>Unable to send data within the specified <code>ctsTimeout</code> period.</td></tr></table><table><tr><td></table></div></p></dl><a name="925922"> </a><h4>Compatibility </h4><dl><a name="925926"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925927"> </a><h4>See Also </h4><dl><a name="925937"> </a><p></p><dt><code><a href="NewSerialManager.html#925940"></code>SrmSendCheck<code></a></code>, <code><a href="NewSerialManager.html#925983"></code>SrmSendFlush<code></a></code>, <code><a href="NewSerialManager.html#926019"></code>SrmSendWait<code></a></code></dl></dl></dl><a name="925940"> </a><br> <br> <br><h3> SrmSendCheck</h3><dl><dl><a name="925941"> </a><h4>Purpose </h4><dl><a name="925942"> </a><p></p><dt>Checks the transmit FIFO and returns the number of bytes left to be sent. </dl><a name="925943"> </a><h4>Prototype </h4><dl><a name="925944"> </a><dt><code>Err SrmSendCheck(UInt16&nbsp;portId, UInt32*&nbsp;numBytesP)</code></dl></dl><dl><a name="925945"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925946"> </a><CODE>-&gt; <code>portID</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925947"> </a><CODE>&lt;- <code>numBytesP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of bytes left in the FIFO queue.<br></TD></TR></TABLE></dl><dl><a name="925948"> </a><h4>Result </h4><p><a name="925962"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925951"> </a>0</td><td><a name="925953"> </a>No error.</td></tr><tr><td><a name="925955"> </a><code>serErrBadPort</code></td><td><a name="925957"> </a>This port doesn't exist.</td></tr><tr><td><a name="925959"> </a><code>serErrNotSupported</code></td><td><a name="925961"> </a>This feature not supported by the hardware.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="925963"> </a><h4>Comments </h4><dl><a name="925964"> </a><p></p><dt>Not all serial devices support this feature.</dl><a name="925965"> </a><h4>Compatibility </h4><dl><a name="925969"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="925970"> </a><h4>See Also </h4><dl><a name="925980"> </a><p></p><dt><code><a href="NewSerialManager.html#925893"></code>SrmSend<code></a></code>, <code><a href="NewSerialManager.html#925983"></code>SrmSendFlush<code></a></code>, <code><a href="NewSerialManager.html#926019"></code>SrmSendWait<code></a></code></dl></dl></dl><a name="925983"> </a><br> <br> <br><h3> SrmSendFlush</h3><dl><dl><a name="925984"> </a><h4>Purpose </h4><dl><a name="925985"> </a><p></p><dt>Flushes the transmit FIFO.</dl><a name="925986"> </a><h4>Prototype </h4><dl><a name="925987"> </a><dt><code>Err SrmSendFlush(UInt16&nbsp;portId)</code></dl></dl><dl><a name="925988"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925989"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE></dl><dl><a name="925990"> </a><h4>Result </h4><p><a name="926000"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925993"> </a>0</td><td><a name="925995"> </a>No error.</td></tr><tr><td><a name="925997"> </a><code>serErrBadPort</code></td><td><a name="925999"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="926001"> </a><h4>Compatibility </h4><dl><a name="926005"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="926006"> </a><h4>See Also </h4><dl><a name="926016"> </a><p></p><dt><code><a href="NewSerialManager.html#925893"></code>SrmSend<code></a></code>, <code><a href="NewSerialManager.html#925940"></code>SrmSendCheck<code></a></code>, <code><a href="NewSerialManager.html#926019"></code>SrmSendWait<code></a></code></dl></dl></dl><a name="926019"> </a><br> <br> <br><h3> SrmSendWait</h3><dl><dl><a name="926020"> </a><h4>Purpose </h4><dl><a name="926021"> </a><p></p><dt>Waits until all previous data has been sent from the transmit FIFO, then returns.</dl><a name="926022"> </a><h4>Prototype </h4><dl><a name="926023"> </a><dt><code>Err SrmSendWait(UInt16&nbsp;portId)</code></dl></dl><dl><a name="926024"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926025"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE></dl><dl><a name="926026"> </a><h4>Result </h4><p><a name="926040"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="926029"> </a>0</td><td><a name="926031"> </a>No error.</td></tr><tr><td><a name="926033"> </a><code>serErrBadPort</code></td><td><a name="926035"> </a>This port doesn't exist.</td></tr><tr><td><a name="926037"> </a><code>serErrTimeoutErr</code></td><td><a name="926039"> </a>Unable to send data within the <code>ctsTimeout</code> period.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="926041"> </a><h4>Compatibility </h4><dl><a name="926045"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="926046"> </a><h4>See Also </h4><dl><a name="926056"> </a><p></p><dt><code><a href="NewSerialManager.html#925893"></code>SrmSend<code></a></code>, <code><a href="NewSerialManager.html#925940"></code>SrmSendCheck<code></a></code>, <code><a href="NewSerialManager.html#925983"></code>SrmSendFlush<code></a></code></dl></dl></dl><a name="926059"> </a><br> <br> <br><h3> SrmSetReceiveBuffer</h3><dl><dl><a name="926060"> </a><h4>Purpose </h4><dl><a name="926061"> </a><p></p><dt>Installs a new buffer into the new serial manager's receive queue.</dl><a name="926062"> </a><h4>Prototype </h4><dl><a name="926063"> </a><dt><code>Err SrmSetReceiveBuffer(UInt16&nbsp;portId, void&nbsp;*bufP, UInt16&nbsp;bufSize)</code></dl></dl><dl><a name="926064"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926065"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926066"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to new receive buffer. Ignored if <code>bufSize</code> is <code>NULL</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926067"> </a><CODE>-&gt; <code>bufSize</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size of new receive buffer in bytes. To remove this buffer and allocate a new default buffer (512 bytes), specify <code>NULL</code>.<br></TD></TR></TABLE></dl><dl><a name="926068"> </a><h4>Result </h4><p><a name="926082"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="926071"> </a>0</td><td><a name="926073"> </a>No error.</td></tr><tr><td><a name="926075"> </a><code>serErrBadPort</code></td><td><a name="926077"> </a>This port doesn't exist.</td></tr><tr><td><a name="926079"> </a><code>memErrNotEnoughSpace</code></td><td><a name="926081"> </a>Not enough memory to allocate default buffer.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="926083"> </a><h4>Comments </h4><a name="926084"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Applications must install the default buffer before closing the port (or disposing of the new receive queue.)<br><hr><br></blockquote><a name="926085"> </a><h4>Compatibility </h4><dl><a name="926089"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl></dl></dl><a name="926092"> </a><br> <br> <br><h3> SrmSetWakeupHandler</h3><dl><dl><a name="926093"> </a><h4>Purpose </h4><dl><a name="926094"> </a><p></p><dt>Installs a wakeup handler.</dl><a name="926095"> </a><h4>Prototype </h4><dl><a name="926096"> </a><dt><code>Err SrmSetWakeupHandler(UInt16&nbsp;portId, WakeupHandlerProcPtr&nbsp;procP, UInt32&nbsp;refCon)</code></dl></dl><dl><a name="926097"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926098"> </a><CODE>-&gt; <code>portId</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Port ID.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926102"> </a><CODE>-&gt; <code>procP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a <code><a href="NewSerialManager.html#926137"></code>WakeupHandlerProc<code></a></code> function. Specify <code>NULL</code> to remove a handler.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926103"> </a><CODE>-&gt; <code>refCon</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>User-defined data that is passed to the wakeup handler function. This can be a pointer or not.<br></TD></TR></TABLE></dl><dl><a name="926104"> </a><h4>Result </h4><p><a name="926114"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="926107"> </a>0</td><td><a name="926109"> </a>No error.</td></tr><tr><td><a name="926111"> </a><code>serErrBadPort</code></td><td><a name="926113"> </a>This port doesn't exist.</td></tr></table><table><tr><td></table></div></p></dl><dl><a name="926115"> </a><h4>Comments </h4><dl><a name="926116"> </a><p></p><dt>The wakeup handler function will not become active until it is primed with a number of bytes that is greater than 0, by the <code><a href="NewSerialManager.html#925605"></code>SrmPrimeWakeupHandler<code></a></code> function. Every time a wakeup handler is called, it must be reprimed (via <code>SrmPrimeWakeupHandler</code>) in order to be called again.</dl><a name="926120"> </a><h4>Compatibility </h4><dl><a name="926124"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="926125"> </a><h4>See Also </h4><dl><a name="926132"> </a><p></p><dt><code><a href="NewSerialManager.html#925605"></code>SrmPrimeWakeupHandler<code></a></code>, <code><a href="NewSerialManager.html#926137"></code>WakeupHandlerProc<code></a></code></dl></dl></dl><a name="926134"> </a><h2> New Serial Manager Application-Defined Function</h2><a name="926137"> </a><br> <br> <br><h3> WakeupHandlerProc</h3><dl><dl><a name="926138"> </a><h4>Purpose </h4><dl><a name="926139"> </a><p></p><dt>Called after some number of bytes are received by the new serial manager's interrupt function.</dl><a name="926140"> </a><h4>Prototype </h4><dl><a name="926141"> </a><dt><code>void WakeupHandlerProcPtr(UInt32&nbsp;refCon)</code></dl></dl><dl><a name="926142"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926143"> </a><CODE>-&gt;<code>refCon</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>User-defined data passed from the <code><a href="NewSerialManager.html#926092"></code>SrmSetWakeupHandler<code></a></code> function.<br></TD></TR></TABLE></dl><dl><a name="926147"> </a><h4>Result </h4><dl><a name="926148"> </a><p></p><dt>Returns nothing.</dl></dl><dl><a name="926149"> </a><h4>Comments </h4><dl><a name="926153"> </a><p></p><dt>This handler function is installed by calling <code><a href="NewSerialManager.html#926092"></code>SrmSetWakeupHandler<code></a></code>. The number of bytes after which it is called is specified by <code><a href="NewSerialManager.html#925605"></code>SrmPrimeWakeupHandler<code></a></code>.<a name="926157"> </a><p></p><dt>Because wakeup handlers are called during interrupt time, they cannot call ANY Palm OS<sup>&#174;</sup> system functions that may block the system in any way. Wakeup handlers should also be very short so as to reduce interrupt latency.</dl><a name="926158"> </a><h4>Compatibility </h4><dl><a name="926162"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484724">New Serial Manager Feature Set</a> is present.</dl><a name="926163"> </a><h4>See Also </h4><dl><a name="926170"> </a><p></p><dt><code><a href="NewSerialManager.html#925605"></code>SrmPrimeWakeupHandler<code></a></code>, <code><a href="NewSerialManager.html#926092"></code>SrmSetWakeupHandler<code></a></code><dl><a name="926182"> </a><p></p><dt><strong></strong></dl></dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="NetworkUtils.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="ScriptPlugin.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 58 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:04 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/NewSerialManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
</html>