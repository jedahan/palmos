<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/EventLoop.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:04 GMT -->
<head><title>Event Loop</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="AppStartupAndStop.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="UserInterface.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS Programmer's Companion</B></center><hr><br><a name="924905"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>4 Event Loop</h1><dl><a name="924907"> </a><p></p><dt>This chapter discusses the event manager, the main interface between the Palm OS system software and the application. It discusses in some detail what an application does in response to user input, providing code fragments as examples where needed. The topics covered are:<ul type="SQUARE"><a name="924911"> </a><br><li><a href="EventLoop.html#925079">The Application Event Loop</a><br><a name="924915"> </a><br><li><a href="EventLoop.html#925190">Low-Level Event Management</a><br></ul><a name="924916"> </a><p></p><dt>This chapter's focus is on how to write your applications main event loop. For more detailed information on events, consult the <em>Palm OS SDK Reference</em>. Details for each event are given in <a href="EventRef.html#924906">Chapter 3, "Palm OS Events."</a> In addition to the reference material, consult the chapter <a href="UserInterface.html#924904">"User Interface"</a> in this book. It provides the event flow for each user interface element. <a name="924926"> </a><p></p><dt><a href="EventLoop.html#925077">Figure 4.1</a> illustrates control flow in a typical application.</dl><a name="925077"> </a><h4>Figure 4.1	 <img src="images/EventLoopa.gif" height="719" width="629">Control Flow in a Typical Application</h4><a name="925079"> </a><h2> The Application Event Loop</h2><dl><a name="925083"> </a><p></p><dt>As described in the previous chapter, "<a href="AppStartupAndStop.html#924904">Application Startup and Stop</a>," an application performs a full startup when it receives the launch code <code>sysAppLaunchCmdNormalLaunch</code>. It begins with a startup routine, then goes into an event loop, and finally exits with a stop routine. <a name="925085"> </a><p></p><dt>In the event loop, the application fetches events from the queue and dispatches them, taking advantage of the default system functionality as appropriate. <a name="925087"> </a><p></p><dt>While in the loop, the application continuously checks for events on the event queue. If there are events on the queue, the application has to process them as determined in the event loop. As a rule, the events are passed on to the system, which knows how to handle them. For example, the system knows how to respond to pen taps on forms or menus. <a name="925088"> </a><p></p><dt>The application typically remains in the event loop until the system tells it to shut itself down by sending an <code><a href="EventRef.html#925387"></code>appStopEvent<code></a></code> (not a launch code) through the event queue. The application must detect this event and terminate. </dl><a name="925093"> </a><h4>Listing 4.1	 Top-Level Event Loop Example from Datebook.c</h4><a name="925094"> </a><hr><code>static void EventLoop (void)</code><br><a name="925095"> </a><code>{</code><br><a name="925096"> </a><code>&nbsp&nbsp&nbsp UInt16 error;</code><br><a name="925097"> </a><code>&nbsp&nbsp&nbsp EventType event;</code><br><a name="925098"> </a><code>&nbsp&nbsp&nbsp do</code><br><a name="925099"> </a><code>&nbsp&nbsp&nbsp 	 {</code><br><a name="925100"> </a><code>&nbsp&nbsp&nbsp 	 EvtGetEvent (&amp;event, evtWaitForever);</code><br><a name="925101"> </a><code>&nbsp&nbsp&nbsp 	 </code><br><a name="925102"> </a><code>&nbsp&nbsp&nbsp 	 PreprocessEvent (&amp;event);</code><br><a name="925103"> </a><code>&nbsp&nbsp&nbsp 	 </code><br><a name="925104"> </a><code>&nbsp&nbsp&nbsp 	 if (! SysHandleEvent (&amp;event))</code><br><a name="925105"> </a><code>&nbsp&nbsp&nbsp 	 	 </code><br><a name="925106"> </a><code>&nbsp&nbsp&nbsp 	 	 if (! MenuHandleEvent (NULL, &amp;event, &amp;error))</code><br><a name="925107"> </a><code>&nbsp&nbsp&nbsp 	 	 	 </code><br><a name="925108"> </a><code>&nbsp&nbsp&nbsp 	 	 	 if (! ApplicationHandleEvent (&amp;event))</code><br><a name="925109"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 FrmDispatchEvent (&amp;event); </code><br><a name="925110"> </a><code></code><br><a name="925111"> </a><code>&nbsp&nbsp&nbsp 	 #if	 	 EMULATION_LEVEL != EMULATION_NONE</code><br><a name="925112"> </a><code>&nbsp&nbsp&nbsp 	 	 ECApptDBValidate (ApptDB);</code><br><a name="925113"> </a><code>&nbsp&nbsp&nbsp 	 #endif</code><br><a name="925114"> </a><code>&nbsp&nbsp&nbsp 	 }</code><br><a name="925115"> </a><code>&nbsp&nbsp&nbsp while (event.eType != appStopEvent);</code><br><a name="925116"> </a><code>}</code><br><hr><br><dl><a name="925117"> </a><p></p><dt>In the event loop, the application iterates through these steps (see <a href="EventLoop.html#925077">Figure 4.1</a> and <a href="EventLoop.html#925093">Listing 4.1</a>)</dl>  <a name="925124"> </a><font face="">Fetch an event from the event queue.</font>  <a name="925125"> </a><font face="">Call <code>PreprocessEvent </code>to allow the datebook event handler to see the command keys before any other event handler gets them. Some of the datebook views display UI that disappears automatically; this UI needs to be dismissed before the system event handler or the menu event handler display any UI objects. </font>  <a name="925126"> </a><font face="">Note that not all applications need a <code>PreprocessEvent</code> function. It may be appropriate to call <code>SysHandleEvent</code> right away. </font>  <a name="925130"> </a><font face="">Call <code><a href="SystemManager.html#925364"></code>SysHandleEvent<code></a></code> to give the system an opportunity to handle the event. </font>  <a name="925131"> </a><font face="">The system handles events like power on/power off, Graffiti input, tapping silk-screened icons, or pressing buttons. During the call to <code>SysHandleEvent</code>, the user may also be informed about low-battery warnings or may find and search another application.</font>  <a name="925132"> </a><font face="">Note that in the process of handling an event, <code>SysHandleEvent</code> may generate new events and put them on the queue. For example, the system handles Graffiti input by translating the pen events to key events. Those, in turn, are put on the event queue and are eventually handled by the application. </font>  <a name="925133"> </a><font face=""><code>SysHandleEvent</code> returns <code>true</code> if the event was completely handled, that is, no further processing of the event is required. The application can then pick up the next event from the queue. </font>  <a name="925134"> </a><font face="">If <code>SysHandleEvent</code> did not completely handle the event, the application calls <code><a href="Menu.html#925345"></code>MenuHandleEvent<code></a></code>. <code>MenuHandleEvent</code> handles two types of events:</font><p></p><ul type="CIRCLE"><a name="925138"> </a><li>If the user has tapped in the area that invokes a menu, <code>MenuHandleEvent</code> brings up the menu. <a name="925139"> </a><li>If the user has tapped inside a menu to invoke a menu command, <code>MenuHandleEvent</code> removes the menu from the screen and puts the events that result from the command onto the event queue. </ul>  <a name="925140"> </a><font face=""><code>MenuHandleEvent</code> returns <code>TRUE</code> if the event was completely handled. </font>  <a name="925141"> </a><font face="">If <code>MenuHandleEvent</code> did not completely handle the event, the application calls <code>ApplicationHandleEvent</code>, a function your application has to provide itself. <code>ApplicationHandleEvent</code> handles only the <code><a href="EventRef.html#925659"></code>frmLoadEvent<code></a></code> for that event; it loads and activates application form resources and sets the event handler for the active form. </font>  <a name="925145"> </a><font face="">If <code>ApplicationHandleEvent</code> did not completely handle the event, the application calls <code><a href="Form.html#925818"></code>FrmDispatchEvent<code></a>. FrmDispatchEvent</code> first sends the event to the application's event handler for the active form. This is the event handler routine that was established in <code>ApplicationHandleEvent</code>. Thus the application's code is given the first opportunity to process events that pertain to the current form. The application's event handler may completely handle the event and return <code>true</code> to calls from <code>FrmDispatchEvent.</code>In that case, <code>FrmDispatchEvent</code> returns to the application's event loop. Otherwise, <code>FrmDispatchEvent</code> calls <code><a href="Form.html#926413"></code>FrmHandleEvent<code></a></code> to provide the system's default processing for the event. </font>  <a name="925152"> </a><font face="">For example, in the process of handling an event, an application frequently has to first close the current form and then open another one, as follows:</font><p></p><ul type="CIRCLE"><a name="925156"> </a><li>The application calls <code><a href="Form.html#926376"></code>FrmGotoForm<code></a></code> to bring up another form. <code>FrmGotoForm</code> queues a <code><a href="EventRef.html#925596"></code>frmCloseEvent<code></a></code> for the currently active form, then queues <code><a href="EventRef.html#925659"></code>frmLoadEvent<code></a></code> and <code><a href="EventRef.html#925679"></code>frmOpenEvent<code></a></code> for the new form. <a name="925166"> </a><li>When the application gets the <code>frmCloseEvent,</code> it closes and erases the currently active form. <a name="925167"> </a><li>When the application gets the <code>frmLoadEvent</code>, it loads and then activates the new form. Normally, the form remains active until it's closed. (Note that this wouldn't work if you preload all forms, but preloading is really discouraged. Applications don't need to be concerned with the overhead of loading forms; loading is so fast that applications can do it when they need it.) The application's event handler for the new form is also established.<a name="925168"> </a><li>When the application gets the <code>frmOpenEvent</code>, it performs any required initialization of the form, then draws the form on the display. </ul>  <a name="925169"> </a><font face="">After <code>FrmGotoForm</code> has been called, any further events that come through the main event loop and to <code>FrmDispatchEvent</code> are dispatched to the event handler for the form that's currently active. For each dialog box or form, the event handler knows how it should respond to events, for example, it may open, close, highlight, or perform other actions in response to the event. <code><a href="Form.html#926413"></code>FrmHandleEvent<code></a></code> invokes this default UI functionality. </font>  <a name="925173"> </a><font face="">After the system has done all it can to handle the event for the specified form, the application finally calls the active form's own event handling function. For example, in the datebook application, it may call <code>DayViewHandleEvent</code> or <code>WeekViewHandleEvent</code>. </font><dl><a name="925174"> </a><p></p><dt>Notice how the event flow allows your application to rely on system functionality as much as it wants. If your application wants to know whether a button is pressed, it has only to wait for <code><a href="EventRef.html#935051"></code>ctlSelectEvent<code></a></code>. All the details of the event queue are handled by the system. <a name="925178"> </a><p></p><dt>Some events are actually requests for the application to do something, for example, <code><a href="EventRef.html#925679"></code>frmOpenEvent<code></a></code>. Typically, all the application does is draw its own interface, using the functions provided by the system, and then waits for events it can handle to arrive from the queue. <a name="925183"> </a><p></p><dt>Only the active form should process events. </dl><a name="925190"> </a><h2> Low-Level Event Management</h2><dl><a name="925192"> </a><p></p><dt>You can perform low-level event management using System Event Manager functions. The system event manager: <ul type="SQUARE"><a name="925193"> </a><br><li>manages the low-level pen and key event queues. <br><a name="925194"> </a><br><li>translates taps on silk-screened icons into key events.<br><a name="925195"> </a><br><li>sends pen strokes in the Graffiti area to the Graffiti recognizer. <br><a name="925196"> </a><br><li>puts the system into low-power doze mode when there is no user activity. <br></ul><a name="925197"> </a><p></p><dt>Most applications have no need to call the system event manager directly because most of the functionality they need comes from the higher-level event manager or is automatically handled by the system. <a name="925198"> </a><p></p><dt>Applications that do use the system event manager directly might do so to enqueue key events into the key queue or to retrieve each of the pen points that comprise a pen stroke from the pen queue. <a name="925199"> </a><p></p><dt>This section provides information about the system event manager by discussing these topics: <ul type="SQUARE"><a name="925203"> </a><br><li><a href="EventLoop.html#925217">Event Translation: Pen Strokes to Key Events</a><br><a name="925207"> </a><br><li><a href="EventLoop.html#925234">Pen Queue Management</a><br><a name="925211"> </a><br><li><a href="EventLoop.html#925314">Auto-Off Control</a><br><a name="925215"> </a><br><li><a href="EventLoop.html#925322">System Event Manager Summary</a><br></ul></dl><a name="925217"> </a><h3> Event Translation: Pen Strokes to Key Events</h3><dl><a name="925219"> </a><p></p><dt>One of the higher-level functions provided by the system event manager is conversion of pen strokes on the digitizer to key events. For example, the system event manager sends any stroke in the Graffiti area of the digitizer automatically to the Graffiti recognizer for conversion to a key event. Taps on silk-screened icons, such as the application launcher, Menu button, and Find button, are also intercepted by the system event manager and converted into the appropriate key events.<a name="925220"> </a><p></p><dt>When the system converts a pen stroke to a key event, it:<ul type="SQUARE"><a name="925221"> </a><br><li>Retrieves all pen points that comprise the stroke from the pen queue<br><a name="925222"> </a><br><li>Converts the stroke into the matching key event<br><a name="925223"> </a><br><li>Enqueues that key event into the key queue<br></ul><a name="925224"> </a><p></p><dt>Eventually, the system returns the key event to the application as a normal result of calling <a href="SystemEventManager.html#925143">EvtGetEvent</a>. <a name="925228"> </a><p></p><dt>Most applications rely on the following default behavior of the system event manager:<ul type="SQUARE"><a name="925230"> </a><br><li>All strokes in the predefined Graffiti area of the digitizer are converted to key events<br><a name="925231"> </a><br><li>All taps on the silk-screened icons are convert to key events<br><a name="925232"> </a><br><li>All other strokes are passed on to the application for processing<br></ul></dl><a name="925234"> </a><h3> Pen Queue Management</h3><dl><a name="925236"> </a><p></p><dt>The pen queue is a preallocated area of system memory used for capturing the most recent pen strokes on the digitizer. It is a circular queue with a first-in, first-out method of storing and retrieving pen points. Points are usually enqueued by a low-level interrupt routine and dequeued by the system event manager or application.<a name="925241"> </a><p></p><dt><a href="EventLoop.html#925752">Table 4.1</a> summarizes pen management.<p><a name="925262"> </a> </p><p><div> <table border="3"><caption><B><a name="925752"> </a><h4>Table 4.1	 Pen Queue Management&nbsp;</h4></B></caption><tr><th><a name="925246"> </a><strong>The user...</strong></th><th><a name="925248"> </a><strong>The system...</strong></th></tr><tr><td><a name="925250"> </a>Brings the pen down on the digitizer.</td><td><a name="925252"> </a>Stores a pen-down sequence in the pen queue and starts the stroke capture. </td></tr><tr><td><a name="925254"> </a>Draws a character. </td><td><a name="925256"> </a>Stores additional points in the pen queue periodically. </td></tr><tr><td><a name="925258"> </a>Lifts the pen.</td><td><a name="925260"> </a>Stores a pen-up sequence in the pen queue and turns off stroke capture. </td></tr></table><table><tr><td></table></div></p><a name="925263"> </a><p></p><dt>The system event manager provides an API for initializing and flushing the pen queue and for queuing and dequeuing points. Some state information is stored in the queue itself: to dequeue a stroke, the caller must first make a call to dequeue the stroke information (<a href="SystemEventManager.html#925004">EvtDequeuePenStrokeInfo</a>) before the points for the stroke can be dequeued. Once the last point is dequeued, another <code>EvtDequeuePenStrokeInfo</code> call must be made to get the next stroke.<a name="925267"> </a><p></p><dt>Applications usually don't need to call <code>EvtDequeuePenStrokeInfo</code>  because the event manager calls this function automatically when it detects a complete pen stroke in the pen queue. After calling <code>EvtDequeuePenStrokeInfo</code>, the system event manager stores the stroke bounds into the event record and returns the pen-up event to the application. The application is then free to dequeue the stroke points from the pen queue, or to ignore them altogether. If the points for that stroke are not dequeued by the time <a href="SystemEventManager.html#925143">EvtGetEvent</a> is called again, the system event manager automatically flushes them.</dl><a name="925271"> </a><h3> Key Queue Management</h3><dl><a name="925273"> </a><p></p><dt>The key queue is an area of system memory preallocated for capturing key events. Key events come from one of two occurrences: <ul type="SQUARE"><a name="925274"> </a><br><li>As a direct result of the user pressing one of the buttons on the case <br><a name="925275"> </a><br><li>As a side effect of the user drawing a Graffiti stroke on the digitizer, which is converted in software to a key event<br></ul><a name="925279"> </a><p></p><dt><a href="EventLoop.html#925781">Table 4.2</a> summarizes key management.<p><a name="925308"> </a> </p><p><div> <table border="3"><caption><B><a name="925781"> </a><h4>Table 4.2	 Key Queue Management&nbsp;</h4></B></caption><tr><th><a name="925284"> </a><strong>User action</strong></th><th><a name="925286"> </a><strong>System response</strong></th></tr><tr><td><a name="925288"> </a>Hardware button press.</td><td><a name="925290"> </a>Interrupt routine enqueues the appropriate key event into the key queue, temporarily disables further hardware button interrupts, and sets up a timer task to run every 10 ms. </td></tr><tr><td><a name="925292"> </a>Hold down key for extended time period. </td><td><a name="925295"> </a>Timer task to supports auto-repeat of the key (timer task is also used to debounce the hardware). </td></tr><tr><td><a name="925297"> </a>Release key for certain amount of time.</td><td><a name="925299"> </a>Timer task reenables the hardware button interrupts.</td></tr><tr><td><a name="925301"> </a>Pen stroke in Graffiti area of digitizer.</td><td><a name="925303"> </a>System manager calls the Graffiti recognizer, which then removes the stroke from the pen queue, converts the stroke into one or more key events, and finally enqueues these key events into the key queue. </td></tr><tr><td><a name="925305"> </a>Pen stroke on silk-screened icons.</td><td><a name="925307"> </a>System event manager converts the stroke into the appropriate key event and enqueues it into the key queue.</td></tr></table><table><tr><td></table></div></p><a name="925309"> </a><p></p><dt>The system event manager provides an API for initializing and flushing the key queue and for enqueuing and dequeuing key events. Usually, applications have no need to dequeue key events; the event manager does this automatically if it detects a key in the queue and returns a <code>keyDownEvent</code> to the application through the <a href="SystemEventManager.html#925143">EvtGetEvent</a> call.</dl><a name="925314"> </a><h3> Auto-Off Control</h3><dl><a name="925315"> </a><p></p><dt>Because the system event manager manages hardware events like pen taps and hardware button presses, it's responsible for resetting the auto-off timer on the device. Whenever the system detects a hardware event, it automatically resets the auto-off timer to 0. If an application needs to reset the auto-off timer manually, it can do so through the system event manager call <a href="SystemEventManager.html#925260">EvtResetAutoOffTimer</a>.</dl><a name="925322"> </a><h3> System Event Manager Summary</h3><p><a name="925456"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th colspan=2 rowspan=1><a name="925325"> </a><strong>System Event Manager Functions</strong></th></tr><tr><td colspan=2 rowspan=1><a name="925329"> </a><strong>Main Event Queue Management</strong></td></tr><tr><td><a name="925336"> </a><a href="SystemEventManager.html#925143">EvtGetEvent</a> </td><td><a name="925341"> </a><a href="SystemEventManager.html#925074">EvtEventAvail</a> </td></tr><tr><td><a name="925346"> </a><a href="SystemEventManager.html#932680">EvtSysEventAvail</a></td><td><a name="925351"> </a><a href="SystemEventManager.html#924939">EvtAddEventToQueue</a></td></tr><tr><td><a name="925356"> </a><a href="SystemEventManager.html#924952">EvtAddUniqueEventToQueue</a></td><td><a name="925361"> </a><a href="SystemEventManager.html#924975">EvtCopyEvent</a></td></tr><tr><td><a name="925363"> </a><strong>Pen Queue Management</strong></td><td><a name="925365"> </a></td></tr><tr><td><a name="925370"> </a><strong><a href="SystemEventManager.html#925224">EvtPenQueueSize</a></strong></td><td><a name="925375"> </a><a href="SystemEventManager.html#924987">EvtDequeuePenPoint</a></td></tr><tr><td><a name="925380"> </a><a href="SystemEventManager.html#925004">EvtDequeuePenStrokeInfo</a></td><td><a name="925385"> </a><a href="SystemEventManager.html#925104">EvtFlushNextPenStroke</a></td></tr><tr><td><a name="925390"> </a><a href="SystemEventManager.html#925125">EvtFlushPenQueue</a></td><td><a name="925395"> </a><a href="SystemEventManager.html#925157">EvtGetPen</a></td></tr><tr><td><a name="925400"> </a><a href="SystemEventManager.html#925178">EvtGetPenBtnList</a></td><td><a name="925402"> </a></td></tr><tr><td colspan=2 rowspan=1><a name="925404"> </a><strong>Key Queue Management</strong></td></tr><tr><td><a name="925411"> </a><a href="SystemEventManager.html#925210">EvtKeyQueueSize</a></td><td><a name="925416"> </a><a href="SystemEventManager.html#925039">EvtEnqueueKey</a></td></tr><tr><td><a name="925421"> </a><a href="SystemEventManager.html#925091">EvtFlushKeyQueue</a></td><td><a name="925426"> </a><a href="SystemEventManager.html#925197">EvtKeyQueueEmpty</a></td></tr><tr><td colspan=2 rowspan=1><a name="925428"> </a><strong>Handling pen strokes and key strokes</strong></td></tr><tr><td><a name="925435"> </a><a href="SystemEventManager.html#925028">EvtEnableGraffiti</a></td><td><a name="925440"> </a><a href="SystemEventManager.html#925238">EvtProcessSoftKeyStroke</a></td></tr><tr><td colspan=2 rowspan=1><a name="925442"> </a><strong>Handling power on and off events</strong></td></tr><tr><td><a name="925449"> </a><a href="SystemEventManager.html#925260">EvtResetAutoOffTimer</a></td><td><a name="925455"> </a><a href="SystemEventManager.html#925299">EvtWakeup</a><code></code></td></tr></table><table><tr><td></table></div></p><dl><a name="925470"> </a><p></p><dt><strong></strong></dl><hr><br><center><B>Palm OS Programmer's Companion</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="AppStartupAndStop.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="UserInterface.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 73 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:34 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/EventLoop.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:04 GMT -->
</html>