<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/NetworkCommunication.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:16 GMT -->
<head><title>Network Communication</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="Beaming.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="InternetApps.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS Programmer's Companion</B></center><hr><br><a name="924904"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924902"> </a>11 Network Communication</h1><dl><a name="924905"> </a><p></p><dt>Two different Palm OS<sup>&#174;</sup> libraries provide network services to applications:<ul type="SQUARE"><a name="924906"> </a><br><li>The net library provides basic network services using TCP and UDP via a socket API. This library is discussed in the section <a href="NetworkCommunication.html#924915">Net Library</a>.<br><a name="924910"> </a><br><li>The Internet library builds on the net library to provide a socket-like API to high-level Internet protocols such as HTTP. This library is discussed in the section <a href="NetworkCommunication.html#926125">Internet Library</a>.<br></ul></dl><a name="924915"> </a><h2> Net Library</h2><dl><a name="924916"> </a><p></p><dt>The net library allows Palm OS applications to easily establish a connection with any other machine on the Internet and transfer data to and from that machine using the standard TCP/IP protocols.<a name="924918"> </a><p></p><dt>The basic network services provided by the net library include: <ul type="SQUARE"><a name="924920"> </a><br><li>Stream-based, guaranteed delivery of data using TCP (Transmission Control Protocol).<br><a name="924922"> </a><br><li>Datagram-based, best-effort delivery of data using UDP (User Datagram Protocol). <br></ul><a name="924927"> </a><p></p><dt>You can implement higher-level Internet-based services (file transfer, e-mail, web browsing, etc.) on top of these basic delivery services. <a name="924929"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Applications cannot directly use the net library to make wireless connections. Use the Internet library for wireless connections. <br><hr><br></blockquote><a name="924930"> </a><p></p><dt>This section describes how to use the net library in your application. It covers:<ul type="SQUARE"><a name="924934"> </a><br><li><a href="NetworkCommunication.html#924976">About the Net Library</a><br><a name="924938"> </a><br><li><a href="NetworkCommunication.html#925045">Net Library Usage Steps</a><br><a name="924942"> </a><br><li><a href="NetworkCommunication.html#925080">Obtaining the Net Library's Reference Number</a><br><a name="924946"> </a><br><li><a href="NetworkCommunication.html#925100">Setting Up Berkeley Socket API</a><br><a name="924950"> </a><br><li><a href="NetworkCommunication.html#925114">Setup and Configuration Calls</a><br><a name="924954"> </a><br><li><a href="NetworkCommunication.html#925417">Opening the Net Library</a><br><a name="924958"> </a><br><li><a href="NetworkCommunication.html#925478">Closing the Net Library</a><br><a name="924962"> </a><br><li><a href="NetworkCommunication.html#925499">Version Checking</a><br><a name="924966"> </a><br><li><a href="NetworkCommunication.html#925537">Network I/O and Utility Calls</a><br><a name="924970"> </a><br><li><a href="NetworkCommunication.html#925558">Berkeley Sockets API Functions</a><br><a name="924974"> </a><br><li><a href="NetworkCommunication.html#926013">Extending the Network Login Script Support</a><br></ul></dl><a name="924976"> </a><h3> About the Net Library</h3><dl><a name="924978"> </a><p></p><dt>The net library consists of two parts: a netlib interface and a net protocol stack. <a name="924980"> </a><p></p><dt>The <strong>netlib interface</strong> is the set of routines that an application calls directly when it makes a net library call. These routines execute in the caller's task like subroutines of the application. They are not linked in with the application, however, but are called through the library dispatch mechanism. <a name="924981"> </a><p></p><dt>With the exception of functions that open, close, and set up the net library, the net library's API maps almost directly to the Berkeley UNIX sockets API, the de facto standard API for Internet applications. You can compile an application written to use the Berkeley sockets API for the Palm OS with only slight changes to the source code.<a name="924985"> </a><p></p><dt>The <strong>net protocol stack</strong> runs as a separate task in the operating system. Inside this task, the TCP/IP protocol stack runs, and received packets are processed from the network device drivers. The netlib interface communicates with the net protocol stack through an operating system mailbox queue. It posts requests from applications into the queue and blocks until the net protocol stack processes the requests.<a name="924989"> </a><p></p><dt>Having the net protocol stack run as a separate task has two big advantages: <ul type="SQUARE"><a name="924990"> </a><br><li>The operating system can switch in the net protocol stack to process incoming packets from the network even if the application is currently busy. <br><a name="924991"> </a><br><li>Even if an application is blocked waiting for some data to arrive off the network, the net protocol stack can continue to process requests for other applications. <br></ul><a name="924992"> </a><p></p><dt>One or more network interfaces run inside the net protocol stack task. A <strong>network interface</strong> is a separately linked database containing code necessary to abstract link-level protocols. For example, there are separate network interface databases for PPP and SLIP. A network interface is generally specified by the user in the Network preference panel. In rare circumstances, interfaces can also be attached and detached from the net library at runtime as described in the section <a href="NetworkCommunication.html#925128">"Settings for Interface Selection"</a> later in this chapter. </dl><a name="925001"> </a><h4> Constraints</h4><dl><a name="925002"> </a><p></p><dt>Because it's unclear whether all future platforms will need or want network support (especially devices with very limited amounts of memory), network support is an optional part of the operating system. For this reason, the net library is implemented as a system library that is installed at runtime and doesn't have to be present for the system to work properly. <a name="925004"> </a><p></p><dt>When the net library is present and running, it requires an estimated additional 32 KB of RAM. This in effect doubles the overall system RAM requirements, currently 32 KB without the net library. It's therefore not practical to run the net library on any platform that has 128 KB or less of total RAM available since the system itself will consume 64 KB of RAM (leaving only 64 KB for user storage in a 128 KB system). <a name="925006"> </a><p></p><dt>Because of the RAM requirements, the net library is supported only on PalmPilot Professional and newer devices running Palm OS 2.0 and later. <a name="925007"> </a><p></p><dt>All applications written for Palm OS must pay special attention to memory and CPU usage because Palm OS runs on small devices with limited amounts of memory and other hardware resources. Applications that use the net library, therefore, must pay even more attention to memory usage. After opening the net library, the total remaining amount of RAM available to an application is approximately 12 KB on a PalmPilot Professional and 36KB on a Palm III<sup>&#153;</sup>. </dl><a name="925009"> </a><h4> The Programmer's Interface</h4><dl><a name="925010"> </a><p></p><dt>There are essentially two sets of API into the net library: the net library's native API, and the Berkeley sockets API. The two APIs map almost directly to each other. You can use the Berkeley sockets API with no performance penalty and little or no modifications to any existing code that you have. <a name="925012"> </a><p></p><dt>The header file &lt;unix/sys_socket.h&gt; contains a set of macros that map Berkeley sockets calls directly to net library calls. The main difference between the net library API and the Berkeley sockets API is that most net library API calls accept additional parameters for: <ul type="SQUARE"><a name="925013"> </a><br><li><strong>A reference number.</strong> All library calls in the Palm OS must have the library reference number as the first parameter. <br><a name="925014"> </a><br><li><strong>A timeout.</strong> In consumer systems such as the Palm OS device, infinite timeouts don't work well because the end user can't "kill" a process that's stuck. The timeout allows the application to gracefully recover from hung connections. The default timeout is 2 seconds.<br><a name="925015"> </a><br><li><strong>An error code.</strong> The sockets API by convention returns error codes in the application's global variable <code>errno</code>. The net library API doesn't rely on any application global variables. This allows system code (which cannot have global variables) to use the net library API. <br></ul><a name="925016"> </a><p></p><dt>The macros in sys_socket.h do the following:<p><a name="925034"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925019"> </a><strong>For...</strong></th><th><a name="925021"> </a><strong>The macros pass...</strong></th></tr><tr><td><a name="925023"> </a>reference number</td><td><a name="925025"> </a>AppNetRefnum (application global variable).</td></tr><tr><td><a name="925027"> </a>timeout</td><td><a name="925029"> </a><code>AppNetTimeout</code> (application global variable).</td></tr><tr><td><a name="925031"> </a>error code</td><td><a name="925033"> </a>Address of the application global errno.</td></tr></table><table><tr><td></table></div></p><a name="925036"> </a><p></p><dt>For example, consider the Berkeley sockets call socket, which is declared as:<dl><a name="925037"> </a><br><code>Int16 socket(Int16&nbsp;domain, Int16&nbsp;type, Int16&nbsp;protocol);</code><br><dl><a name="925038"> </a><p></p><dt>The equivalent net library call is <code>NetLibSocketOpen</code>, which is declared as:</dl><a name="925039"> </a><br><code>NetSocketRef NetLibSocketOpen(UInt16&nbsp;libRefnum, NetSocketAddrEnum&nbsp;domain, NetSocketTypeEnum&nbsp;type, Int16&nbsp;protocol, Int32&nbsp;timeout, Err*&nbsp;errP)</code><br><dl><a name="925040"> </a><p></p><dt>The macro for <code>socket</code> is:</dl><a name="925041"> </a><br><code>#define socket(domain,type,protocol) \</code><br></dl><dl><a name="925042"> </a><code>NetLibSocketOpen(AppNetRefnum, domain, type, protocol, AppNetTimeout, &amp;errno)</code><br></dl></dl><a name="925045"> </a><h3> Net Library Usage Steps</h3><dl><a name="925046"> </a><p></p><dt>In general, using the net library involves the steps listed below. The next several sections describe some of the steps in more detail. <a name="925047"> </a><p></p><dt>For an example of using the net library, see the example application <code>NetSample</code> in the <code>Palm OS Examples</code> directory. It exercises many of the net library calls.<p><a name="925048"> </a>	1.	 Obtain the net library's reference number.</p><p><a name="925049"> </a> Because the net library is a system library, all net library calls take the library's reference number as the first parameter. For this reason, your first step is to obtain the reference number and save it. See "<a href="NetworkCommunication.html#925080">Obtaining the Net Library's Reference Number</a>."</p><p><a name="925053"> </a>	2.	 Set up for using Berkeley sockets API. </p><p><a name="925054"> </a> You can either use the net library's native API or the Berkeley sockets API for the majority of what you do with the net library. If you're already familiar with Berkeley sockets API, you'll probably want to use it instead of the native API. If so, follow the steps in "<a href="NetworkCommunication.html#925100">Setting Up Berkeley Socket API</a>."</p><p><a name="925058"> </a>	3.	 If necessary, configure the net library the way you want it. </p><p><a name="925059"> </a> Typically, users set up their networking services by using the Network preferences panel. Most applications don't set up the networking services themselves; they simply access them through the net library preferences database. In rare instances, your application might need to perform some network configuration, and it usually should do so before the net library is open. See "<a href="NetworkCommunication.html#925114">Setup and Configuration Calls</a>."</p><p><a name="925063"> </a>	4.	 Open the net library right before the first network access.</p><a name="925064"> </a><p></p><dt>Because of the limited resources in the Palm OS environment, the net library was designed so that it only takes up extra memory from the system when an application actually needs to use its services. An Internet application must therefore inform the system when it needs to use the net library by opening the net library when it starts up and by closing it when it exits. See "<a href="NetworkCommunication.html#925417">Opening the Net Library</a>."<p><a name="925069"> </a>	5.	 Make calls to access the network. </p><a name="925070"> </a><p></p><dt>Once the net library has been opened, sockets can be opened and data sent to and received from remote hosts using either the Berkeley sockets API or the native net library API. See "<a href="NetworkCommunication.html#925537">Network I/O and Utility Calls</a>."<p><a name="925074"> </a>	6.	 Close the net library when you're finished with it. </p><p><a name="925077"> </a> Closing the net library frees up the resources. See "<a href="NetworkCommunication.html#925478">Closing the Net Library</a>."</p></dl><a name="925080"> </a><h3> Obtaining the Net Library's Reference Number</h3><dl><a name="925084"> </a><p></p><dt>To determine the reference number, call <a href="SystemManager.html#925491">SysLibFind</a>, passing the name of the net library, "<code>Net.lib</code>". In addition, if you intend to use Berkeley sockets API, save the reference number in the application global variable AppNetRefnum. <dl><a name="925086"> </a><br><code>err = SysLibFind("Net.lib", &amp;AppNetRefnum);</code><br></dl><dl><a name="925087"> </a><code>if (err) {/* error handling here */}</code><br><dl><a name="925088"> </a><p></p><dt>Remember that the net library requires Palm OS version 2.0 or later. If the <code>SysLibFind</code> call can't find the net library, it returns an error code. </dl></dl></dl><a name="925100"> </a><h3> Setting Up Berkeley Socket API</h3><dl><a name="925101"> </a><p></p><dt>To set up the use of Berkeley sockets API, do the following: <ul type="SQUARE"><a name="925103"> </a><br><li>Include the header file &lt;unix/sys_socket.h&gt;, provided with the Palm OS SDK.<br><a name="925105"> </a><br><li>Link your project with the module <code>NetSocket.c</code>, which declares and initializes three required global variables: AppNetTimeout, AppNetRefnum, and errno. <code>NetLibSocket.c</code> also contains the glue code necessary for a few of the Berkeley sockets functions. <br><a name="925109"> </a><br><li>As described in the previous section, assign the net library's reference number to the variable <code>AppNetRefnum</code>. <br><a name="925110"> </a><br><li>Adjust <code>AppNetTimeout</code>'s value if necessary. <br><dl><a name="925111"> </a><p></p><dt>This value represents the maximum number of system ticks to wait before a net library call expires. Most applications should adjust this timeout value and possibly adjust it for different sections of code. The following example sets the timeout value to 10 seconds. </dl></ul><dl><a name="925112"> </a><br><code>&nbsp&nbsp&nbsp AppNetTimeout = SysTicksPerSecond() * 10;</code><br></dl></dl><a name="925114"> </a><h3> Setup and Configuration Calls</h3><dl><a name="925116"> </a><p></p><dt>The setup and configuration API calls of the net library are normally only used by the Network preferences panel. This includes calls to set IP addresses, host name, domain name, login script, interface settings, and so on. Each setup and configuration call saves its settings in the net library preferences database in nonvolatile storage for later retrieval by the runtime calls. <a name="925118"> </a><p></p><dt>In rare instances, an application might need to perform setup and configuration itself. For example, some applications might allow users to select a particular "service" before trying to establish a connection. Such applications present a pick list of service names and allow the user to select a service name. This functionality is provided via the Network preferences panel. The panel provides launch codes (defined in <code>SystemMgr.h</code>) that allow an application to present a list of possible service names to let the end user pick one. The preferences panel then makes the necessary net library setup and configuration calls to set up for that particular service.<a name="925120"> </a><p></p><dt>Usually, the setup and configuration calls are made while the library is closed. A subset of the calls can also be issued while the library is open and will have real-time effects on the behavior of the library. <a href="NetLibrary.html#924903">Chapter 54, </a><a href="NetLibrary.html#924905">"Net Library"</a> in <em>Palm OS SDK Reference</em>, describes the behavior of each call in more detail. </dl><a name="925128"> </a><h4> Settings for Interface Selection</h4><dl><a name="925132"> </a><p></p><dt>As you learned in the section "<a href="NetworkCommunication.html#924976">About the Net Library</a>," the net library uses one or more network interfaces to abstract low-level networking protocols. The user specifies which network interface to use in the Network preference panel. <a name="925134"> </a><p></p><dt>You can also use net library calls to specify which interface(s) should be used:<ul type="SQUARE"><a name="925139"> </a><br><li><code><a href="NetLibrary.html#926252"></code>NetLibIFAttach<code></a></code> attaches an interface to the library so that it will be used when and if the library is open.<br><a name="925144"> </a><br><li><code><a href="NetLibrary.html#926287"></code>NetLibIFDetach<code></a></code> detaches an interface from the library. <br><a name="925149"> </a><br><li><code><a href="NetLibrary.html#926358"></code>NetLibIFGet<code></a></code> returns an interface's creator and instance number. <br></ul><a name="925150"> </a><p></p><dt>Unlike most net library functions, these functions can be called while the library is open or closed. If the library is open, the specific interface is attached or detached in real time. If the library is closed, the information is saved in preferences and used the next time the library is opened. <a name="925151"> </a><p></p><dt>Each interface is identified by a creator and an instance number. You need these values if you want to attach or detach an interface or to query or set interface settings. You use <code>NetLibIFGet</code> to obtain this information. <code>NetLibIFGet</code> takes four parameters: the net library's reference number, an index into the library's interface list, and addresses of two variables where the creator and instance number are returned. <a name="925152"> </a><p></p><dt>The creator is one of the following values:<ul type="SQUARE"><a name="925154"> </a><br><li><code>netIFCreatorLoop</code> (Loopback network)<br><a name="925156"> </a><br><li><code>netIFCreatorSLIP</code> (SLIP network)<br><a name="925158"> </a><br><li><code>netIFCreatorPPP</code> (PPP network)<br></ul><a name="925164"> </a><p></p><dt><code></code>If you know which interface you want to obtain information about, you can iterate through the network interface list, calling <code>NetLibIFGet</code> with successive index values until the interface with the creator value you need is returned. </dl><a name="925166"> </a><h4> Interface Specific Settings</h4><dl><a name="925167"> </a><p></p><dt>The net library configuration is structured so that network interface- specific settings can be specified for each network interface independently. These interface specific settings are called IF settings and are set and retrieved through the <code><a href="NetLibrary.html#926396"></code>NetLibIFSettingGet<code></a></code> and <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> calls. <ul type="SQUARE"><a name="925178"> </a><br><li>The <code><a href="NetLibrary.html#926396"></code>NetLibIFSettingGet<code></a></code> call takes a setting ID as a parameter along with a buffer pointer and buffer size for the return value of the setting. Some settings, like login script, are of variable size so the caller must be prepared to allocate a buffer large enough to retrieve the entire setting. (<code>NetLibIFSettingGet</code> returns the required size if you pass <code>NULL</code> for the buffer. See the <code>NetLibIFSettingGet </code>description in the reference documentation for more information.) <br><a name="925183"> </a><br><li>The <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> call also takes a setting ID as a parameter along with a pointer to the new setting value and the size of the new setting. <br><dl><a name="925184"> </a><p></p><dt>If you're using <code>NetLibIFSettingSet</code> to set the login script, see the next section. </dl></ul><a name="925185"> </a><p></p><dt>For an example of using these functions, see the <code>NetSample</code> example application in the <code>Palm OS Examples</code> directory. The function <code>CmdSettings</code> in the file <code>CmdInfo.c</code>, for example, shows how to loop through and obtain information about all of the network interfaces. </dl><a name="925186"> </a><h4> Setting an Interface's Login Script</h4><dl><a name="934137"> </a><p></p><dt>The <code>netIFSettingLoginScript</code> setting is used to store the login script for an interface. The login script is generated either from the script that the user enters in the Network preferences panel or from a script file that is downloaded onto the device during a HotSync<sup>&#174;</sup> operation. The format of the script is rigid; if a syntactically incorrect login script is presented to the net library, the results are unpredictable. The basic format is a series of null-terminated command lines followed by a null byte at the end of the script. Each command line has the format:<dl><a name="925188"> </a><br><code>&lt;command-byte&gt; [&lt;parameter&gt;]</code><br><dl><a name="925189"> </a><p></p><dt>where the command byte is the first character in the line and there is 1 and only 1 space between the command byte and the parameter string. <a href="NetworkCommunication.html#928767">Table 11.1</a> lists the possible commands.<p><a name="925290"> </a> </p><p><div> <table border="3"><caption><B><a name="928767"> </a><h4>Table 11.1	 Login Script Commands&nbsp;</h4></B></caption><tr><th><a name="925197"> </a><strong>Function</strong></th><th><a name="925199"> </a><strong>Command</strong></th><th><a name="925201"> </a><strong>Parameter</strong></th><th><a name="925203"> </a><strong>Example</strong></th></tr><tr><td><a name="925205"> </a>Send </td><td><a name="925207"> </a><code>s</code> </td><td><a name="925209"> </a>string</td><td><a name="925211"> </a><code>s go PPP</code> </td></tr><tr><td><a name="925213"> </a>Wait for</td><td><a name="925215"> </a><code>w</code> </td><td><a name="925217"> </a>string</td><td><a name="925219"> </a><code>w password:</code> </td></tr><tr><td><a name="925221"> </a>Delay</td><td><a name="925223"> </a><code>d</code> </td><td><a name="925225"> </a>seconds</td><td><a name="925227"> </a><code>d 1</code> </td></tr><tr><td><a name="925229"> </a>Get IP</td><td><a name="925231"> </a><code>g</code> </td><td><a name="925233"> </a></td><td><a name="925235"> </a><code>g</code> </td></tr><tr><td><a name="925237"> </a>Prompt</td><td><a name="925239"> </a><code>a</code> </td><td><a name="925241"> </a>string</td><td><a name="925243"> </a><code>a Enter Name:</code> </td></tr><tr><td><a name="925245"> </a>Wait for prompt</td><td><a name="925247"> </a><code>f </code></td><td><a name="925249"> </a>string</td><td><a name="925251"> </a><code>f ID:</code></td></tr><tr><td><a name="925253"> </a>Send CR</td><td><a name="925255"> </a><code>s</code> </td><td><a name="925257"> </a>string</td><td><a name="925259"> </a><code>s ^N</code></td></tr><tr><td><a name="925261"> </a>Send UserID</td><td><a name="925263"> </a><code>s</code> </td><td><a name="925265"> </a>string</td><td><a name="925267"> </a><code>s jdoe </code></td></tr><tr><td><a name="925269"> </a>Send Password</td><td><a name="925271"> </a><code>s</code> </td><td><a name="925273"> </a>string </td><td><a name="925275"> </a>s <em>mypassword</em></td></tr><tr><td><a name="925277"> </a>Plugin command<a href="#925283"><sup>1</sup></a></td><td><a name="925285"> </a><code>sp</code> </td><td><a name="925287"> </a>string </td><td><a name="925289"> </a>sp <em>plugin</em><code>:</code><em>cmd</em><code>:</code><em>arg</em></td></tr></table><table><tr><td><sup>1</sup><p><a name="925283"> </a> See "<a href="NetworkCommunication.html#926013">Extending the Network Login Script Support</a>."</p></table></div></p><a name="925291"> </a><p></p><dt>The parameter string to the send (<code>s</code>) command can contain the escape sequences shown in <a href="NetworkCommunication.html#928790">Table 11.2</a>.<p><a name="925342"> </a> </p><p><div> <table border="3"><caption><B><a name="928790"> </a><h4>Table 11.2	 Send Command Escape Sequences&nbsp;</h4></B></caption><tr><td><a name="925299"> </a>$USERID</td><td><a name="925301"> </a>substitutes user name</td></tr><tr><td><a name="925303"> </a>$PASSWORD</td><td><a name="925305"> </a>substitutes password</td></tr><tr><td><a name="925307"> </a>$DBUSERID</td><td><a name="925309"> </a>substitutes dialback user name</td></tr><tr><td><a name="925311"> </a>$DBPASSWORD</td><td><a name="925313"> </a>substitutes dialback password</td></tr><tr><td><a name="925315"> </a> ^c</td><td><a name="925317"> </a>if c is `@' -&gt; `_', then byte value 0 -&gt; 31 <br>else if c is `a' -&gt; `z', then byte value 1 -&gt; 26<br>else c </td></tr><tr><td><a name="925319"> </a>&lt;cr&gt;</td><td><a name="925321"> </a>carriage return (0x0D)</td></tr><tr><td><a name="925323"> </a>&lt;lf&gt;</td><td><a name="925325"> </a>line feed (0x0A)</td></tr><tr><td><a name="925327"> </a>\"</td><td><a name="925329"> </a>"</td></tr><tr><td><a name="925331"> </a> \^</td><td><a name="925333"> </a>^</td></tr><tr><td><a name="925335"> </a> \&lt;</td><td><a name="925337"> </a>&lt;</td></tr><tr><td><a name="925339"> </a> \\</td><td><a name="925341"> </a>\</td></tr></table><table><tr><td></table></div></p><a name="925344"> </a><p></p><dt>Note also that login scripts can be created on a desktop computer and then installed onto the device during synchronization. The script commands are inspired by the Windows dial-up scripting command language for dial-up networking. For documentation from Microsoft, search for the file <code>Script.doc</code> in the <code>Windows</code> folder. The Network preferences panel on Palm OS supports the following subset of commands: <a name="925345"> </a><p></p><dt><code>set serviceName<br>set userName <br>set password <br>set phoneNumber <br>set primaryDNS<br>set secondaryDNS <br>set ipAddr <br>set closewait <br>set inactivityTimeout <br>set establishmentTimeout <br>set protocol <br>set dynamicIP <br>waitfor<br>transmit <br>getip <br>delay <br>prompt <br>waitforprompt<br>plugin "</code><em>pluginname</em><code>:</code><em>cmd</em><code>[:</code><em>arg</em><code>]" </code><a name="925346"> </a><p></p><dt>The <code>plugin</code> command is a Palm OS-specific extension used to perform a command defined in a plugin. See <a href="NetworkCommunication.html#926013">"Extending the Network Login Script Support"</a> for more information on plugins. <a name="925350"> </a><p></p><dt>Create a script file with the extension <code>.pnc</code> or <code>.scp</code> and place it in the user's install directory. The network conduit will download it to the device during the next HotSync operation. Each script file should contain only one service definition. </dl></dl></dl><a name="925351"> </a><h4> General Settings</h4><dl><a name="925352"> </a><p></p><dt>In addition to the interface-specific settings, there's a class of settings that don't apply to any one particular interface. These general settings are set and retrieved through the <code><a href="NetLibrary.html#927759"></code>NetLibSettingGet<code></a></code> and <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code> calls. These calls take setting ID, buffer pointer, and buffer size parameters. </dl><a name="925417"> </a><h3> Opening the Net Library</h3><dl><a name="925422"> </a><p></p><dt>Call <code><a href="NetLibrary.html#927163"></code>NetLibOpen<code></a></code> to open the net library, passing the reference number you retrieved through <a href="SystemManager.html#925491">SysLibFind</a>. Before the net library is opened, most calls issued to it fail with a netErrNotOpen error code. <dl><a name="925426"> </a><br><code>err = NetLibOpen(AppNetRefnum, &amp;ifErrs);</code><br></dl><dl><a name="925427"> </a><code>if (err || ifErrs) {/* error handling here */}</code><br><dl><a name="925428"> </a><p></p><dt>Multiple applications can have the library open at a time, so the net library may already be open when <code>NetLibOpen</code> is called. If so, the function increments the library's <strong>open count</strong>, which keeps track of how many applications are accessing it, and returns immediately. (You can retrieve the open count with the function <code><a href="NetLibrary.html#927306"></code>NetLibOpenCount<code></a></code>.)<a name="925432"> </a><p></p><dt>If the net library is not already open, NetLibOpen starts up the net protocol stack task, allocates memory for internal use by the net library, and brings up the network connection. Most likely, the user has configured the Palm OS device to establish a SLIP or PPP connection through a modem and in this type of setup, <code>NetLibOpen</code> dials up the modem and establishes the connection before returning. <a name="925434"> </a><p></p><dt>If any of the attached network interfaces (such as SLIP or PPP) fail to come up, the final parameter (<code>ifErrs</code> in the example above) contains the error number of the first interface that encountered a problem.<a name="925435"> </a><p></p><dt>It's possible, and quite likely, that the net library will be able to open even though one or more interfaces failed to come up (due to bad modem settings, service down, etc.). Some applications may therefore wish to close the net library using <a href="NetLibrary.html#925462">NetLibClose</a> if the interface error parameter is non-zero and display an appropriate message for the user. If an application needs more detailed information, e.g. which interface(s) in particular failed to come up, it can loop through each of the attached interfaces and ask each one if it is up or not. For example:</dl></dl><dl><a name="925439"> </a><br><code>UInt16 index, ifInstance;</code><br></dl><dl><a name="925440"> </a><code>UInt32 ifCreator;</code><br><a name="925441"> </a><code>Err err;</code><br><a name="925442"> </a><code>UInt8 up;</code><br><a name="925443"> </a><code>Char ifName[32];</code><br><a name="925444"> </a><code>...</code><br><a name="925445"> </a><code>for (index = 0; 1; index++) {</code><br><a name="925446"> </a><code>&nbsp&nbsp&nbsp err = NetLibIFGet(AppNetRefnum, index, </code><br><a name="925447"> </a><code>&nbsp&nbsp&nbsp 	 &amp;ifCreator, &amp;ifInstance);</code><br><a name="925448"> </a><code>&nbsp&nbsp&nbsp if (err) break;</code><br><a name="925449"> </a><code></code><br><a name="925450"> </a><code>&nbsp&nbsp&nbsp settingSize = sizeof(up);</code><br><a name="925451"> </a><code>&nbsp&nbsp&nbsp err = NetLibIFSettingGet(AppNetRefnum, </code><br><a name="925452"> </a><code>&nbsp&nbsp&nbsp 	 ifCreator, ifInstance, netIFSettingUp, &amp;up, </code><br><a name="925453"> </a><code>&nbsp&nbsp&nbsp 	 &amp;settingSize);</code><br><a name="925454"> </a><code>&nbsp&nbsp&nbsp if (err || up) continue;</code><br><a name="925455"> </a><code>&nbsp&nbsp&nbsp settingSize = 32;</code><br><a name="925456"> </a><code>&nbsp&nbsp&nbsp err = NetLibIFSettingGet(AppNetRefnum, <br>	 	 ifCreator, ifInstance, netIFSettingName, <br>	 	 ifName, &amp;settingSize);</code><br><a name="925457"> </a><code>&nbsp&nbsp&nbsp if (err) continue;</code><br><a name="925458"> </a><code></code><br><a name="925459"> </a><code>&nbsp&nbsp&nbsp //display interface didn't come up message</code><br><a name="925460"> </a><code>}</code><br><a name="925461"> </a><code>NetLibClose(AppNetRefnum, true);</code><br></dl></dl><a name="925478"> </a><h3> Closing the Net Library</h3><dl><a name="925480"> </a><p></p><dt>Before an application quits, or if it no longer needs to do network   I/O, it should call <code><a href="NetLibrary.html#925462"></code>NetLibClose<code></a></code>. <dl><a name="925484"> </a><br><code>err = NetLibClose(AppNetRefnum, false);</code><br><dl><a name="925485"> </a><p></p><dt><code>NetLibClose</code> simply decrements the open count. The <code>false</code> parameter specifies that if the open count has reached 0, the net library should not immediately close. Instead, <code>NetLibClose</code> schedules a timer to shut down the net library unless another <code><a href="NetLibrary.html#927163"></code>NetLibOpen<code></a></code> is issued before the timer expires. When the net library's open count is 0 but its timer hasn't yet expired, it's referred to as being in the <strong>close-wait state</strong>. <a name="925490"> </a><p></p><dt>Just how long the net library waits before closing is set by the user in the Network preferences panel. This timeout value allows users to quit from one network application and launch another application within a certain time period without having to wait for another network connection establishment. <a name="925491"> </a><p></p><dt>If <code>NetLibOpen</code> is called before the close timer expires, it simply cancels the timer and marks the library as fully open with an open count of 1 before returning. If the timer expires before another NetLibOpen is issued, all existing network connections are brought down, the net protocol stack task is terminated, and all memory allocated for internal use by the net library is freed. <a name="925492"> </a><p></p><dt>It's recommended that you allow the net library to enter the close-wait state. However, if you do need the net library to close immediately, you can do one of two things:<ul type="SQUARE"><a name="925493"> </a><br><li>Set <code>NetLibClose</code>'s second parameter to <code>true</code>. This parameter specifies whether the library should close immediately or not. <br><a name="925497"> </a><br><li>Call <code><a href="NetLibrary.html#925959"></code>NetLibFinishCloseWait<code></a></code>. This function checks the net library to see if it's in the close-wait state and if so, performs an immediate close. <br></ul></dl></dl></dl><a name="925499"> </a><h3> Version Checking</h3><dl><a name="925504"> </a><p></p><dt>Besides using <a href="SystemManager.html#925491">SysLibFind</a> to determine if the net library is installed, an application can also look for the net library version feature. This feature is only present if the net library is installed. This feature can be used to get the version number of the net library as follows: <dl><a name="925505"> </a><br><code>UInt32* version;</code><br></dl><dl><a name="925506"> </a><code>err = FtrGet(netFtrCreator, netFtrNumVersion,</code><br><a name="925507"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 	 	 &amp;version);</code><br><dl><a name="925508"> </a><p></p><dt>If the net library is not installed, FtrGet returns a non-zero result code.<a name="925530"> </a><p></p><dt>The version number is encoded in the format <code>0xMMmfsbbb</code>, where: <p><a name="928809"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925511"> </a>MM</td><td><a name="925513"> </a>major version </td></tr><tr><td><a name="925515"> </a>m</td><td><a name="925517"> </a>minor version</td></tr><tr><td><a name="925519"> </a> f </td><td><a name="925521"> </a>bug fix level</td></tr><tr><td><a name="925523"> </a> s </td><td><a name="925525"> </a>stage: 3-release, 2-beta, 1-alpha, 0-development</td></tr><tr><td><a name="925527"> </a>bbb </td><td><a name="925529"> </a>build number for non-releases </td></tr></table><table><tr><td></table></div></p><a name="925531"> </a><p></p><dt>For example:<a name="925532"> </a><p></p><dt>	 V1.1.2b3 would be encoded as 0x01122003<a name="925533"> </a><p></p><dt>	 V2.0a2 would be encoded as 0x02001002<a name="925534"> </a><p></p><dt>	 V1.0.1 would be encoded as 0x01013000<a name="925535"> </a><p></p><dt>This document describes version 2.01 of the net library (0x02013000). </dl></dl></dl><a name="925537"> </a><h3> Network I/O and Utility Calls</h3><dl><a name="925538"> </a><p></p><dt>For the network I/O and utility calls, you can either make calls using Berkeley sockets API or using the net library's native API. <a name="925539"> </a><p></p><dt>Several books have been published that describe how to use Berkeley sockets API to perform network communication. Net library API closely mirrors Berkeley sockets API in this regard. However, you should keep in mind these important differences between using networking I/O on a typical computer and using net library on a Palm OS device:<ul type="SQUARE"><a name="925541"> </a><br><li>You can open a maximum of four sockets at once in the net library. This is to keep net library's memory requirements to a minimum. <br><a name="925542"> </a><br><li>When you try to send a large block of data, the net library automatically buffers only a portion of that block because of the limited available dynamic memory. The function call returns the number of bytes of data that it actually transmitted. You must check the return value and if there's more data to send, call the function again until the transmission is finished. <br><a name="925543"> </a><br><li>If you expect to also receive data during a large transmission, you should send a smaller block, then read back whatever is available to read before sending the next block. In this way, the amount of memory in the dynamic heap that must be used to buffer data waiting to send out and data waiting to be read back in by the application is kept to a minimum.<br></ul><a name="925544"> </a><p></p><dt>For more information, see the following:<ul type="SQUARE"><a name="925548"> </a><br><li>The next section, "<a href="NetworkCommunication.html#925558">Berkeley Sockets API Functions</a>," provides tables that list the supported Berkeley sockets calls, the corresponding native net library call, and gives a brief description of what each call does. <br><a name="925555"> </a><br><li><a href="NetLibrary.html#924903">Chapter 54, </a><a href="NetLibrary.html#924905">"Net Library"</a> of the <em>Palm OS SDK Reference</em> provides detailed descriptions of each net library call. Where applicable, it gives the equivalent sockets API call for each net library native call. <br><a name="925556"> </a><br><li>The <code>NetSample</code> example application in the <code>Palm OS Examples</code> directory shows how to use the Berkeley sockets API in Palm OS applications. <br></ul></dl><a name="925558"> </a><h3> Berkeley Sockets API Functions</h3><dl><a name="925559"> </a><p></p><dt>This section provides tables that list the functions in the Berkeley sockets API that are supported by the net library. In some cases, the calls have limited functionality from what's found in a full implementation of the sockets API and these limitations are described here. </dl><a name="925561"> </a><h4> Socket Functions</h4><p><a name="925823"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925564"> </a><strong>Berkeley Sockets Function</strong></th><th><a name="925566"> </a><strong>Net Library Function</strong></th><th><a name="925568"> </a><strong>Description</strong></th></tr><tr><td><a name="925570"> </a>accept </td><td><a name="925575"> </a><code><a href="NetLibrary.html#927971"></code>NetLibSocketAccept<code></a></code></td><td><a name="925577"> </a>Accepts a connection from a stream-based socket.</td></tr><tr><td><a name="925580"> </a><code>bind</code> </td><td><a name="925585"> </a><code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code></td><td><a name="925587"> </a>Binds a socket to a local address.</td></tr><tr><td><a name="925590"> </a><code>close</code></td><td><a name="925595"> </a><code><a href="NetLibrary.html#928143"></code>NetLibSocketClose<code></a></code></td><td><a name="925597"> </a>Closes a socket.</td></tr><tr><td><a name="925600"> </a><code>connect</code> </td><td><a name="925605"> </a><code><a href="NetLibrary.html#928189"></code>NetLibSocketConnect<code></a></code></td><td><a name="925607"> </a>Connects a socket to a remote endpoint to establish a connection.</td></tr><tr><td><a name="925610"> </a><code>fcntl</code> </td><td><a name="925615"> </a><code><a href="NetLibrary.html#928465"></code>NetLibSocketOptionSet<code></a></code><a name="925619"> </a><code></code><code><a href="NetLibrary.html#928409"></code>NetLibSocketOptionGet<code></a><br>(...,netSocketOptSockNonBlocking,...)</code></td><td><a name="925621"> </a>Supported only for socket <code>refnum</code>s and the only commands it supports are <code>F_SETFL</code> and <code>F_GETFL</code>. The commands can be used to put a socket into non-blocking mode by setting the <code>FNDELAY</code> flag in the argument parameter appropriately -- all other flags are ignored. The <code>F_SETFL</code>, <code>F_GETFL</code>, and <code>FNDELAY</code> constants are defined in <code>&lt;unix/unix_fcntl.h&gt;</code>. </td></tr><tr><td><a name="925624"> </a><code>getpeername</code> </td><td><a name="925629"> </a><code><a href="NetLibrary.html#928032"></code>NetLibSocketAddr<code></a></code></td><td><a name="925631"> </a>Gets the remote socket address for a connection.</td></tr><tr><td><a name="925634"> </a><code>getsockname</code> </td><td><a name="925639"> </a><code><a href="NetLibrary.html#928032"></code>NetLibSocketAddr<code></a></code></td><td><a name="925641"> </a>Gets the local socket address of a connection. <a name="925642"> </a><a name="925643"> </a><a name="925644"> </a></td></tr><tr><td><a name="925647"> </a><code>getsockopt</code> </td><td><a name="925652"> </a><code><a href="NetLibrary.html#928409"></code>NetLibSocketOptionGet<code></a></code></td><td><a name="925654"> </a>Gets a socket's control options. Only the following options are implemented:</td></tr><tr><td><a name="925656"> </a></td><td><a name="925658"> </a></td><td><ul type="SQUARE"><a name="925661"> </a><br><li><code>TCP_NODELAY</code><br><dl><a name="925662"> </a><p></p><dt>Allows the application to disable the TCP output buffering algorithm so that TCP sends small packets as soon as possible. This constant is defined in <code>&lt;unix/netinet_tcp.h&gt;</code>.</dl></ul></td></tr><tr><td><a name="925664"> </a></td><td><a name="925666"> </a></td><td><ul type="SQUARE"><a name="925669"> </a><br><li><code>TCP_MAXSEG</code><br><dl><a name="925670"> </a><p></p><dt>Get the TCP maximum segment size. This constant is defined in <code>&lt;unix/netinet_tcp.h&gt;</code>.</dl></ul></td></tr><tr><td><a name="925672"> </a></td><td><a name="925674"> </a></td><td><ul type="SQUARE"><a name="925677"> </a><br><li><code>SO_KEEPALIVE</code><br><dl><a name="925678"> </a><p></p><dt>Enables periodic transmission of probe segments when there is no data exchanged on a connection. If the remote endpoint doesn't respond, the connection is considered broken, and <code>so_error</code> is set to <code>ETIMEOUT</code>.</dl></ul></td></tr><tr><td><a name="925680"> </a></td><td><a name="925682"> </a></td><td><ul type="SQUARE"><a name="925685"> </a><br><li><code>SO_LINGER</code><br><dl><a name="925686"> </a><p></p><dt>Specifies what to do with the unsent data when a socket is closed. It uses the <code>linger</code> structure defined in <code>&lt;unix/sys_socket.h&gt;</code>.</dl></ul></td></tr><tr><td><a name="925688"> </a></td><td><a name="925690"> </a></td><td><ul type="SQUARE"><a name="925693"> </a><br><li><code>SO_ERROR</code><br><dl><a name="925694"> </a><p></p><dt>Returns the current value of the variable <code>so_error</code>, defined in <code>&lt;unix/sys_socketvar.h&gt;</code></dl></ul></td></tr><tr><td><a name="925696"> </a></td><td><a name="925698"> </a></td><td><ul type="SQUARE"><a name="925701"> </a><br><li><code>SO_TYPE</code><br><dl><a name="925702"> </a><p></p><dt>Returns the socket type to the caller. </dl></ul></td></tr><tr><td><a name="925705"> </a><code>listen</code> </td><td><a name="925710"> </a><code><a href="NetLibrary.html#928246"></code>NetLibSocketListen<code></a></code></td><td><a name="925712"> </a>Sets up the socket to listen for incoming connection requests. The queue size is quietly limited to 1. (Higher values are ignored.)</td></tr><tr><td><a name="925716"> </a><code>read</code>, <code>recv</code>, <code>recvmsg</code>, <code>recvfrom</code> </td><td><a name="925723"> </a><code><a href="NetLibrary.html#927329"></code>NetLibReceive<code></a><br><a href="NetLibrary.html#927400"></code>NetLibReceivePB<code></a></code></td><td><a name="925728"> </a>Read data from a socket. The <code>recv</code>, <code>recvmsg</code>, and <code>recvfrom</code> calls support the <code>MSG_PEEK</code> flag but not the <code>MSG_OOB</code> or <code>MSG_DONTROUTE</code> flags.</td></tr><tr><td><a name="925731"> </a><code>select</code> </td><td><a name="925736"> </a><code><a href="NetLibrary.html#927500"></code>NetLibSelect<code></a></code></td><td><a name="925738"> </a>Allows the application to block on multiple I/O events. The system will wake up the application process when any of the multiple I/O events occurs. </td></tr><tr><td><a name="925740"> </a></td><td><a name="925742"> </a></td><td><a name="925744"> </a>This function uses the <code>timeval</code> structure defined in <code>&lt;unix/sys_time.h&gt;</code> and the <code>fd_set</code> structure defined in <code>sys/types.h</code>.</td></tr><tr><td><a name="925746"> </a></td><td><a name="925748"> </a></td><td><a name="925750"> </a>Also associated with this function are the following four macros defined in <code>&lt;unix/sys_types.h&gt;:</code><ul type="SQUARE"><a name="925751"> </a><br><li><code>FD_ZERO</code><br><a name="925752"> </a><br><li><code>FD_SET</code><br><a name="925753"> </a><br><li><code>FD_CLR</code><br><a name="925754"> </a><br><li><code>FD_ISSET</code><br></ul></td></tr><tr><td><a name="925756"> </a></td><td><a name="925758"> </a></td><td><dl><a name="925760"> </a><p></p><dt>Besides socket descriptors, this function also works with the "stdin" descriptor, <code>sysFileDescStdIn</code>. This descriptor is marked as ready for input whenever a user or system event is available in the event queue. This includes any event that would be returned by <code>EvtGetEvent</code>. No other descriptors besides <code>sysFileDescStdIn</code> and socket <code>refnum</code>s are allowed.</dl></td></tr><tr><td><a name="925765"> </a><code>send</code>, <code>sendmsg</code>, <code>sendto</code> </td><td><a name="925771"> </a><code><a href="NetLibrary.html#927575"></code>NetLibSend<code></a><br><a href="NetLibrary.html#927671"></code>NetLibSendPB<code></a></code></td><td><a name="925776"> </a>These functions write data to a socket. These calls, unlike the <code>recv</code> calls, <strong>do</strong> support the <code>MSG_OOB</code> flag. The <code>MSG_PEEK</code> flag is not applicable and the <code>MSG_DONTROUTE</code> flag is not supported.</td></tr><tr><td><a name="925779"> </a><code>setsockopt</code> </td><td><a name="925784"> </a><code><a href="NetLibrary.html#928465"></code>NetLibSocketOptionSet<code></a></code></td><td><a name="925786"> </a>This function sets control options of a socket. Only the following options are allowed:<ul type="SQUARE"><a name="925788"> </a><br><li><code>TCP_NODELAY</code><br><a name="925790"> </a><br><li><code>SO_KEEPALIVE</code><br><a name="925792"> </a><br><li><code>SO_LINGER</code><br></ul></td></tr><tr><td><a name="925795"> </a><code>shutdown</code> </td><td><a name="925800"> </a><code><a href="NetLibrary.html#928827"></code>NetLibSocketShutdown<code></a></code></td><td><a name="925802"> </a>Similar to <code>close()</code>; however, it gives the caller more control over a full-duplex connection.</td></tr><tr><td><a name="925805"> </a><code>socket</code> </td><td><a name="925810"> </a><code><a href="NetLibrary.html#928319"></code>NetLibSocketOpen<code></a></code></td><td><a name="925812"> </a>Creates a socket for communication.The only valid address family is <code>AF_INET</code>. The only valid socket types are <code>SOCK_STREAM,</code> <code>SOCK_DGRAM</code>, and in Palm OS version 3.0 and higher, <code>SOCK_RAW</code>. The protocol parameter should be set to 0.</td></tr><tr><td><a name="925815"> </a><code>write</code> </td><td><a name="925820"> </a><code><a href="NetLibrary.html#927575"></code>NetLibSend<code></a></code></td><td><a name="925822"> </a>Writes data to a socket.</td></tr></table><table><tr><td></table></div></p><a name="925825"> </a><h4> Supported Network Utility Functions</h4><p><a name="925923"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925828"> </a><strong>Berkeley Sockets Function</strong></th><th><a name="925830"> </a><strong>Net Library Function</strong></th><th><a name="925832"> </a><strong>Description</strong></th></tr><tr><td><a name="925835"> </a><code>getdomainname</code> </td><td><a name="925840"> </a><code><a href="NetLibrary.html#928409"></code>NetLibSocketOptionGet<code></a>(..,<br>netSettingDomainName,...)</code></td><td><a name="925842"> </a>Returns the domain name of the local host.</td></tr><tr><td><a name="925845"> </a><code>gethostbyaddr</code> </td><td><a name="925850"> </a><code><a href="NetLibrary.html#925980"></code>NetLibGetHostByAddr<code></a></code></td><td><a name="925852"> </a>Looks up host information given the host's IP address. It returns a <code>hostent</code> structure, as defined in <code>&lt;netdb.h&gt;</code>.</td></tr><tr><td><a name="925855"> </a><code>gethostbyname</code> </td><td><a name="925860"> </a><code><a href="NetLibrary.html#926060"></code>NetLibGetHostByName<code></a></code></td><td><a name="925862"> </a>Looks up host information given the host's name. It returns a <code>hostent</code> structure which is defined in <code>&lt;netdb.h&gt;</code>.</td></tr><tr><td><a name="925865"> </a><code>gethostname</code> </td><td><a name="925870"> </a><code><a href="NetLibrary.html#927759"></code>NetLibSettingGet<code></a>(..,<br>netSettingHostName,<br>...)</code></td><td><a name="925872"> </a>Returns the name of the local host.</td></tr><tr><td><a name="925875"> </a><code>getservbyname</code> </td><td><a name="925880"> </a><code><a href="NetLibrary.html#926212"></code>NetLibGetServByName<code></a></code></td><td><a name="925882"> </a>Returns a <code>servent</code> structure, defined in <code>&lt;netdb.h&gt;</code> given a service name.</td></tr><tr><td><a name="925885"> </a><code>gettimeofday</code> </td><td><a name="925887"> </a>glue code using <code><a href="DateAndTimeManager.html#925140"></code>TimGetSeconds<code></a></code></td><td><a name="925892"> </a>Returns the current date and time.</td></tr><tr><td><a name="925895"> </a><code>setdomainname</code> </td><td><a name="925900"> </a><code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a>(..,<br>netSettingDomainName,...)</code></td><td><a name="925902"> </a>Sets the domain name of the local host.</td></tr><tr><td><a name="925905"> </a><code>sethostname</code> </td><td><a name="925910"> </a><code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a>(..,<br>netSettingHostName,<br>...)</code></td><td><a name="925912"> </a>Sets the name of the local host.</td></tr><tr><td><a name="925915"> </a><code>settimeofday</code> </td><td><a name="925917"> </a>glue code using <code><a href="DateAndTimeManager.html#925185"></code>TimSetSeconds<code></a></code> </td><td><a name="925922"> </a>Sets the current date and time.</td></tr></table><table><tr><td></table></div></p><a name="925925"> </a><h4> Supported Byte Ordering Macros</h4><dl><a name="925926"> </a><p></p><dt>The byte ordering macros are defined in &lt;unix/netinet_in.h&gt;. They convert an integer between network byte order and the host byte order. <p><a name="925952"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925929"> </a><strong>Berkeley<br>Sockets<br>Macro</strong></th><th><a name="925931"> </a><strong>Description</strong></th></tr><tr><td><a name="925934"> </a><code>htonl</code> </td><td><a name="925936"> </a>Converts a 32-bit integer from host byte order to network byte order.</td></tr><tr><td><a name="925939"> </a><code>htons</code> </td><td><a name="925941"> </a>Converts a 16-bit integer from host byte order to network byte order.</td></tr><tr><td><a name="925944"> </a><code>ntohl</code> </td><td><a name="925946"> </a>Converts a 32-bit integer from network byte order to host byte order.</td></tr><tr><td><a name="925949"> </a><code>ntohs</code> </td><td><a name="925951"> </a>Converts a 16-bit integer from network byte order to host byte order.</td></tr></table><table><tr><td></table></div></p></dl><a name="925954"> </a><h4> Supported Network Address Conversion Functions</h4><dl><a name="925955"> </a><p></p><dt>The network address conversion functions are declared in the <code>&lt;unix/arpa_inet.h&gt;</code> header file. They convert a network address from one format to another, or manipulate parts of a network address.<p><a name="926011"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925958"> </a><strong>Berkeley Sockets Function</strong></th><th><a name="925960"> </a><strong>Net Library Function</strong></th><th><a name="925962"> </a><strong>Description</strong></th></tr><tr><td><a name="925965"> </a><code>inet_addr</code> </td><td><a name="925970"> </a><code><a href="NetLibrary.html#925420"></code>NetLibAddrAToIN<code></a></code></td><td><a name="925972"> </a>Converts an IP address from dotted decimal format to 32-bit binary format. </td></tr><tr><td><a name="925975"> </a><code>inet_network</code> </td><td><a name="925977"> </a>glue code</td><td><a name="925979"> </a>Converts an IP network number from a dotted decimal format to a 32-bit binary format.</td></tr><tr><td><a name="925982"> </a><code>inet_makeaddr</code> </td><td><a name="925984"> </a>glue code</td><td><a name="925986"> </a>Returns an IP address in an <code>in_addr</code> structure given an IP network number and an IP host number in 32-bit binary format.</td></tr><tr><td><a name="925989"> </a><code>inet_lnaof</code> </td><td><a name="925991"> </a>glue code</td><td><a name="925993"> </a>Returns the host number part of an IP address.</td></tr><tr><td><a name="925996"> </a><code>inet_netof</code> </td><td><a name="925998"> </a>glue code</td><td><a name="926000"> </a>Returns the network number part of an IP address.</td></tr><tr><td><a name="926003"> </a><code>inet_ntoa</code> </td><td><a name="926008"> </a><code><a href="NetLibrary.html#925440"></code>NetLibAddrINToA<code></a></code></td><td><a name="926010"> </a>Converts an IP address from 32-bit format to dotted decimal format.</td></tr></table><table><tr><td></table></div></p></dl><a name="926013"> </a><h3> Extending the Network Login Script Support</h3><dl><a name="926014"> </a><p></p><dt>Beginning in Palm OS 3.3, you can write a plugin that extends the list of available script commands in the Network preferences panel. You might do so, for example, if: <ul type="SQUARE"><a name="926015"> </a><br><li>You are a corporate IT shop, system integrator, or a token card vendor and want the login script to properly respond to a range of different connection scenarios defined by the authentication server. <br><a name="926016"> </a><br><li>You are a token card vendor and you want to create the Palm OS version of your password generator. <br><a name="926017"> </a><br><li>You want to perform conditional tests and branching during the execution of the script. <br></ul><a name="926018"> </a><p></p><dt>The login script enhancement can also be installed on any device that already has network library support (that is, PalmPilot<sup>&#153;</sup> Professional and newer devices running Palm OS 2.0 or higher). To do so, you install a file named <code>Network.prc</code> along with a PRC file for the network interface you use (i.e., PPP or SLIP). These files provide the new Network preferences panel, which contains support for some new commands and support for the ability to write script plugins. <a name="926019"> </a><p></p><dt>The sections below describe the basics of how to write a login script plugin. For more detailed information on the API you use to write a plugin, see the chapter <a href="ScriptPlugin.html#924904">"Script Plugin" </a> in the <em>Palm OS SDK Reference</em>. </dl><a name="926023"> </a><h4> Writing the Login Script Plugin</h4><dl><a name="926024"> </a><p></p><dt>To write a login script plugin, you create a project like you normally would; however, specify <code>'scpt'</code> as the database type instead of <code>'appl'</code>. (If you're using Metrowerks CodeWarrior, you specify the database type in the PalmRez post linker panel.) <a name="926025"> </a><p></p><dt>In the <code>PilotMain</code> function, the plugin should respond to two launch codes: <ul type="SQUARE"><a name="926030"> </a><br><li><a href="ScriptPlugin.html#925071">scptLaunchCmdListCmds</a> to inform the Network preferences panel of the commands your plugin implements. <br><a name="926035"> </a><br><li><a href="ScriptPlugin.html#925081">scptLaunchCmdExecuteCmd</a> to execute one of your commands. <br></ul></dl><a name="926037"> </a><h4> Responding to scptLaunchCmdListCmds</h4><dl><a name="926038"> </a><p></p><dt>The Network preferences panel sends the <code>scptLaunchCmdListCmds</code> launch code when it is constructing the pull-down list of available commands that it displays in its script view. The panel sends this launch code to all PRCs of type <code>'scpt'</code>. It passes an empty structure of type <code><a href="ScriptPlugin.html#925024"></code>PluginInfoType<code></a></code> as its parameter block. Your plugin should respond by filling in the structure with the following information: <p></p><ul type="CIRCLE"><a name="926043"> </a><li>The name of your plugin (the name of the PRC file)<a name="926044"> </a><li>The number of commands your plugin implements. No more than <code>pluginMaxNumOfCmds</code> is allowed. <a name="926046"> </a><li>An array containing the name of each command your plugin implements and a Boolean value that indicates whether your plugin takes an argument. </ul><a name="926047"> </a><p></p><dt>A given device might have multiple plugins installed. If so, the resulting pull-down list contains the union of all commands supported by all of the plugins installed on the device. For this reason, you should make sure the command names you supply are unique. You also should make sure the names are as brief as possible, as only 15 characters are allowed for the name. </dl><a name="926048"> </a><h4> Responding to scptLaunchCmdExecuteCmd</h4><dl><a name="926050"> </a><p></p><dt>The <code>scptLaunchCmdExecuteCmd</code> launch code is sent when the login script is being executed. That is, the user has attempted to connect to the network service specified in the Network preferences panel, and the panel is executing the script to perform authentication. <a name="926052"> </a><p></p><dt>The <code>scptLaunchCmdExecuteCmd</code> parameter block is a structure of type <code><a href="ScriptPlugin.html#924984"></code>PluginExecCmdType<code></a></code>. It contains: <ul type="SQUARE"><a name="926056"> </a><br><li>The name of the command to be executed <br><a name="926057"> </a><br><li>The command argument, if it takes one<br><a name="926058"> </a><br><li>A pointer to a network interface function<br><a name="926059"> </a><br><li>A handle to information specific to the current connection<br></ul><a name="926060"> </a><p></p><dt>Your plugin should execute the specified command. When a plugin is launched with this code, it is launched as a subroutine and as such does not have access to global variables. Also keep in mind that the network library and a connection application (such as the HotSync application) are already running when the plugin is launched. Thus, available memory and stack space are extremely limited. <a name="926061"> </a><p></p><dt>To perform most of its work, the plugin command probably needs access to the network interface (such as SLIP or PPP) specified for the selected network service. For this reason, the plugin is passed a pointer to a callback function defined by the network interface. The plugin should call this function when it needs to perform the following tasks: <ul type="SQUARE"><a name="926062"> </a><br><li>Read a number of bytes from the network<br><a name="926063"> </a><br><li>Write a number of bytes to the network<br><a name="926064"> </a><br><li>Get the user's name and password information<br><a name="926065"> </a><br><li>Write a string to the connection log<br><a name="926066"> </a><br><li>Prompt the user for information<br><a name="926067"> </a><br><li>Check to see if the user pressed the Cancel button<br><a name="926068"> </a><br><li>Display a form<br><a name="926069"> </a><br><li>Obtain access to the serial library<br></ul><a name="926070"> </a><p></p><dt>The callback's prototype is defined by <code><a href="ScriptPlugin.html#925222"></code>ScriptPluginSelectorProc<code></a></code>. It takes as arguments the handle to the connection-specific data passed in with the launch code, the task that the network interface should perform (specified as a <code>pluginNetLib</code>... constant), followed by a series of parameters whose interpretations depend on which task is to be performed. <a name="926074"> </a><p></p><dt>For example, the following code implements the command "Send Uname", which sends the user's name to the host computer. </dl><a name="926075"> </a><h4>Listing 11.1	 Simple Script Plugin Command</h4><a name="926076"> </a><hr><code>#define  pluginSecondCmd "Send Uname"</code><br><a name="926077"> </a><code></code><br><a name="926078"> </a><code>UInt32 PilotMain(UInt16&nbsp;cmd, void&nbsp;*cmdPBP, UInt16&nbsp;launchFlags) {</code><br><a name="926079"> </a><code>PluginExecCmdPtr execPtr;</code><br><a name="926080"> </a><code>UInt32 error = success;</code><br><a name="926081"> </a><code>Int16 dataSize = 0;</code><br><a name="926082"> </a><code>Char* dataBuffer = NULL;</code><br><a name="926083"> </a><code>ScriptPluginSelectorProcPtr selectorTypeP;</code><br><a name="926084"> </a><code></code><br><a name="926085"> </a><code>if (cmd == scptLaunchCmdExecuteCmd) {</code><br><a name="926086"> </a><code>&nbsp&nbsp&nbsp execPtr = (PluginExecCmdPtr)cmdPBP;</code><br><a name="926087"> </a><code>&nbsp&nbsp&nbsp selectorTypeP = execPtr-&gt;procP-&gt;selectorProcP;</code><br><a name="926088"> </a><code></code><br><a name="926089"> </a><code>&nbsp&nbsp&nbsp dataBuffer = MemPtrNew(pluginMaxLenTxtStringArg+1);</code><br><a name="926090"> </a><code>&nbsp&nbsp&nbsp if (!dataBuffer) {</code><br><a name="926091"> </a><code>&nbsp&nbsp&nbsp 	 return failure;</code><br><a name="926092"> </a><code>&nbsp&nbsp&nbsp }</code><br><a name="926093"> </a><code>&nbsp&nbsp&nbsp MemSet(dataBuffer,pluginMaxLenTxtStringArg+1,0);</code><br><a name="926094"> </a><code></code><br><a name="926095"> </a><code>&nbsp&nbsp&nbsp if (!StrCompare(execPtr-&gt;commandName, pluginSecondCmd)) {</code><br><a name="926096"> </a><code></code><br><a name="926097"> </a><code>&nbsp&nbsp&nbsp 	 /* get the user name from the network interface */</code><br><a name="926098"> </a><code>&nbsp&nbsp&nbsp 	 error = (selectorTypeP)(execPtr-&gt;handle, </code><br><a name="926099"> </a><code>&nbsp&nbsp&nbsp 	 	 pluginNetLibGetUserName, (void*)dataBufferP, &amp;dataSize, 0, </code><br><a name="926100"> </a><code>&nbsp&nbsp&nbsp 	 	 NULL); </code><br><a name="926101"> </a><code>&nbsp&nbsp&nbsp 	 if (error) goto Exit;</code><br><a name="926102"> </a><code></code><br><a name="926103"> </a><code>&nbsp&nbsp&nbsp 	 dataSize = StrLen((Char*)dataBufferP);</code><br><a name="926104"> </a><code></code><br><a name="926105"> </a><code>/* have the network interface send the user name to the host */</code><br><a name="926106"> </a><code>&nbsp&nbsp&nbsp 	 error = (selectorTypeP)(execPtr-&gt;handle, </code><br><a name="926107"> </a><code>&nbsp&nbsp&nbsp 	 	 pluginNetLibWriteBytes, (void*)dataBufferP, &amp;dataSize, 0, </code><br><a name="926108"> </a><code>&nbsp&nbsp&nbsp 	 	 NULL);</code><br><a name="926109"> </a><code></code><br><a name="926110"> </a><code>&nbsp&nbsp&nbsp return error;</code><br><a name="926111"> </a><code>&nbsp&nbsp&nbsp }</code><br><a name="926112"> </a><code>}</code><br><hr><br><dl><a name="926113"> </a><p></p><dt>If your command needs to interact with the user, it must do so through the network interface. When the connection attempt is taking place, the user sees either the Network preferences panel or the HotSync application. Your plugin does not have control of the screen, so you cannot simply display a form. You have two options: <ul type="SQUARE"><a name="926114"> </a><br><li>The network interface can display a prompt for you and return the value that the user enters in response. It can also query the Network preferences panel to see if the user cancelled the connection attempt. <br><a name="926115"> </a><br><li>If you want to do more than simply display a prompt or check the cancel status, you can use the command <code>pluginNetLibCallUIProc</code> to display a form and call your own user interface routine. <br></ul><a name="926118"> </a><p></p><dt>To use <code>pluginNetLibCallUIProc</code>, you must do the following: </dl>  <a name="926119"> </a><font face="">Initialize the form using a form resource that you've created. </font>  <a name="926120"> </a><font face="">Create a struct that contains your form's handle and any other values that you are going to need in your user interface routine. </font>  <a name="926121"> </a><font face="">Call the network interface's callback function with the <code>pluginNetLibCallUIProc</code> command, the structure with the form's handle and other pertinent information, and the address of a function in your plugin that will perform the user interface routine. This function should take one argument--the struct you've passed to the network interface--and return <code>void</code>. </font>  <a name="926122"> </a><font face="">When the call to the network interface returns, close the form. </font><dl><a name="926123"> </a><p></p><dt>For an example of using <code>pluginNetLibCallUIProc</code>, see the functions <code>WaitForData</code> and <code>promptUser</code> in the example code <code>ScriptPlugin.c</code>. </dl><a name="926125"> </a><h2> Internet Library</h2><dl><a name="926126"> </a><p></p><dt>The Internet library provides Palm applications easy access to World Wide Web documents. The Internet library uses the net library for basic network access and builds on top of the net library's socket concept to provide a socket-like API to higher level internet protocols like HTTP and HTTPS.<a name="926127"> </a><p></p><dt>Using the Internet library, an application can access a web page with as little as three calls (<code><a href="INetLib.html#927416"></code>INetLibURLOpen<code></a></code>, <code><a href="INetLib.html#927085"></code>INetLibSockRead<code></a></code>, and <code><a href="INetLib.html#926426"></code>INetLibSockClose<code></a></code>). The Internet library also provides a more advanced API for those applications that need finer control.<a name="926140"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>The information in this section applies only to version 3.2 or later of the Palm OS on Palm VII devices. These features are implemented only if the <a href="CompatibilityApdx.html#484493">Wireless Internet Feature Set</a> is present.<hr><br></blockquote><a name="926147"> </a><blockquote><hr><em><strong>WARNING!</strong></em><p></p>In future OS versions, Palm Computing does not intend to support or provide backward compatibility for the Internet library API.<hr><br></blockquote><a name="926148"> </a><p></p><dt>The Internet library is implemented as a system library that is installed at runtime and doesn't have to be present for the system to work properly.<a name="926149"> </a><p></p><dt>This section describes how to use the Internet library in your application. It covers:<ul type="SQUARE"><a name="926153"> </a><br><li><a href="NetworkCommunication.html#926183">System Requirements</a><br><a name="926157"> </a><br><li><a href="NetworkCommunication.html#926196">Initialization and Setup</a><br><a name="926161"> </a><br><li><a href="NetworkCommunication.html#926224">Accessing Web Pages</a><br><a name="926165"> </a><br><li><a href="NetworkCommunication.html#926252">Asynchronous Operation</a><br><a name="926169"> </a><br><li><a href="NetworkCommunication.html#926278">Using the Low Level Calls</a><br><a name="926177"> </a><br><li><a href="NetworkCommunication.html#926315">Cache Overview</a><br><a name="926181"> </a><br><li><a href="NetworkCommunication.html#926332">Internet Library Network Configurations</a><br></ul></dl><a name="926183"> </a><h3> System Requirements</h3><dl><a name="926184"> </a><p></p><dt>The Internet library is available only on version 3.2 or later of the Palm OS on Palm VII devices. Before making any Internet library calls, ensure that the Internet library is available. You can be sure it is available by using the following <code><a href="FeatureManager.html#924918"></code>FtrGet<code></a></code> call:<dl><a name="926191"> </a><br><code>err = FtrGet(inetLibFtrCreator, inetFtrNumVersion, &amp;value);</code><br><dl><a name="926192"> </a><p></p><dt>If the Internet library is installed, the <code>value</code> parameter will be non-zero and the returned error will be zero (for no error).<a name="926194"> </a><p></p><dt>When the Internet library is present and running, it requires an estimated additional 1 KB of RAM, beyond the net library. More additional memory is used for the security library, if that is used (when accessing secure sites), and for opening a cache database, if that is used.</dl></dl></dl><a name="926196"> </a><h3> Initialization and Setup</h3><dl><a name="926197"> </a><p></p><dt>Before using the Internet library, an application must call <code><a href="SystemManager.html#925491"></code>SysLibFind<code></a></code> to obtain a library reference number, as follows:<dl><a name="926201"> </a><br><code>err = SysLibFind("INet.lib", &amp;libRefNum)</code><br><dl><a name="926205"> </a><p></p><dt>Next, it must call <code><a href="INetLib.html#926261"></code>INetLibOpen<code></a></code> to allocate an <code>inetH</code> handle. The <code>inetH</code> handle holds all application specific environment settings and each application that uses the Internet library gets its own private <code>inetH</code> handle. Any calls that change the default behavior of the Internet library affect environment settings stored in the application's own <code>inetH</code> structure, so these changes will not affect other applications that might be using the Internet library at the same time.<a name="926206"> </a><p></p><dt><code>INetLibOpen</code> also opens the net library for the application. In addition, the application can tell <code>INetLibOpen</code> the type of network service it prefers: wireline or wireless. <code>INetLibOpen</code> queries the available network interfaces and attaches the appropriate one(s) for the desired type of service. When the application calls <code><a href="INetLib.html#925855"></code>INetLibClose<code></a></code>, the previous interface configuration is restored. For more information on configurations, see the section <a href="NetworkCommunication.html#926332">"Internet Library Network Configurations" </a>. <a name="926213"> </a><p></p><dt>The Internet library gets some of its default behavior from the system preferences database, and some of these preference settings are made by the user via the Wireless preferences panel. The preferences set by this panel include the proxy server to use and a setting that determines whether or not the user is warned when the device ID is sent. Other settings stored in the preferences database come from Internet library network configurations (see <a href="NetworkCommunication.html#926332">"Internet Library Network Configurations" </a>). All these settings can be queried and/or overridden by each application through the <code><a href="INetLib.html#926318"></code>INetLibSettingGet<code></a></code> and <code><a href="INetLib.html#926370"></code>INetLibSettingSet<code></a></code> calls. However, any changes made by an application are not stored into the system preferences, but only take effect while that <code>inetH</code> handle is open.</dl></dl></dl><a name="926224"> </a><h3> Accessing Web Pages</h3><dl><a name="926225"> </a><p></p><dt>In the Palm.Net environment, all HTML documents are dynamically compressed by the Palm Web Clipping Proxy server before being transmitted to the Palm device.<a name="926227"> </a><p></p><dt>The procedure for reading a page from the network operates as follows. First, the application passes the desired URL to the <code><a href="INetLib.html#927416"></code>INetLibURLOpen<code></a></code> routine, which creates a socket handle to access that web page. This routine returns immediately before performing any required network I/O. Then the application calls <code><a href="INetLib.html#927085"></code>INetLibSockRead<code></a></code> to read the data, followed by <code><a href="INetLib.html#926426"></code>INetLibSockClose<code></a></code> to close down the socket. <a name="926237"> </a><p></p><dt>Note that if no data is available to read immediately, <code>INetLibSockRead</code> blocks until at least one byte of data is available to be read. To implement asynchronous operation using events, see the next section, <a href="NetworkCommunication.html#926252">Asynchronous Operation</a>.<a name="926241"> </a><p></p><dt>If an application requires finer control over the operation, it can replace the call to <code>INetLibURLOpen</code> with other lower-level Internet library calls (<code><a href="INetLib.html#927026"></code>INetLibSockOpen<code></a></code>, <code><a href="INetLib.html#927183"></code>INetLibSockSettingSet<code></a></code>, etc.) that are described in the section <a href="NetworkCommunication.html#926278">"Using the Low Level Calls" </a>.</dl><a name="926252"> </a><h3> Asynchronous Operation</h3><dl><a name="926253"> </a><p></p><dt>A major challenge in writing an Internet application is handling the task of accessing content over a slow network while still providing good user-interface response. For example, a user should be able to scroll, select menus, or tap the Cancel button in the middle of a download of a web page.<a name="926254"> </a><p></p><dt>To easily enable this type of functionality, the Internet library provides the <code><a href="INetLib.html#926211"></code>INetLibGetEvent<code></a></code> call. This call is designed to replace the <code>EvtGetEvent</code> call that all traditional, non-network Palm applications use. The <code>INetLibGetEvent</code> call fetches the next event that needs to be processed, whether that event is a user-interface event like a tap on the screen, or a network event like some data arriving from the remote host that needs to be read. If no events are ready, <code>INetLibGetEvent</code> automatically puts the Palm device into low-power mode and blocks until the next event occurs.<a name="926258"> </a><p></p><dt>Using <code>INetLibGetEvent</code> is the preferred way of performing network I/O since it maximizes battery life and user-interface responsiveness. <a name="926259"> </a><p></p><dt>With <code>INetLibGetEvent</code>, the process of accessing a web page becomes only slightly more complicated. Instead of calling <code>INetLibSockRead</code> immediately after <code>INetLibURLOpen</code>, the application should instead return to its event loop and wait for the next event. When it gets a network event that says data is ready at the socket, then it should call <code>INetLibSockRead</code>.<a name="926260"> </a><p></p><dt>There are two types of network events that <code>INetLibGetEvent</code> can return in addition to the standard user-interface events. The first event is a status change event (<code><a href="EventRef.html#925831"></code>inetSockStatusChangeEvent<code></a></code>). This event indicates that the status of a socket has changed and the application may want to update its user interface. For example, when calling <code>INetLibURLOpen</code> to access an HTTP server, the status on the socket goes from "finding host," to "connecting with host," to "waiting for data," to "reading data," etc. The event structure associated with an event of this type contains both the socket handle and the new status so that the application can update the user interface accordingly.<a name="926264"> </a><p></p><dt>The second type of event that <code>INetLibGetEvent</code> can return is a data-ready event (<code><a href="EventRef.html#925781"></code>inetSockReadyEvent<code></a></code>). This event is returned when data is ready at the socket for reading. This event tells the application that it can call <code>INetLibSockRead</code> and be assured that it will not block while waiting for data to arrive.<a name="926268"> </a><p></p><dt>The general flow of an application that uses the Internet library is to open a URL using <code>INetLibURLOpen</code>, in response to a user command. Then it repeatedly calls <code>INetLibGetEvent</code> to process events from both the user interface and the newly created socket returned by <code>INetLibURLOpen</code>. In response to <code>inetSockStatusChangeEvent</code> events, the application should update the user interface to show the user the current status, such as finding host, connecting to host, reading data, etc. In response to <code>inetSockReadyEvent</code> events, the application should read data from the socket using <code>INetLibSockRead</code>. Finally, when all available data has been read (<code>INetLibSockRead</code> returns 0 bytes read), the application should close the socket using <code>INetLibSockClose</code>.<a name="926276"> </a><p></p><dt>Finally, the convenience call <code><a href="INetLib.html#927226"></code>INetLibSockStatus<code></a></code> is provided so that an application can query the status of a socket handle. This call never blocks on network I/O so it is safe to call at any time. It not only returns the current status of the socket but also whether or not it is ready for reading and/or writing. It essentially returns the same information as conveyed via the events <code>inetSockReadyEvent</code> and <code>inetSockStatusChangeEvent</code>. Applications that don't use <code>INetLibGetEvent</code> could repeatedly poll <code>INetLibSockStatus</code> to check for status changes and readiness for I/O, though polling is not recommended.</dl><a name="926278"> </a><h3> Using the Low Level Calls</h3><dl><a name="926279"> </a><p></p><dt>Applications that need finer control than <code>INetLibURLOpen</code> provides can use the lower level calls of the Internet library. These include <code><a href="INetLib.html#927026"></code>INetLibSockOpen<code></a></code>, <code><a href="INetLib.html#926461"></code>INetLibSockConnect<code></a></code>, <code><a href="INetLib.html#927183"></code>INetLibSockSettingSet<code></a></code>, <code><a href="INetLib.html#926619"></code>INetLibSockHTTPReqCreate<code></a></code>, <code><a href="INetLib.html#926527"></code>INetLibSockHTTPAttrGet<code></a></code>, <code><a href="INetLib.html#926571"></code>INetLibSockHTTPAttrSet<code></a></code>, and <code><a href="INetLib.html#926664"></code>INetLibSockHTTPReqSend<code></a></code>.<a name="926301"> </a><p></p><dt>A single call to <code>INetLibURLOpen</code> for an HTTP resource is essentially equivalent to this sequence: <code>INetLibSockOpen</code>, <code>INetLibSockConnect</code>, <code>INetLibSockHTTPReqCreate</code>, and <code>INetLibSockHTTPReqSend</code>. These four calls provide the capability for the application to access non-standard ports on the server (if allowed), to modify the default HTTP request headers, and to perform HTTP PUT and POST operations. The only calls here that actually perform network I/O are <code>INetLibSockConnect</code>, which establishes a TCP connection with the remote host, and <code>INetLibSockHTTPReqSend</code>, which sends the HTTP request to the server.<a name="926302"> </a><p></p><dt><code>INetLibSockHTTPAttrSet</code> is provided so that the application can add or modify the default HTTP request headers that <code>INetLibSockHTTPReqCreate</code> creates.<a name="926303"> </a><p></p><dt><code>INetLibSockSettingSet</code> allows an application finer control over the socket settings.<a name="926308"> </a><p></p><dt>Finally, the routine <code><a href="INetLib.html#927319"></code>INetLibURLCrack<code></a></code> is provided as a convenient utility for breaking a URL into its component parts.</dl><a name="926315"> </a><h3> Cache Overview</h3><dl><a name="926316"> </a><p></p><dt>The Internet library maintains a cache database of documents that have been downloaded. This is an LRU (Least Recently Used) cache; that is, the least recently used items are flushed when the cache fills. Whether or not a retrieved page is cached is determined by a flag (<code>inetOpenURLFlagKeepInCache</code>) set in the socket or by <code>INetLibURLOpen</code>. Another flag (<code>inetOpenURLFlagLookInCache</code>) determines if the Internet library should check the cache first when retrieving a URL.<a name="926317"> </a><p></p><dt>The same cache database can be used by any application using the Internet library, so that every application can share the same pool of prefetched documents. Alternately, an application can use a different cache database. The cache database to use is specified in the <code>INetLibOpen</code> call.<a name="926318"> </a><p></p><dt>Generally, a cached item is stored in one or more database records in the same format as it arrives from the server.<a name="926319"> </a><p></p><dt>In the cache used by the Clipper application, each record includes a field that contains the "master" URL of the item. This field is set to the URL of the active PQA, so all pages linked from one PQA have the same master URL. This facilitates finding all pages in a hierarchy to build a history list.<a name="926320"> </a><p></p><dt>The Internet library maintains a list of items in the cache. You can retrieve items in this list, or iterate over the whole list, by calling <code><a href="INetLib.html#925773"></code>INetLibCacheList<code></a></code>. You can retrieve a cached document directly by using <code><a href="INetLib.html#925725"></code>INetLibCacheGetObject<code></a></code>.<a name="926330"> </a><p></p><dt>You can check if a URL is cached by calling <code><a href="INetLib.html#927376"></code>INetLibURLGetInfo<code></a></code>.</dl><a name="926332"> </a><h3> Internet Library Network Configurations</h3><dl><a name="926333"> </a><p></p><dt>The Internet library supports network configurations. A <strong>configuration</strong> is a specific set of values for several of the Internet library settings (from the <code><a href="INetLib.html#925286"></code>INetSettingEnum<code></a></code> type).<a name="926337"> </a><p></p><dt>The Internet library keeps a list of available configurations and aliases to them. There are three built-in configurations:<ul type="SQUARE"><a name="926338"> </a><br><li>A wireless configuration that uses the Palm.Net wireless system and the Palm Web Clipping Proxy server.<br><a name="926339"> </a><br><li>A wireline configuration that uses the wireline network configuration specified in the Network preferences panel and the Palm Web Clipping Proxy server.<br><a name="926340"> </a><br><li>A generic configuration that uses the wireline network configuration specified in the Network preferences panel and no proxy server.<br></ul><a name="926341"> </a><p></p><dt>You can also define your own configuration by modifying an existing one and saving it under a different name.<a name="926342"> </a><p></p><dt>The Internet library also defines several <strong>configuration aliases</strong> (see <a href="INetLib.html#925584">"Configuration Aliases" </a> in the <em>Palm OS SDK Reference</em>). An alias is a configuration name that simply points to another configuration. You can specify an alias anywhere in the API you would specify a configuration. This facilitates easy re-assignment of the built-in configurations and eliminates having duplicate settings. You assign an alias by using <code><a href="INetLib.html#925927"></code>INetLibConfigAliasSet<code></a></code> and can retrieve an alias by using <code><a href="INetLib.html#925884"></code>INetLibConfigAliasGet<code></a></code>.<a name="926352"> </a><p></p><dt>For example, to change the default configuration used by the Internet library for a particular kind of connection, you can set up the appropriate values for a connection, save the configuration, and then set the Internet library's default alias configuration to point to your custom configuration. When an application specifies which configuration it wants to use, if it specifies the alias, it will use the custom settings.<a name="926353"> </a><p></p><dt>If you use configurations at all, it will probably be to specify a specific configuration when opening the Internet library via <code>INetLibOpen</code>. The Internet library also contains an API to allow you to manipulate configurations in your application, but doing so is rare. You can list the available configurations (<code><a href="INetLib.html#926055"></code>INetLibConfigList<code></a></code>), get a configuration index (<code><a href="INetLib.html#926017"></code>INetLibConfigIndexFromName<code></a></code>), select (<code><a href="INetLib.html#926089"></code>INetLibConfigMakeActive<code></a></code>) the Internet library network configuration you would prefer to use (wireless, wireline, etc.), rename existing configurations (<code><a href="INetLib.html#926129"></code>INetLibConfigRename<code></a></code>), and delete configurations (<code><a href="INetLib.html#925973"></code>INetLibConfigDelete<code></a></code>).<a name="926369"> </a><p></p><dt>The configuration functions are provided primarily for use by Preferences panels while editing and saving configurations. The general procedure is to make the configuration active that you want to edit, set the settings appropriately, then save the configuration using <code><a href="INetLib.html#926175"></code>INetLibConfigSaveAs<code></a></code>. Note that configuration changes are not saved after the Internet library is closed, unless you call <code>INetLibConfigSaveAs</code>. </dl><a name="926374"> </a><h2> Summary of Network Communication</h2><p><a name="926673"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="926377"> </a><strong>Net Library Functions</strong></th><th><a name="926379"> </a><strong></strong></th></tr><tr><td colspan=2 rowspan=1><a name="926381"> </a><strong>Library Open and Close</strong></td></tr><tr><td colspan=1 rowspan=3><a name="926388"> </a><a href="NetLibrary.html#925462">NetLibClose</a><br><a href="NetLibrary.html#925884">NetLibConnectionRefresh</a><br><a href="NetLibrary.html#925959">NetLibFinishCloseWait</a></td><td colspan=1 rowspan=3><a name="926399"> </a><a href="NetLibrary.html#927163">NetLibOpen</a><br><a href="NetLibrary.html#927306">NetLibOpenCount</a></td></tr><tr></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926415"> </a><strong>Socket Creation and Deletion</strong></td></tr><tr><td><a name="926422"> </a><a href="NetLibrary.html#928143">NetLibSocketClose</a></td><td><a name="926427"> </a><a href="NetLibrary.html#928319">NetLibSocketOpen</a></td></tr><tr><td colspan=2 rowspan=1><a name="926429"> </a><strong>Socket Options</strong></td></tr><tr><td><a name="926436"> </a><a href="NetLibrary.html#928409">NetLibSocketOptionGet</a></td><td><a name="926441"> </a><a href="NetLibrary.html#928465">NetLibSocketOptionSet</a></td></tr><tr><td colspan=2 rowspan=1><a name="926443"> </a><strong>Socket Connections</strong></td></tr><tr><td colspan=1 rowspan=3><a name="926450"> </a><a href="NetLibrary.html#927971">NetLibSocketAccept</a><br><a href="NetLibrary.html#928032">NetLibSocketAddr</a><br><a href="NetLibrary.html#928080">NetLibSocketBind</a></td><td colspan=1 rowspan=3><a name="926461"> </a><a href="NetLibrary.html#928189">NetLibSocketConnect</a><br><a href="NetLibrary.html#928246">NetLibSocketListen</a><br><a href="NetLibrary.html#928827">NetLibSocketShutdown</a></td></tr><tr></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926477"> </a><strong>Send and Receive Routines</strong></td></tr><tr><td colspan=1 rowspan=3><a name="926484"> </a><a href="NetLibrary.html#925911">NetLibDmReceive</a><br><a href="NetLibrary.html#927329">NetLibReceive</a><br><a href="NetLibrary.html#927400">NetLibReceivePB</a></td><td colspan=1 rowspan=3><a name="926495"> </a><a href="NetLibrary.html#927575">NetLibSend</a><br><a href="NetLibrary.html#927671">NetLibSendPB</a></td></tr><tr></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926508"> </a><strong>Utilities</strong></td></tr><tr><td colspan=1 rowspan=7><a name="926515"> </a><a href="NetLibrary.html#925372">NetHToNL</a><br><a href="NetLibrary.html#925397">NetHToNS</a><br><a href="NetLibrary.html#925420">NetLibAddrAToIN</a><br><a href="NetLibrary.html#925440">NetLibAddrINToA</a><br><a href="NetLibrary.html#925980">NetLibGetHostByAddr</a><br><a href="NetLibrary.html#926060">NetLibGetHostByName</a><br><a href="NetLibrary.html#926138">NetLibGetMailExchangeByName</a></td><td colspan=1 rowspan=7><a name="926538"> </a><a href="NetLibrary.html#926212">NetLibGetServByName</a><br><a href="NetLibrary.html#926869">NetLibMaster</a><br><a href="NetLibrary.html#927500">NetLibSelect</a><br><a href="NetLibrary.html#928866">NetLibTracePrintF</a><br><a href="NetLibrary.html#928902">NetLibTracePutS</a><br><a href="NetLibrary.html#928934">NetNToHL</a><br><a href="NetLibrary.html#928960">NetNToHS</a></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926582"> </a><strong>Setup</strong></td></tr><tr><td colspan=1 rowspan=5><a name="926589"> </a><a href="NetLibrary.html#926252">NetLibIFAttach</a><br><a href="NetLibrary.html#926287">NetLibIFDetach</a><br><a href="NetLibrary.html#926316">NetLibIFDown</a><br><a href="NetLibrary.html#926358">NetLibIFGet</a><br><a href="NetLibrary.html#926396">NetLibIFSettingGet</a></td><td colspan=1 rowspan=5><a name="926606"> </a><a href="NetLibrary.html#926758">NetLibIFSettingSet</a><br><a href="NetLibrary.html#926816">NetLibIFUp</a><br><a href="NetLibrary.html#927759">NetLibSettingGet</a><br><a href="NetLibrary.html#927919">NetLibSettingSet</a></td></tr><tr></tr><tr></tr><tr></tr><tr></tr></table><table><tr><td></table></div></p><p><a name="926699"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="926676"> </a><strong>Network Utilities</strong></th><th><a name="926678"> </a><strong></strong></th></tr><tr><td><a name="926687"> </a><a href="NetworkUtils.html#924937">NetUReadN</a></td><td><a name="926695"> </a><a href="NetworkUtils.html#924961">NetUTCPOpen</a><br><a href="NetworkUtils.html#925065">NetUWriteN</a></td></tr></table><table><tr><td></table></div></p><p><a name="926905"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="926702"> </a><strong>Internet Library Functions</strong></th><th><a name="926704"> </a><strong></strong></th></tr><tr><td colspan=2 rowspan=1><a name="926706"> </a><strong>Library Open and Close</strong></td></tr><tr><td><a name="926713"> </a><a href="INetLib.html#925855">INetLibClose</a></td><td><a name="926718"> </a><a href="INetLib.html#926261">INetLibOpen</a></td></tr><tr><td colspan=2 rowspan=1><a name="926720"> </a><strong>Settings</strong></td></tr><tr><td><a name="926727"> </a><a href="INetLib.html#926318">INetLibSettingGet</a></td><td><a name="926732"> </a><a href="INetLib.html#926370">INetLibSettingSet</a></td></tr><tr><td colspan=2 rowspan=1><a name="926734"> </a><strong>Event Management</strong></td></tr><tr><td><a name="926741"> </a><a href="INetLib.html#926211">INetLibGetEvent</a></td><td><a name="926743"> </a></td></tr><tr><td colspan=2 rowspan=1><a name="926745"> </a><strong>High-Level Socket Calls</strong></td></tr><tr><td colspan=1 rowspan=2><a name="926752"> </a><a href="INetLib.html#926426">INetLibSockClose</a><br><a href="INetLib.html#927085">INetLibSockRead</a></td><td colspan=1 rowspan=2><a name="926760"> </a><a href="INetLib.html#927416">INetLibURLOpen</a></td></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926766"> </a><strong>Low-Level Socket Calls</strong></td></tr><tr><td colspan=1 rowspan=3><a name="926773"> </a><a href="INetLib.html#926461">INetLibSockConnect</a><br><a href="INetLib.html#927026">INetLibSockOpen</a><br><a href="INetLib.html#927142">INetLibSockSettingGet</a></td><td colspan=1 rowspan=3><a name="926784"> </a><a href="INetLib.html#927183">INetLibSockSettingSet</a><br><a href="INetLib.html#927226">INetLibSockStatus</a></td></tr><tr></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926797"> </a><strong>HTTP Interface</strong></td></tr><tr><td colspan=1 rowspan=2><a name="926804"> </a><a href="INetLib.html#926527">INetLibSockHTTPAttrGet</a><br><a href="INetLib.html#926571">INetLibSockHTTPAttrSet</a></td><td colspan=1 rowspan=2><a name="926812"> </a><a href="INetLib.html#926619">INetLibSockHTTPReqCreate</a><br><a href="INetLib.html#926664">INetLibSockHTTPReqSend</a></td></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926821"> </a><strong>Utilities</strong></td></tr><tr><td colspan=1 rowspan=2><a name="926828"> </a><a href="INetLib.html#925827">INetLibCheckAntennaState</a> <br><a href="INetLib.html#927319">INetLibURLCrack</a><br><a href="INetLib.html#927376">INetLibURLGetInfo</a></td><td colspan=1 rowspan=2><a name="926839"> </a><a href="INetLib.html#927474">INetLibURLsAdd</a><br><a href="INetLib.html#927536">INetLibWiCmd</a></td></tr><tr></tr><tr><td colspan=2 rowspan=1><a name="926848"> </a><strong>Cache Interface</strong></td></tr><tr><td><a name="926855"> </a><a href="INetLib.html#925725">INetLibCacheGetObject</a></td><td><a name="926860"> </a><a href="INetLib.html#925773">INetLibCacheList</a></td></tr><tr><td colspan=2 rowspan=1><a name="926862"> </a><strong>Configuration</strong></td></tr><tr><td colspan=1 rowspan=4><a name="926869"> </a><a href="INetLib.html#925884">INetLibConfigAliasGet</a><br><a href="INetLib.html#925927">INetLibConfigAliasSet</a><br><a href="INetLib.html#925973">INetLibConfigDelete</a><br><a href="INetLib.html#926017">INetLibConfigIndexFromName</a></td><td colspan=1 rowspan=4><a name="926883"> </a><a href="INetLib.html#926055">INetLibConfigList</a><br><a href="INetLib.html#926089">INetLibConfigMakeActive</a><br><a href="INetLib.html#926129">INetLibConfigRename</a><br><a href="INetLib.html#926175">INetLibConfigSaveAs</a></td></tr><tr></tr><tr></tr><tr></tr></table><table><tr><td></table></div></p><dl><a name="926947"> </a><p></p><dt><strong></strong></dl><hr><br><center><B>Palm OS Programmer's Companion</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="Beaming.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="InternetApps.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 80 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:46 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/NetworkCommunication.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:16 GMT -->
</html>