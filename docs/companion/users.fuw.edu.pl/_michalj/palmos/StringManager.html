<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/StringManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
<head><title>String Manager</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="StandardIO.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="SystemEventManager.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924904"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924902"> </a>44 String Manager</h1><dl><a name="924905"> </a><p></p><dt>This chapter provides reference material for the string manager. The string manager API is declared in the header file <code>StringMgr.h</code>. <a name="924910"> </a><p></p><dt>For more information, see the <a href="UserInterface.html#926379">"Text"</a> section in the <em>Palm OS Programmer's Companion</em>. </dl><a name="924911"> </a><h2> String Manager Functions</h2><a name="924913"> </a><br> <br> <br><h3> StrAToI</h3><dl><dl><a name="924914"> </a><h4>Purpose </h4><dl><a name="924915"> </a><p></p><dt>Convert a string to an integer. </dl><a name="924916"> </a><h4>Prototype </h4><dl><a name="924918"> </a><dt><code>Int32 StrAToI (const&nbsp;Char*&nbsp;str)</code></dl></dl><dl><a name="924919"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924920"> </a><CODE><code>str</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to convert.<br></TD></TR></TABLE></dl><dl><a name="924921"> </a><h4>Result </h4><dl><a name="924922"> </a><p></p><dt>Returns the integer.</dl></dl><dl><a name="924923"> </a><h4>Comments </h4><dl><a name="924925"> </a><p></p><dt>Use this function instead of the standard <code>atoi</code> routine.</dl></dl></dl><a name="924927"> </a><br> <br> <br><h3> StrCaselessCompare</h3><dl><dl><a name="924928"> </a><h4>Purpose </h4><dl><a name="924929"> </a><p></p><dt>Compare two strings with case and accent insensitivity. </dl><a name="924930"> </a><h4>Prototype </h4><dl><a name="924932"> </a><dt><code>Int16 StrCaselessCompare (const&nbsp;Char*&nbsp;s1, const&nbsp;Char*&nbsp;s2)</code></dl></dl><dl><a name="924933"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924934"> </a><CODE><code>s1</code>, <code>s2</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Two string pointers.<br></TD></TR></TABLE></dl><dl><a name="924935"> </a><h4>Result </h4><dl><a name="924936"> </a><p></p><dt>Returns 0 if the strings match.<a name="924937"> </a><p></p><dt>Returns a positive number if <code>s1</code> &gt; <code>s2</code>.<a name="924938"> </a><p></p><dt>Returns a negative number if <code>s1</code> &lt; <code>s2</code>.</dl></dl><dl><a name="924939"> </a><h4>Comments </h4><dl><a name="924941"> </a><p></p><dt>Use this function instead of the standard <code>stricmp</code> routine. Use it to find strings, or use it with <code><a href="StringManager.html#925003"></code>StrCompare<code></a></code> to sort strings. (See the comments in <code>StrCompare</code> for a example code.) <a name="924943"> </a><p></p><dt>To support systems that use multi-byte character encodings, consider using <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code> instead of this function. Both functions can match single-byte characters with their multi-byte equivalents, but <code>TxtCaselessCompare</code> can also return the length of the matching text. </dl><a name="924947"> </a><h4>See Also </h4><dl><a name="924957"> </a><p></p><dt><code><a href="StringManager.html#925167"></code>StrNCaselessCompare<code></a></code>, <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a>, </code><code><a href="StringManager.html#925003"></code>StrCompare<code></a></code>, <code><a href="StringManager.html#925234"></code>StrNCompare<code></a></code>, <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code> </dl></dl></dl><a name="924965"> </a><br> <br> <br><h3> StrCat</h3><dl><dl><a name="924966"> </a><h4>Purpose </h4><dl><a name="924967"> </a><p></p><dt>Concatenate one string to another.</dl><a name="924968"> </a><h4>Prototype </h4><dl><a name="924970"> </a><dt><code>Char* StrCat (Char*&nbsp;dst, const&nbsp;Char*&nbsp;src)</code></dl></dl><dl><a name="924971"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924972"> </a><CODE><code>dst</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Destination string pointer.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924973"> </a><CODE><code>src</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Source string pointer. <br></TD></TR></TABLE></dl><dl><a name="924974"> </a><h4>Result </h4><dl><a name="924975"> </a><p></p><dt>Returns a pointer to the destination string.</dl></dl><dl><a name="924976"> </a><h4>Comments </h4><dl><a name="924978"> </a><p></p><dt>Use this function instead of the standard <code>strcat</code> routine.</dl></dl></dl><a name="924980"> </a><br> <br> <br><h3> StrChr</h3><dl><dl><a name="924981"> </a><h4>Purpose </h4><dl><a name="924982"> </a><p></p><dt>Look for a character within a string. </dl><a name="924983"> </a><h4>Prototype </h4><dl><a name="924985"> </a><dt><code>Char* StrChr (const&nbsp;Char*&nbsp;str, WChar&nbsp;chr)</code></dl></dl><dl><a name="924986"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924987"> </a><CODE><code>str</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to search.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924988"> </a><CODE><code>chr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Character to search for.<br></TD></TR></TABLE></dl><dl><a name="924989"> </a><h4>Result </h4><dl><a name="924990"> </a><p></p><dt>Returns a pointer to the first occurrence of character in <code>str</code>. Returns <code>NULL</code> if the character is not found.</dl></dl><dl><a name="924991"> </a><h4>Comments </h4><dl><a name="924993"> </a><p></p><dt>Use this function instead of the standard <code>strchr</code> routine.<a name="924994"> </a><p></p><dt>This routine does not correctly find a `\0' character on Palm OS<sup>&#174;</sup> version 1.0. <a name="924995"> </a><p></p><dt>This function can handle both single-byte characters and multi-byte characters.<a name="924996"> </a><p></p><dt><code>StrChr</code> displays a non-fatal error message if <code>chr</code> is greater than <code>0xFF</code>.</dl><a name="924997"> </a><h4>See Also </h4><dl><a name="925001"> </a><p></p><dt><code><a href="StringManager.html#925326"></code>StrStr<code></a></code> </dl></dl></dl><a name="925003"> </a><br> <br> <br><h3> StrCompare</h3><dl><dl><a name="925004"> </a><h4>Purpose </h4><dl><a name="925005"> </a><p></p><dt>Compare two strings. </dl><a name="925006"> </a><h4>Prototype </h4><dl><a name="925008"> </a><dt><code>Int16 StrCompare (const&nbsp;Char*&nbsp;s1, const&nbsp;Char*&nbsp;s2)</code></dl></dl><dl><a name="925009"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925010"> </a><CODE><code>s1, s2</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Two string pointers.<br></TD></TR></TABLE></dl><dl><a name="925011"> </a><h4>Result </h4><dl><a name="925012"> </a><p></p><dt>Returns 0 if the strings match.<a name="925013"> </a><p></p><dt>Returns a positive number if <code>s1</code> sorts after <code>s2</code> alphabetically.<a name="925014"> </a><p></p><dt>Returns a negative number if <code>s1</code> sorts before <code>s2</code> alphabetically.</dl></dl><dl><a name="925015"> </a><h4>Comments </h4><dl><a name="925017"> </a><p></p><dt>Use this function instead of the standard <code>strcmp</code> routine.<a name="925018"> </a><p></p><dt>This function is case sensitive. Use it to sort strings but not to find them.<a name="925019"> </a><p></p><dt>This function performs a character-by-character comparison of <code>s1</code> and <code>s2</code> and returns as soon as it finds two unequal characters. For example, if you are comparing the string "celery" with the string "Cauliflower," <code>StrCompare</code> returns that "celery" should appear before "Cauliflower" because it sorts the letter "c" before "C." <a name="925020"> </a><p></p><dt>If you need to perform a true alphabetical sort, use <code><a href="StringManager.html#924927"></code>StrCaselessCompare<code></a></code> before using <code>StrCompare</code>, as in the following code:</dl></dl><dl><a name="925024"> </a><br><code>Int16 result = StrCaselessCompare(a, b);</code><br></dl><dl><a name="925025"> </a><code>if (result == 0)</code><br><a name="925026"> </a><code>&nbsp&nbsp&nbsp result = StrCompare(a, b);</code><br><a name="925027"> </a><code>return(result);</code><br><dl><a name="925029"> </a><p></p><dt>To support systems that use multi-byte character encodings, consider using <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code> instead of this function. Both functions can match single-byte characters with their multi-byte equivalents, but <code>TxtCompare</code> can also return the length of the matching text. </dl></dl><dl><a name="925033"> </a><h4>See Also </h4><dl><a name="925043"> </a><p></p><dt><code><a href="StringManager.html#925234"></code>StrNCompare<code></a></code>, <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code>, <code><a href="StringManager.html#924927"></code>StrCaselessCompare<code></a></code>, <code><a href="StringManager.html#925167"></code>StrNCaselessCompare<code></a></code>, <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code> </dl></dl></dl><a name="925051"> </a><br> <br> <br><h3> StrCopy</h3><dl><dl><a name="925052"> </a><h4>Purpose </h4><dl><a name="925053"> </a><p></p><dt>Copy one string to another.</dl><a name="925054"> </a><h4>Prototype </h4><dl><a name="925056"> </a><dt><code>Char* StrCopy (Char*&nbsp;dst, const&nbsp;Char*&nbsp;src)</code></dl></dl><dl><a name="925057"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925058"> </a><CODE><code>dst, src</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Two string pointers.<br></TD></TR></TABLE></dl><dl><a name="925059"> </a><h4>Result </h4><dl><a name="925060"> </a><p></p><dt>Returns a pointer to the destination string.</dl></dl><dl><a name="925061"> </a><h4>Comments </h4><dl><a name="925063"> </a><p></p><dt>Use this function instead of the standard <code>strcpy</code> routine. <a name="925064"> </a><p></p><dt>This function does not work properly with overlapping strings. </dl></dl></dl><a name="925066"> </a><br> <br> <br><h3> StrDelocalizeNumber</h3><dl><dl><a name="925067"> </a><h4>Purpose </h4><dl><a name="925068"> </a><p></p><dt>Delocalize a number passed in as a string. Convert the number from any localized notation to US notation (decimal point and thousandth comma). The current thousand and decimal separators have to be passed in. </dl><a name="925069"> </a><h4>Prototype </h4><dl><a name="925071"> </a><dt><code>Char* StrDelocalizeNumber (Char*&nbsp;s, Char&nbsp;thousandSeparator, Char&nbsp;decimalSeparator)</code></dl></dl><dl><a name="925072"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925073"> </a><CODE><code>s</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the number as an ASCII string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925074"> </a><CODE><code>thousandSeparator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Current thousand separator.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925075"> </a><CODE><code>decimalSeparator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Current decimal separator.<br></TD></TR></TABLE></dl><dl><a name="925076"> </a><h4>Result </h4><dl><a name="925077"> </a><p></p><dt>Returns a pointer to the changed number and modifies the string in <code>s</code>. </dl></dl><dl><a name="925078"> </a><h4>Compatibility </h4><dl><a name="925082"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl><a name="925083"> </a><h4>See Also </h4><dl><a name="925090"> </a><p></p><dt><code><a href="StringManager.html#925144"></code>StrLocalizeNumber<code></a></code>, <code><a href="MiscSys.html#924921"></code>LocGetNumberSeparators<code></a></code> </dl></dl></dl><a name="925092"> </a><br> <br> <br><h3> StrIToA</h3><dl><dl><a name="925093"> </a><h4>Purpose </h4><dl><a name="925094"> </a><p></p><dt>Convert an integer to ASCII.</dl><a name="925095"> </a><h4>Prototype </h4><dl><a name="925097"> </a><dt><code>Char* StrIToA (Char*&nbsp;s, Int32&nbsp;i)</code></dl></dl><dl><a name="925098"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925099"> </a><CODE><code>s</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String pointer to store results.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925100"> </a><CODE><code>i</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Integer to convert.<br></TD></TR></TABLE></dl><dl><a name="925101"> </a><h4>Result </h4><dl><a name="925102"> </a><p></p><dt>Returns a pointer to the result string. </dl></dl><dl><a name="925103"> </a><h4>See Also </h4><dl><a name="925110"> </a><p></p><dt><code><a href="StringManager.html#924913"></code>StrAToI<code></a></code>, <code><a href="StringManager.html#925112"></code>StrIToH<code></a></code></dl></dl></dl><a name="925112"> </a><br> <br> <br><h3> StrIToH</h3><dl><dl><a name="925113"> </a><h4>Purpose </h4><dl><a name="925114"> </a><p></p><dt>Convert an integer to hexadecimal ASCII.</dl><a name="925115"> </a><h4>Prototype </h4><dl><a name="925117"> </a><dt><code>Char* StrIToH (Char*&nbsp;s, UInt32&nbsp;i)</code></dl></dl><dl><a name="925118"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925119"> </a><CODE><code>s</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String pointer to store results.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925120"> </a><CODE><code>i</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Integer to convert.<br></TD></TR></TABLE></dl><dl><a name="925121"> </a><h4>Result </h4><dl><a name="925122"> </a><p></p><dt>Returns the string pointer <code>s</code>.</dl></dl><dl><a name="925123"> </a><h4>See Also </h4><dl><a name="925127"> </a><p></p><dt><code><a href="StringManager.html#925092"></code>StrIToA<code></a></code></dl></dl></dl><a name="925129"> </a><br> <br> <br><h3> StrLen</h3><dl><dl><a name="925130"> </a><h4>Purpose </h4><dl><a name="925131"> </a><p></p><dt>Compute the length of a string.</dl><a name="925132"> </a><h4>Prototype </h4><dl><a name="925134"> </a><dt><code>UInt16 StrLen (const&nbsp;Char*&nbsp;src)</code></dl></dl><dl><a name="925135"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925136"> </a><CODE><code>src</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String pointer<br></TD></TR></TABLE></dl><dl><a name="925137"> </a><h4>Result </h4><dl><a name="925138"> </a><p></p><dt>Returns the length of the string in bytes.</dl></dl><dl><a name="925139"> </a><h4>Comments </h4><dl><a name="925141"> </a><p></p><dt>Use this function instead of the standard <code>strlen</code> routine.<a name="925142"> </a><p></p><dt>This function returns the length of the string in bytes. On systems that support multi-byte characters, the number returned does not always equal the number of characters. </dl></dl></dl><a name="925144"> </a><br> <br> <br><h3> StrLocalizeNumber</h3><dl><dl><a name="925145"> </a><h4>Purpose </h4><dl><a name="925146"> </a><p></p><dt>Convert a number (passed in as a string) to localized format, using a specified thousands separator and decimal separator. </dl><a name="925147"> </a><h4>Prototype </h4><dl><a name="925149"> </a><dt><code>Char* StrLocalizeNumber (Char*&nbsp;s, Char&nbsp;thousandSeparator, Char&nbsp;decimalSeparator)</code></dl></dl><dl><a name="925150"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925151"> </a><CODE><code>s</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number ASCII string to localize.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925152"> </a><CODE><code>thousandSeparator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Localized thousand separator.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925153"> </a><CODE><code>decimalSeparator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Localized decimal separator.<br></TD></TR></TABLE></dl><dl><a name="925154"> </a><h4>Result </h4><dl><a name="925155"> </a><p></p><dt>Returns a pointer to the changed number. Converts the number string in <code>s</code> by replacing all occurrences of "," with <code>thousandSeparator</code> and all occurrences of "." with <code>decimalSeparator</code>. </dl></dl><dl><a name="925156"> </a><h4>Compatibility </h4><dl><a name="925160"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl><a name="925161"> </a><h4>See Also </h4><dl><a name="925165"> </a><p></p><dt><code><a href="StringManager.html#925066"></code>StrDelocalizeNumber<code></a></code> </dl></dl></dl><a name="925167"> </a><br> <br> <br><h3> StrNCaselessCompare</h3><dl><dl><a name="925168"> </a><h4>Purpose </h4><dl><a name="925169"> </a><p></p><dt>Compares two strings out to <em>n</em> characters with case and accent insensitivity.</dl><a name="925170"> </a><h4>Prototype </h4><dl><a name="925172"> </a><dt><code>Int16 StrNCaselessCompare (const&nbsp;Char*&nbsp;s1, const&nbsp;Char*&nbsp;s2, Int32&nbsp;n)</code></dl></dl><dl><a name="925173"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925174"> </a><CODE><code>s1</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to first string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925175"> </a><CODE><code>s2</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to second string. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925176"> </a><CODE><code>n</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length in bytes of the text to compare.<br></TD></TR></TABLE></dl><dl><a name="925177"> </a><h4>Result </h4><dl><a name="925178"> </a><p></p><dt>Returns 0 if the strings match.<a name="925179"> </a><p></p><dt>Returns a positive number if <code>s1</code> &gt; <code>s2</code>.<a name="925180"> </a><p></p><dt>Returns a negative number if <code>s1</code> &lt; <code>s2</code>.</dl></dl><dl><a name="925181"> </a><h4>Comments </h4><dl><a name="925183"> </a><p></p><dt>To support systems that use multi-byte character encodings, consider using <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code> instead of this function. Both functions can match single-byte characters with their multi-byte equivalents, but <code>TxtCaselessCompare</code> can also return the length of the matching text. </dl><a name="925187"> </a><h4>Compatibility </h4><dl><a name="925191"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl><a name="925192"> </a><h4>See Also </h4><dl><a name="925202"> </a><p></p><dt><code><a href="StringManager.html#925234"></code>StrNCompare<code></a></code>, <code><a href="StringManager.html#924927"></code>StrCaselessCompare<code></a></code>, <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code>, <code><a href="StringManager.html#925003"></code>StrCompare<code></a></code>, <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code> </dl></dl></dl><a name="925210"> </a><br> <br> <br><h3> StrNCat</h3><dl><dl><a name="925211"> </a><h4>Purpose </h4><dl><a name="925212"> </a><p></p><dt>Concatenates one string to another clipping the destination string to a maximum of <em>n</em> bytes (including the null character at the end).</dl><a name="925213"> </a><h4>Prototype </h4><dl><a name="925215"> </a><dt><code>Char* StrNCat (Char*&nbsp;dst, const&nbsp;Char*&nbsp;src, Int16&nbsp;n)</code></dl></dl><dl><a name="925216"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925217"> </a><CODE><code>dst</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to destination string. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925218"> </a><CODE><code>src</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to source string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925219"> </a><CODE><code>n</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum length in bytes for <code>dst</code>, including the terminating null character.<br></TD></TR></TABLE></dl><dl><a name="925220"> </a><h4>Result </h4><dl><a name="925221"> </a><p></p><dt>Returns a pointer to the destination string.</dl></dl><dl><a name="925222"> </a><h4> Comment</h4><dl><a name="925224"> </a><p></p><dt>This function differs from the standard C <code>strncat</code> function in these ways: <ul type="SQUARE"><a name="925225"> </a><br><li><code>StrNCat</code> treats the parameter <code>n</code> as the maximum length in bytes for <code>dst</code>. That means it will copy at most <code>n</code> - <code>StrLen(dst)</code> - 1 bytes from <code>src</code>. The standard C function always copies <code>n</code> bytes from <code>src</code> into <code>dst</code>. (It copies the entire <code>src</code> into <code>dst</code> if the length of <code>src</code> is less than <code>n</code>). <br><a name="925226"> </a><br><li>If the length of the destination string reaches <code>n</code> - 1, <code>StrNCat</code> stops copying bytes from <code>src</code> and appends the terminating null character to <code>dst</code>. If the length of the destination string is already greater than or equal to <code>n</code> - 1 before the copying begins, <code>StrNCat</code> does not copy any data from <code>src</code>. <br><a name="925227"> </a><br><li>In the standard C function, if <code>src</code> is less than <code>n</code>, the entire <code>src</code> string is copied into <code>dst</code> and then the remaining space is filled with null characters. <code>StrNCat</code> does not fill the remaining space with null characters in released ROMs. In debug ROMs, <code>StrNCat</code> fills the remaining bytes with the value <code>0xFE</code>. <br></ul></dl><a name="925228"> </a><h4>Compatibility </h4><dl><a name="925232"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl></dl></dl><a name="925234"> </a><br> <br> <br><h3> StrNCompare</h3><dl><dl><a name="925235"> </a><h4>Purpose </h4><dl><a name="925236"> </a><p></p><dt>Compare two strings out to <em>n</em> characters. This function is case and accent sensitive. </dl><a name="925237"> </a><h4>Prototype </h4><dl><a name="925239"> </a><dt><code>Int16 StrNCompare (const&nbsp;Char*&nbsp;s1, const&nbsp;Char*&nbsp;s2, UInt32&nbsp;n)</code></dl></dl><dl><a name="925240"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925241"> </a><CODE><code>s1</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to first string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925242"> </a><CODE><code>s2</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to second string. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925243"> </a><CODE><code>n</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length in bytes of text to compare. <br></TD></TR></TABLE></dl><dl><a name="925244"> </a><h4>Result </h4><dl><a name="925245"> </a><p></p><dt>Returns 0 if the strings match.<a name="925246"> </a><p></p><dt>Returns a positive number if <code>s1</code> &gt; <code>s2</code>.<a name="925247"> </a><p></p><dt>Returns a negative number if <code>s1</code> &lt; <code>s2</code>.</dl></dl><dl><a name="925248"> </a><h4>Comments </h4><dl><a name="925250"> </a><p></p><dt>To support systems that use multi-byte character encodings, consider using <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code> instead of this function. Both functions can match single-byte characters with their multi-byte equivalents, but <code>TxtCompare</code> can also return the length of the matching text. </dl><a name="925254"> </a><h4>Compatibility </h4><dl><a name="925258"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl><a name="925259"> </a><h4>See Also </h4><dl><a name="925269"> </a><p></p><dt><code><a href="StringManager.html#925003"></code>StrCompare<code></a></code>, <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code>, <code><a href="StringManager.html#925167"></code>StrNCaselessCompare<code></a></code>, <code><a href="StringManager.html#924927"></code>StrCaselessCompare<code></a></code>, <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code> </dl></dl></dl><a name="925277"> </a><br> <br> <br><h3> StrNCopy</h3><dl><dl><a name="925278"> </a><h4>Purpose </h4><dl><a name="925279"> </a><p></p><dt>Copies up to <em>n</em> characters from a source string to the destination string. Terminates <code>dst</code> string at index <em>n</em>-1 if the source string length was <em>n</em>-1 or less.</dl><a name="925280"> </a><h4>Prototype </h4><dl><a name="925282"> </a><dt><code>Char* StrNCopy (Char*&nbsp;dst, const&nbsp;Char*&nbsp;src, Int16&nbsp;n)</code></dl></dl><dl><a name="925283"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925284"> </a><CODE><code>dst</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Destination string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925285"> </a><CODE><code>src</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Source string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925286"> </a><CODE><code>n</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum number of bytes to copy from <code>src</code> string.<br></TD></TR></TABLE></dl><dl><a name="925287"> </a><h4>Result </h4><dl><a name="925288"> </a><p></p><dt>Returns nothing.</dl></dl><dl><a name="925289"> </a><h4>Comments </h4><dl><a name="925290"> </a><p></p><dt>On systems with multi-byte character encodings, this function makes sure that it does not copy part of a multi-byte character. If the <code>n</code>th byte of <code>src</code> contains the high-order or middle byte of a multi-byte character, <code>StrNCopy</code> backs up in <code>dst</code> until the byte after the end of the previous character, and replaces the remaining bytes (up to <code>n</code>-1) with nulls. </dl><a name="925291"> </a><h4>Compatibility </h4><dl><a name="925295"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl></dl></dl><a name="925297"> </a><br> <br> <br><h3> StrPrintF</h3><dl><dl><a name="925298"> </a><h4>Purpose </h4><dl><a name="925300"> </a><p></p><dt>Implements a subset of the ANSI C <code>sprintf</code> call, which writes formatted output to a string. </dl><a name="925301"> </a><h4>Prototype </h4><dl><a name="925303"> </a><dt><code>Int16 StrPrintF (Char*&nbsp;s, <br>const&nbsp;Char*&nbsp;formatStr, ...)</code></dl></dl><dl><a name="925304"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925305"> </a><CODE><code>s</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a string where the results are written.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925306"> </a><CODE><code>formatStr</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the format specification string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925307"> </a><CODE>...</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Zero or more arguments to be formatted as specified by <code>formatStr</code>.<br></TD></TR></TABLE></dl><dl><a name="925308"> </a><h4>Result </h4><dl><a name="925309"> </a><p></p><dt>Number of characters written to destination string. Returns a negative number if there is an error.</dl></dl><dl><a name="925310"> </a><h4>Comments </h4><dl><a name="925314"> </a><p></p><dt>This function internally calls <code><a href="StringManager.html#925361"></code>StrVPrintF<code></a></code> to do the formatting. See that function for details on which format specifications are supported.</dl><a name="925315"> </a><h4>Compatibility </h4><dl><a name="925319"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl><a name="925320"> </a><h4>See Also </h4><dl><a name="925324"> </a><p></p><dt><code><a href="StringManager.html#925361"></code>StrVPrintF<code></a> </code></dl></dl></dl><a name="925326"> </a><br> <br> <br><h3> StrStr</h3><dl><dl><a name="925327"> </a><h4>Purpose </h4><dl><a name="925328"> </a><p></p><dt>Look for a substring within a string. </dl><a name="925329"> </a><h4>Prototype </h4><dl><a name="925331"> </a><dt><code>Char* StrStr (const&nbsp;Char*&nbsp;str, const&nbsp;Char*&nbsp;token)</code></dl></dl><dl><a name="925332"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925333"> </a><CODE><code>str</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to search.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925334"> </a><CODE><code>token</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to search for.<br></TD></TR></TABLE></dl><dl><a name="925335"> </a><h4>Result </h4><dl><a name="925336"> </a><p></p><dt>Returns a pointer to the first occurrence of <code>token</code> in <code>str</code> or <code>NULL</code> if not found.</dl></dl><dl><a name="925337"> </a><h4>Comments </h4><dl><a name="925339"> </a><p></p><dt>Use this function instead of the standard <code>strstr</code> routine.<a name="925340"> </a><p></p><dt>On systems with multi-byte character encodings, this function makes sure that it does not match only part of a multi-byte character. If the matching strings begins at an inter-character boundary, then this function returns <code>NULL</code>. </dl><a name="925341"> </a><h4>See Also </h4><dl><a name="925345"> </a><p></p><dt><code><a href="StringManager.html#924980"></code>StrChr<code></a> </code></dl></dl></dl><a name="925347"> </a><br> <br> <br><h3> StrToLower</h3><dl><dl><a name="925348"> </a><h4>Purpose </h4><dl><a name="925349"> </a><p></p><dt>Convert all the characters in a string to lowercase. </dl><a name="925350"> </a><h4>Prototype </h4><dl><a name="925352"> </a><dt><code>Char* StrToLower (Char*&nbsp;dst, const&nbsp;Char*&nbsp;src)</code></dl></dl><dl><a name="925353"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925354"> </a><CODE><code>dst</code>, <code>src</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Two string pointers.<br></TD></TR></TABLE></dl><dl><a name="925355"> </a><h4>Result </h4><dl><a name="925356"> </a><p></p><dt>Returns a pointer to the destination string.</dl></dl><dl><a name="925357"> </a><h4>Compatibility </h4><dl><a name="925359"> </a><p></p><dt>Prior to Palm OS version 3.5, this function only converted accented characters on Japanese devices. On Palm OS version 3.5 and higher, all characters are appropriately lowercased, including accented characters on Latin devices.</dl></dl></dl><a name="925361"> </a><br> <br> <br><h3> StrVPrintF</h3><dl><dl><a name="925362"> </a><h4>Purpose </h4><dl><a name="925364"> </a><p></p><dt>Implements a subset of the ANSI C <code>vsprintf</code> call, which writes formatted output to a string.</dl><a name="926862"> </a><h4>Prototype </h4><dl><a name="926864"> </a><dt><code>Int16 StrVPrintF (Char*&nbsp;s, const&nbsp;Char*&nbsp;formatStr, _Palm_va_list&nbsp;argParam)</code></dl></dl><dl><a name="926865"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925369"> </a><CODE><code>s</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a string where the results are written. This string is always terminated by a null terminator.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925370"> </a><CODE><code>formatStr</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the format specification string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925371"> </a><CODE><code>argParam</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a list of zero or more parameters to be formatted as specified by the <code>formatStr</code> string.<br></TD></TR></TABLE></dl><dl><a name="925372"> </a><h4>Result </h4><dl><a name="925373"> </a><p></p><dt>Number of characters written to destination string, not including the null terminator. Returns a negative number if there is an error.</dl></dl><dl><a name="925374"> </a><h4>Comments </h4><dl><a name="925375"> </a><p></p><dt>Like the C <code>vsprintf</code> function, this function is designed to be called by your own function that takes a variable number of arguments and passes them to this function. For details on how to use it, see <a href="UserInterface.html#926403">"Using the StrVPrintF Function" </a> in <em>Palm OS Programmer's Companion</em>, or refer to <code>vsprintf</code> in a standard C reference book.<a name="925379"> </a><p></p><dt>Currently, only the conversion specifications <code>%d</code>, <code>%i</code>, <code>%u</code>, <code>%x</code>, <code>%s</code>, and <code>%c</code> are implemented by <code>StrVPrintF</code> (and related functions). Optional modifiers that are supported include: <code>+</code>, <code>-</code>, &lt;space&gt;, <code>*</code>, &lt;digits&gt;, <code>h</code> and <code>l</code> (long). Following is a brief description of how these format specifications work (see a C book for more details).<a name="925380"> </a><p></p><dt>Each conversion specification begins with the % character. Following the % character, there may be one or more of the characters list in <a href="StringManager.html#926028">Table 44.1</a>, in sequence.<p><a name="925518"> </a> </p><p><div> <table border="3"><caption><B><a name="926028"> </a><h4>Table 44.1	 StrVPrintF Format Specification&nbsp;</h4></B></caption><tr><th><a name="925388"> </a><strong>Character</strong></th><th colspan=2 rowspan=1><a name="925390"> </a><strong>Description</strong></th></tr><tr><td><a name="925394"> </a><code>+</code> </td><td colspan=2 rowspan=1><a name="925396"> </a>Specifies that a sign always be placed before a number produced by a signed conversion. A + overrides a space if both are used. Example: <a name="925397"> </a><code>StrPrintF(s,"%+d  %+d",4,-5);</code><a name="925398"> </a>Output to <code>s</code>:<a name="925399"> </a><code>+4  -5</code></td></tr><tr><td><a name="925403"> </a><code>-</code> </td><td colspan=2 rowspan=1><a name="925405"> </a>Specifies that the printed value is left justified within the field width allowed for it. Example: <a name="925406"> </a><code>StrPrintF(s,"%5d%-5d%d",6,9,8);</code><a name="925407"> </a>Output to <code>s</code>:<a name="925408"> </a><code>    69    8</code></td></tr><tr><td><a name="925412"> </a>&lt;space&gt;</td><td colspan=2 rowspan=1><a name="925414"> </a>Specifies that a minus sign always be placed before a negative number and a space before a positive number. Example: <a name="925415"> </a><code>StrPrintF(s,"%&nbsp;d  %&nbsp;d",4,-5);</code><a name="925416"> </a>Output to <code>s</code>:<a name="925417"> </a><code> 4  -5</code></td></tr><tr><td><a name="925421"> </a><code>*</code> </td><td colspan=2 rowspan=1><a name="925423"> </a>Indicates that the next argument (must be an integer) in the list specifies the field width. In this case, the argument following that one is used for the value of this field. Example: <a name="925424"> </a><code>StrPrintF(s,"%*d%d",4,8,5);</code><a name="925425"> </a>Output to <code>s</code>:<a name="925426"> </a><code>8   5</code></td></tr><tr><td><a name="925430"> </a>&lt;number&gt;</td><td colspan=2 rowspan=1><a name="925432"> </a>Specifies a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left justified flag is also specified) to fill out the field width. Example: <a name="925433"> </a><code>StrPrintF(s,"%d%5d",4,3);</code><a name="925434"> </a>Output to <code>s</code>:<a name="925435"> </a><code>4    3</code></td></tr><tr><td><a name="925439"> </a><code>h</code> </td><td colspan=2 rowspan=1><a name="925441"> </a>Specifies that the following d, i, u, or x conversion corresponds to a <code>short</code> or <code>unsigned short</code> argument. Example: <a name="925442"> </a><code>StrPrintF(s,"%hd",401);</code><a name="925443"> </a>Output to <code>s</code>:<a name="925444"> </a><code>401</code></td></tr><tr><td><a name="925448"> </a><code>l</code> or <code>L</code> </td><td colspan=2 rowspan=1><a name="925450"> </a>Specifies that the following d, i, u, or x conversion corresponds to a <code>long</code> or <code>unsigned long</code> <code>StrPrintF(s,"%ld",999999999);</code><a name="925452"> </a>Output to <code>s</code>:<a name="925453"> </a><code>999999999</code></td></tr><tr><td><a name="925457"> </a>&lt;character&gt;</td><td colspan=2 rowspan=1><a name="925459"> </a>A character that indicates the type of conversion to be performed. The supported conversion characters include:</td></tr><tr><td><a name="925463"> </a></td><td><a name="925465"> </a><code>d</code> <a name="925466"> </a>or<a name="925467"> </a><code>i</code></td><td><a name="925469"> </a>A signed integer argument is converted to decimal notation. Example: <a name="925470"> </a><code>StrPrintF(s,"%d   %d",4,-4);</code><a name="925471"> </a>Output to <code>s</code>:<a name="925472"> </a><code>4   -4</code></td></tr><tr><td><a name="925474"> </a></td><td><a name="925476"> </a><code>u</code> </td><td><a name="925478"> </a>An unsigned integer argument is converted to decimal notation. Example: <a name="925479"> </a><code>StrPrintF(s,"%u   %u",4,-4);</code><a name="925480"> </a>Output to <code>s</code>:<a name="925481"> </a><code>4   65532</code></td></tr><tr><td><a name="925483"> </a></td><td><a name="925485"> </a><code>x</code> </td><td><a name="925487"> </a>An integer argument is converted to hexadecimal notation. Example: <a name="925488"> </a><code>StrPrintF(s,"%x",125);</code><a name="925489"> </a>Output to <code>s</code>:<a name="925490"> </a><code>0000007D</code></td></tr><tr><td><a name="925492"> </a></td><td><a name="925494"> </a><code>s</code> </td><td><a name="925496"> </a>A string (<code>char *</code>) argument is copied to the destination string. Example: <a name="925497"> </a><code>StrPrintF(s,"ABC%s","DEF");</code><a name="925498"> </a>Output to <code>s</code>:<a name="925499"> </a><code>ABCDEF</code></td></tr><tr><td><a name="925501"> </a></td><td><a name="925503"> </a><code>c</code> </td><td><a name="925505"> </a>A single character (<code>int</code>) argument is copied to the destination string. Example: <a name="925506"> </a><code>StrPrintF(s,"Telephone%c",'s');</code><a name="925507"> </a>Output to <code>s</code>:<a name="925508"> </a><code>Telephones</code></td></tr><tr><td><a name="925510"> </a></td><td><a name="925512"> </a><code>%</code> </td><td><a name="925514"> </a>A % character is copied to the destination string. Example: <a name="925515"> </a><code>StrPrintF(s,"%%");</code><a name="925516"> </a>Output to <code>s</code>:<a name="925517"> </a><code>%</code></td></tr></table><table><tr><td></table></div></p></dl><a name="925519"> </a><h4>Example </h4><dl><a name="925520"> </a><p></p><dt>Here's an example of how to use this call:</dl></dl><dl><a name="925521"> </a><br><code>#include &lt;stdarg.h&gt;</code><br></dl><dl><a name="925522"> </a><code>void MyPrintF(Char* s, Char* formatStr, ...) <br>{</code><br><a name="925523"> </a><code>&nbsp&nbsp&nbsp va_list args;<br>	 Char text[0x100];</code><br><a name="925524"> </a><code>&nbsp&nbsp&nbsp va_start(args, formatStr);<br>	 StrVPrintF(text, formatStr, args);<br>	 va_end(args);</code><br><a name="925525"> </a><code>&nbsp&nbsp&nbsp MyPutS(text); <br>}</code><br></dl><dl><a name="925526"> </a><h4>Compatibility </h4><dl><a name="925530"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#483165">2.0 New Feature Set</a> is present.</dl><a name="925531"> </a><h4>See Also </h4><dl><a name="925539"> </a><p></p><dt><code><a href="StringManager.html#925297"></code>StrPrintF<code></a></code>, <a href="UserInterface.html#926403">Using the StrVPrintF Function</a><dl><a name="925559"> </a><p></p><dt><strong></strong></dl></dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="StandardIO.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="SystemEventManager.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 46 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:28:46 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/StringManager.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
</html>