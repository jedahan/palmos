<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/TextMgr.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
<head><title>Text Manager</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="SystemManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="Window.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924908"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>47 Text Manager</h1><dl><a name="924909"> </a><p></p><dt>This chapter provides information about the text manager by discussing these topics: <ul type="SQUARE"><a name="924913"> </a><br><li><a href="TextMgr.html#924924">Text Manager Data Structures</a> <br><a name="924917"> </a><br><li><a href="TextMgr.html#924983">Text Manager Functions</a><br></ul><a name="924919"> </a><p></p><dt>The header file <code>TextMgr.h</code> declares the API that this chapter describes. For more information on the text manager, see the chapter <a href="Localization.html#924904">"Localized Applications"</a> in the <em>Palm OS Programmer's Companion</em>. </dl><a name="924924"> </a><h2> Text Manager Data Structures</h2><a name="924927"> </a><h3> CharEncodingType</h3><dl><a name="924928"> </a><p></p><dt>The <code>CharEncodingType</code> enum specifies possible character encodings. A given device supports a single character encoding. The currently available devices support either Windows code page 1252 (an extension of ISO Latin 1) or Windows code page 932 (an extension of Shift JIS). <dl><a name="924929"> </a><br><code>typedef enum {</code><br></dl><dl><a name="924930"> </a><code>&nbsp&nbsp&nbsp charEncodingUnknown = 0,</code><br><a name="924931"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="924932"> </a><code>&nbsp&nbsp&nbsp charEncodingAscii,</code><br><a name="924933"> </a><code>&nbsp&nbsp&nbsp charEncodingISO8859_1,</code><br><a name="924934"> </a><code>&nbsp&nbsp&nbsp charEncodingPalmLatin,</code><br><a name="924935"> </a><code>&nbsp&nbsp&nbsp charEncodingShiftJIS,</code><br><a name="924936"> </a><code>&nbsp&nbsp&nbsp charEncodingPalmSJIS,</code><br><a name="924937"> </a><code>&nbsp&nbsp&nbsp charEncodingUTF8,</code><br><a name="924938"> </a><code>&nbsp&nbsp&nbsp charEncodingCP1252,</code><br><a name="924939"> </a><code>&nbsp&nbsp&nbsp charEncodingCP932</code><br><a name="924940"> </a><code>} CharEncodingType;</code><br></dl></dl><a name="924941"> </a><h4> Value Descriptions</h4><p><a name="924981"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="924945"> </a><code>charEncodingUnknown</code> </td><td><a name="924947"> </a>Unknown to this version of Palm OS<sup>&#174;</sup>.</td></tr><tr><td><a name="924949"> </a><code>charEncodingAscii</code> </td><td><a name="924951"> </a>ISO 646-1991.</td></tr><tr><td><a name="924953"> </a><code>charEncodingISO8859_1</code> </td><td><a name="924955"> </a>ISO 8859 Part 1 (also known as ISO Latin 1). This encoding is commonly used for the Roman alphabet. </td></tr><tr><td><a name="924957"> </a><code>charEncodingPalmLatin</code> </td><td><a name="924959"> </a>Palm OS version of Microsoft Windows code page 1252</td></tr><tr><td><a name="924961"> </a><code>charEncodingShiftJIS</code> </td><td><a name="924963"> </a>Encoding for 0208-1990 with <sub></sub>single-byte Japanese Katakana. This encoding is commonly used for Japanese alphabets. </td></tr><tr><td><a name="924965"> </a><code>charEncodingPalmSJIS </code></td><td><a name="924967"> </a>Palm OS version of Microsoft Windows code page 932</td></tr><tr><td><a name="924969"> </a><code>charEncodingCP1252</code> </td><td><a name="924971"> </a>Microsoft Windows extensions to ISO 8859 Part 1.</td></tr><tr><td><a name="924973"> </a><code>charEncodingCP932</code> </td><td><a name="924975"> </a>Microsoft Windows extensions to Shift JIS.</td></tr><tr><td><a name="924977"> </a><code>charEncodingUTF8</code> </td><td><a name="924979"> </a>Eight-bit safe encoding for Unicode.<code></code></td></tr></table><table><tr><td></table></div></p><a name="924983"> </a><h2> Text Manager Functions</h2><a name="924987"> </a><br> <br> <br><h3> TxtByteAttr</h3><dl><dl><a name="924988"> </a><h4>Purpose </h4><dl><a name="924990"> </a><p></p><dt>Return the possible locations of a given byte within a multi-byte character. </dl><a name="924991"> </a><h4>Prototype </h4><dl><a name="924992"> </a><dt><code>UInt8 TxtByteAttr (UInt8&nbsp;inByte)</code></dl></dl><dl><a name="924993"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="924994"> </a><CODE><code>-&gt; inByte</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A byte representing all or part of a valid character.<br></TD></TR></TABLE></dl><dl><a name="924995"> </a><h4>Result </h4><dl><a name="924996"> </a><p></p><dt>Returns a byte with one or more of the following bits set:<p><a name="925018"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><p><a name="925000"> </a> <code>byteAttrFirst</code></p></th><th><p><a name="925002"> </a> First byte of multi-byte character.</p></th></tr><tr><td><p><a name="925005"> </a> <code>byteAttrLast</code></p></td><td><p><a name="925007"> </a> Last byte of multi-byte character.</p></td></tr><tr><td><p><a name="925010"> </a> <code>byteAttrMiddle</code></p></td><td><p><a name="925012"> </a> Middle byte of multi-byte character.</p></td></tr><tr><td><p><a name="925015"> </a> <code>byteAttrSingle</code></p></td><td><p><a name="925017"> </a> Single-byte character.</p></td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925019"> </a><h4>Comments </h4><dl><a name="925020"> </a><p></p><dt>If <code>inByte</code> is valid in more than one location of a character, multiple return bits are set. For example, 0x40 in the Shift JIS character encoding is valid as a single-byte character and as the low-order byte of a double-byte character. Thus, the return value for <code>TxtByteAttr(0x40)</code> on a Shift JIS system has both the <code>byteAttrSingle</code> and <code>byteAttrLast</code> bits set. <a name="925021"> </a><p></p><dt>Text manager functions that need to determine the byte positioning of a character use <code>TxtByteAttr</code> to do so. You rarely need to use this function yourself. </dl><a name="925022"> </a><h4>Compatibility </h4><dl><a name="925026"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925029"> </a><br> <br> <br><h3> TxtCaselessCompare</h3><dl><dl><a name="925030"> </a><h4>Purpose </h4><dl><a name="925032"> </a><p></p><dt>Perform a case-insensitive comparison of two text buffers. </dl><a name="930617"> </a><h4>Prototype </h4><dl><a name="930618"> </a><dt><code>Int16 TxtCaselessCompare (const&nbsp;Char*&nbsp;s1, UInt16&nbsp;s1Len, UInt16*&nbsp;s1MatchLen, const&nbsp;Char*&nbsp;s2, UInt16&nbsp;s2Len, UInt16*&nbsp;s2MatchLen)</code></dl></dl><dl><a name="925035"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925036"> </a><CODE><code>-&gt; s1</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the first text buffer to compare. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925037"> </a><CODE><code>-&gt; s1Len</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length in bytes of the text pointed to by <code>s1</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925038"> </a><CODE><code>&lt;- s1MatchLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Points to the length in bytes of the text in <code>s1</code> that matched text in <code>s2</code>. Pass <code>NULL</code> for this parameter if you don't need to know this number. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925039"> </a><CODE><code>-&gt; s2</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the second text buffer to compare. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925040"> </a><CODE><code>-&gt; s2Len</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length in bytes of the text pointed to by <code>s2</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925041"> </a><CODE><code>&lt;- s2MatchLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Points to the length in bytes of the text in <code>s2</code> that matched text in <code>s1</code>. Pass <code>NULL</code> for this parameter if you don't need to know this number. <br></TD></TR></TABLE></dl><dl><a name="925042"> </a><h4>Result </h4><dl><a name="925043"> </a><p></p><dt>Returns one of the following values: <p><a name="925057"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925046"> </a>&lt; 0 </td><td><a name="925048"> </a>If <code>s1</code> occurs before <code>s2</code> in alphabetical order.</td></tr><tr><td><a name="925050"> </a>&gt; 0 </td><td><a name="925052"> </a>If <code>s1</code> occurs after <code>s2</code> in alphabetical order.</td></tr><tr><td><a name="925054"> </a>0 </td><td><a name="925056"> </a>If the two substrings that were compared are equal. </td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925058"> </a><h4>Comments </h4><dl><a name="925059"> </a><p></p><dt>In certain character encodings (such as Shift JIS), one character may be accurately represented as either a single-byte character or a multi-byte character. <code>TxtCaselessCompare</code> accurately matches a single-byte character with its multi-byte equivalent. For this reason, the values returned in <code>s1MatchLen</code> and <code>s2MatchLen</code> are not always equal. <a name="925060"> </a><p></p><dt>You must make sure that the parameters <code>s1</code> and <code>s2</code> point to a the start of a valid character. That is, they must point to the first byte of a multi-byte character or they must point to a single-byte character. If they don't, results are unpredictable. </dl><a name="925061"> </a><h4>Compatibility </h4><dl><a name="925065"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925066"> </a><h4>See Also </h4><dl><a name="925076"> </a><p></p><dt><code><a href="StringManager.html#924927"></code>StrCaselessCompare<code></a></code>, <code><a href="TextMgr.html#925610"></code>TxtCompare<code></a></code>, <code><a href="StringManager.html#925003"></code>StrCompare<code></a></code> </dl></dl></dl><a name="925079"> </a><br> <br> <br><h3> TxtCharAttr</h3><dl><dl><a name="925080"> </a><h4>Purpose </h4><dl><a name="925082"> </a><p></p><dt>Return a character's attributes. </dl><a name="925083"> </a><h4>Prototype </h4><dl><a name="925084"> </a><dt><code>UInt16 TxtCharAttr (WChar&nbsp;inChar)</code></dl></dl><dl><a name="925085"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925086"> </a><CODE><code>-&gt; inChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Any valid character. <br></TD></TR></TABLE></dl><dl><a name="925087"> </a><h4>Result </h4><dl><a name="925088"> </a><p></p><dt>Returns a 16-bit unsigned value with any of the following bits set:<p><a name="925125"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><p><a name="925092"> </a> <code>charAttrPrint</code></p></th><th><p><a name="925094"> </a> Printable</p></th></tr><tr><td><p><a name="925097"> </a> <code>charAttrSpace</code></p></td><td><p><a name="925099"> </a> Blank space, tab, or newline</p></td></tr><tr><td><p><a name="925102"> </a> <code>charAttrAlNum</code></p></td><td><p><a name="925104"> </a> Alphanumeric</p></td></tr><tr><td><p><a name="925107"> </a> <code>charAttrAlpha</code></p></td><td><p><a name="925109"> </a> Alphabetic</p></td></tr><tr><td><p><a name="925112"> </a> <code>charAttrCntrl</code></p></td><td><p><a name="925114"> </a> Control character</p></td></tr><tr><td><p><a name="925117"> </a> <code>charAttrGraph</code></p></td><td><p><a name="925119"> </a> Character that appears on the screen; that is, is not whitespace, a control character, or a virtual character. </p></td></tr><tr><td><p><a name="925122"> </a> <code>charAttrDelim</code></p></td><td><p><a name="925124"> </a> Word delimiter (whitespace or punctuation). </p></td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925126"> </a><h4>Comments </h4><dl><a name="925127"> </a><p></p><dt>The character passed to this function must be a valid character given the system encoding. <a name="925128"> </a><p></p><dt>This function is used in the text manager's character attribute macros (<code><a href="TextMgr.html#925214"></code>TxtCharIsAlNum<code></a></code>, <code><a href="TextMgr.html#925267"></code>TxtCharIsCntrl<code></a></code>, and so on). The macros perform operations analogous to the standard C functions <code>isPunct</code>, <code>isPrintable</code>, and so on. Usually, you'd use one of these macros instead of calling <code>TxtCharAttr</code> directly. <a name="925135"> </a><p></p><dt>To obtain attributes specific to a given character encoding, use <code><a href="TextMgr.html#925579"></code>TxtCharXAttr<code></a>.</code></dl><a name="925139"> </a><h4>Compatibility </h4><dl><a name="925143"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925144"> </a><h4>See Also </h4><dl><a name="925148"> </a><p></p><dt><code><a href="TextMgr.html#925509"></code>TxtCharIsValid<code></a></code> </dl></dl></dl><a name="925151"> </a><br> <br> <br><h3> TxtCharBounds</h3><dl><dl><a name="925152"> </a><h4>Purpose </h4><dl><a name="925154"> </a><p></p><dt>Return the boundaries of a character containing the byte at a specified offset in a string. </dl><a name="925155"> </a><h4>Prototype </h4><dl><a name="925156"> </a><dt><code>WChar TxtCharBounds (const&nbsp;Char*&nbsp;inText, UInt32&nbsp;inOffset, UInt32*&nbsp;outStart, UInt32*&nbsp;outEnd)</code></dl></dl><dl><a name="925157"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925158"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the text buffer to search. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925159"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. This location may contain a byte in any position (start, middle, or end) of a multi-byte character.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925160"> </a><CODE><code>&lt;- outStart</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Points to the starting offset of the character containing the byte at <code>inOffset</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925161"> </a><CODE><code>&lt;- outEnd</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Points to the ending offset of the character containing the byte at <code>inOffset</code>.<br></TD></TR></TABLE></dl><dl><a name="925162"> </a><h4>Result </h4><dl><a name="925163"> </a><p></p><dt>Returns the character located between the offsets <code>outStart</code> and <code>outEnd</code>. </dl></dl><dl><a name="925164"> </a><h4>Comments </h4><dl><a name="925165"> </a><p></p><dt>Use this function to determine the boundaries of a character in a string or text buffer. <a name="925166"> </a><p></p><dt>If the byte at <code>inOffset</code> is valid in more than one location of a character, the function must search back toward the beginning of the text buffer until it finds an unambiguous byte to determine the appropriate boundaries. For this reason, <code>TxtCharBounds</code> is often slow and should be used only where needed. <a name="925167"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the beginning of the string. That is, if the string begins with a multi-byte character, <code>inText</code> must point to the first byte of that character. If it doesn't, results are unpredictable. </dl><a name="925168"> </a><h4>Compatibility </h4><dl><a name="925172"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925175"> </a><br> <br> <br><h3> TxtCharEncoding</h3><dl><dl><a name="925176"> </a><h4>Purpose </h4><dl><a name="925178"> </a><p></p><dt>Return the minimum encoding required to represent a character. </dl><a name="925179"> </a><h4>Prototype </h4><dl><a name="925180"> </a><dt><code>CharEncodingType TxtCharEncoding (WChar&nbsp;inChar)</code></dl></dl><dl><a name="925181"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925182"> </a><CODE><code>-&gt; inChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character. <br></TD></TR></TABLE></dl><dl><a name="925183"> </a><h4>Result </h4><dl><a name="925187"> </a><p></p><dt>A <code><a href="TextMgr.html#924927"></code>CharEncodingType<code></a></code> value that indicates the minimum encoding required to represent <code>inChar</code>. If the character isn't recognizable, <code>charEncodingUnknown</code> is returned. </dl></dl><dl><a name="925188"> </a><h4>Comments </h4><dl><a name="925189"> </a><p></p><dt>The minimum encoding is the encoding that takes the lowest number of bytes to represent the character. For example, if the character is a blank or a tab character, the minimum encoding is <code>charEncodingAscii</code> because these characters can be represented in single-byte ASCII. If the character is a &uuml;, the minimum encoding is <code>charEncodingISO8859_1</code>. <a name="925190"> </a><p></p><dt>Because Palm OS<sup>&#174;</sup> only supports a single character encoding at a time, the result of this function is always logically equal to or less than the encoding used on the current system. That is, you'll only receive a return value of <code>charEncodingISO8859_1</code> if you're running on a US or European system and you pass a non-ASCII character. <a name="925191"> </a><p></p><dt>Use this function for informational purposes only. Your code should not assume that the character encoding returned by this function is the Palm OS system character encoding. (Instead use <code>FtrGet</code> as shown in the <code><a href="TextMgr.html#925579"></code>TxtCharXAttr<code></a></code> function description.)<a name="925198"> </a><p></p><dt>Use <code><a href="TextMgr.html#925870"></code>TxtMaxEncoding<code></a></code> to determine the order of encodings. </dl><a name="925199"> </a><h4>Compatibility </h4><dl><a name="925203"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925204"> </a><h4>See Also </h4><dl><a name="925211"> </a><p></p><dt><code><a href="TextMgr.html#926036"></code>TxtStrEncoding<code></a></code>, <code><a href="TextMgr.html#925870"></code>TxtMaxEncoding<code></a></code></dl></dl></dl><a name="925214"> </a><br> <br> <br><h3> TxtCharIsAlNum</h3><dl><dl><a name="925215"> </a><h4>Purpose </h4><dl><a name="925217"> </a><p></p><dt>Macro that indicates if the character is alphanumeric. </dl><a name="925218"> </a><h4>Prototype </h4><dl><a name="925219"> </a><dt><code>TxtCharIsAlNum (ch)</code></dl></dl><dl><a name="925220"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925221"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925222"> </a><h4>Result </h4><dl><a name="925223"> </a><p></p><dt>Returns <code>true</code> if the character is a letter in an alphabet or a numeric digit, <code>false</code> otherwise. </dl></dl><dl><a name="925224"> </a><h4>Compatibility </h4><dl><a name="925228"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925229"> </a><h4>See Also </h4><dl><a name="925236"> </a><p></p><dt><code><a href="TextMgr.html#925301"></code>TxtCharIsDigit<code></a></code>, <code><a href="TextMgr.html#925239"></code>TxtCharIsAlpha<code></a></code> </dl></dl></dl><a name="925239"> </a><br> <br> <br><h3> TxtCharIsAlpha</h3><dl><dl><a name="925240"> </a><h4>Purpose </h4><dl><a name="925242"> </a><p></p><dt>Macro that indicates if a character is a letter in an alphabet. </dl><a name="925243"> </a><h4>Prototype </h4><dl><a name="925244"> </a><dt><code>TxtCharIsAlpha (ch)</code></dl></dl><dl><a name="925245"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925246"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925247"> </a><h4>Result </h4><dl><a name="925248"> </a><p></p><dt>Returns <code>true</code> if the character is a letter in an alphabet, <code>false</code> otherwise. </dl></dl><dl><a name="925249"> </a><h4>Compatibility </h4><dl><a name="925253"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925254"> </a><h4>See Also </h4><dl><a name="925264"> </a><p></p><dt><code><a href="TextMgr.html#925214"></code>TxtCharIsAlNum<code></a></code>, <code><a href="TextMgr.html#925398"></code>TxtCharIsLower<code></a></code>, <code><a href="TextMgr.html#925484"></code>TxtCharIsUpper<code></a></code></dl></dl></dl><a name="925267"> </a><br> <br> <br><h3> TxtCharIsCntrl</h3><dl><dl><a name="925268"> </a><h4>Purpose </h4><dl><a name="925270"> </a><p></p><dt>Macro that indicates if a character is a control character. </dl><a name="925271"> </a><h4>Prototype </h4><dl><a name="925272"> </a><dt><code>TxtCharIsCntrl (ch)</code></dl></dl><dl><a name="925273"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925274"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925275"> </a><h4>Result </h4><dl><a name="925276"> </a><p></p><dt>Returns <code>true</code> if the character is a non-printable character, such as the bell character or a carriage return; <code>false</code> otherwise. </dl></dl><dl><a name="925277"> </a><h4>Compatibility </h4><dl><a name="925281"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925284"> </a><br> <br> <br><h3> TxtCharIsDelim</h3><dl><dl><a name="925285"> </a><h4>Purpose </h4><dl><a name="925287"> </a><p></p><dt>Macro that indicates if a character is a delimiter. </dl><a name="925288"> </a><h4>Prototype </h4><dl><a name="925289"> </a><dt><code>TxtCharIsDelim (ch)</code></dl></dl><dl><a name="925290"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925291"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925292"> </a><h4>Result </h4><dl><a name="925293"> </a><p></p><dt>Returns <code>true</code> if the character is a word delimiter (whitespace or punctuation), <code>false</code> otherwise. </dl></dl><dl><a name="925294"> </a><h4>Compatibility </h4><dl><a name="925298"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925301"> </a><br> <br> <br><h3> TxtCharIsDigit</h3><dl><dl><a name="925302"> </a><h4>Purpose </h4><dl><a name="925304"> </a><p></p><dt>Macro that indicates if the character is a decimal digit. </dl><a name="925305"> </a><h4>Prototype </h4><dl><a name="925306"> </a><dt><code>TxtCharIsDigit (ch)</code></dl></dl><dl><a name="925307"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925308"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925309"> </a><h4>Result 	 </h4><dl><a name="925310"> </a><p></p><dt>Returns <code>true</code> if the character is 0 through 9, <code>false</code> otherwise. </dl></dl><dl><a name="925311"> </a><h4>Compatibility </h4><dl><a name="925315"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925316"> </a><h4>See Also </h4><dl><a name="925323"> </a><p></p><dt><code><a href="TextMgr.html#925214"></code>TxtCharIsAlNum<code></a></code>, <code><a href="TextMgr.html#925376"></code>TxtCharIsHex<code></a></code> </dl></dl></dl><a name="925326"> </a><br> <br> <br><h3> TxtCharIsGraph</h3><dl><dl><a name="925327"> </a><h4>Purpose </h4><dl><a name="925329"> </a><p></p><dt>Macro that indicates if a character is a graphic character.</dl><a name="925330"> </a><h4>Prototype </h4><dl><a name="925331"> </a><dt><code>TxtCharIsGraph (ch)</code></dl></dl><dl><a name="925332"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925333"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925334"> </a><h4>Result </h4><dl><a name="925336"> </a><p></p><dt>Returns <code>true</code> if the character is a graphic character, false otherwise. </dl></dl><dl><a name="925337"> </a><h4>Comments </h4><dl><a name="925338"> </a><p></p><dt>A graphic character is any character visible on the screen, in other words, letters, digits, and punctuation marks. A blank space is not a graphic character because it is not visible. </dl><a name="925339"> </a><h4>Compatibility </h4><dl><a name="925343"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925344"> </a><h4>See Also </h4><dl><a name="925348"> </a><p></p><dt><code><a href="TextMgr.html#925423"></code>TxtCharIsPrint<code></a></code> </dl></dl></dl><a name="925351"> </a><br> <br> <br><h3> TxtCharIsHardKey</h3><dl><dl><a name="925352"> </a><h4>Purpose </h4><dl><a name="925353"> </a><p></p><dt>Macro that returns true if the character is one of the hard keys on the device.</dl><a name="925354"> </a><h4>Prototype </h4><dl><a name="925355"> </a><dt><code>TxtCharIsHardKey (m, ch)</code></dl></dl><dl><a name="925356"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925360"> </a><CODE>-&gt; <code>m</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The modifier keys from the <code><a href="EventRef.html#925881"></code>keyDownEvent<code></a></code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925361"> </a><CODE>-&gt; <code>ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The character from the <code>keyDownEvent</code>.<br></TD></TR></TABLE></dl><dl><a name="925362"> </a><h4>Result </h4><dl><a name="925363"> </a><p></p><dt><code>true</code> if the character is one of the four built-in hard keys on the device, <code>false</code> otherwise. </dl></dl><dl><a name="925364"> </a><h4>Compatibility </h4><dl><a name="925368"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925369"> </a><h4>See Also </h4><dl><a name="925373"> </a><p></p><dt><code><a href="CharacterAttributes.html#924931"></code>ChrIsHardKey<code></a></code> </dl></dl></dl><a name="925376"> </a><br> <br> <br><h3> TxtCharIsHex</h3><dl><dl><a name="925377"> </a><h4>Purpose </h4><dl><a name="925379"> </a><p></p><dt>Macro that indicates if a character is a hexadecimal digit. </dl><a name="925380"> </a><h4>Prototype </h4><dl><a name="925381"> </a><dt><code>TxtCharIsHex (ch)</code></dl></dl><dl><a name="925382"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925383"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925384"> </a><h4>Result </h4><dl><a name="925385"> </a><p></p><dt>Returns <code>true</code> if the character is a hexadecimal digit from 0 to F, <code>false</code> otherwise. </dl></dl><dl><a name="925386"> </a><h4>Compatibility </h4><dl><a name="925390"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925391"> </a><h4>See Also </h4><dl><a name="925395"> </a><p></p><dt><code><a href="TextMgr.html#925301"></code>TxtCharIsDigit<code></a></code> </dl></dl></dl><a name="925398"> </a><br> <br> <br><h3> TxtCharIsLower</h3><dl><dl><a name="925399"> </a><h4>Purpose </h4><dl><a name="925401"> </a><p></p><dt>Macro that indicates if a character is a lowercase letter. </dl><a name="925402"> </a><h4>Prototype </h4><dl><a name="925403"> </a><dt><code>TxtCharIsLower (ch)</code></dl></dl><dl><a name="925404"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925405"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925406"> </a><h4>Result </h4><dl><a name="925407"> </a><p></p><dt>Returns <code>true</code> if the character is a lowercase letter, <code>false</code> otherwise. </dl></dl><dl><a name="925408"> </a><h4>Compatibility </h4><dl><a name="925412"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925413"> </a><h4>See Also </h4><dl><a name="925420"> </a><p></p><dt><code><a href="TextMgr.html#925239"></code>TxtCharIsAlpha<code></a></code>, <code><a href="TextMgr.html#925484"></code>TxtCharIsUpper<code></a></code> </dl></dl></dl><a name="925423"> </a><br> <br> <br><h3> TxtCharIsPrint</h3><dl><dl><a name="925424"> </a><h4>Purpose </h4><dl><a name="925426"> </a><p></p><dt>Macro that indicates if a character is printable. </dl><a name="925427"> </a><h4>Prototype </h4><dl><a name="925428"> </a><dt><code>TxtCharIsPrint (ch)</code></dl></dl><dl><a name="925429"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925430"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925431"> </a><h4>Result </h4><dl><a name="925432"> </a><p></p><dt>Returns <code>true</code> if the character is not a control or virtual character, <code>false</code> otherwise. </dl></dl><dl><a name="925433"> </a><h4>Comments </h4><dl><a name="925437"> </a><p></p><dt>This function differs from <code><a href="TextMgr.html#925326"></code>TxtCharIsGraph<code></a></code> in that it returns <code>true</code> if the character is whitespace. <code>TxtCharIsGraph</code> returns <code>false</code> if the character is whitespace. </dl><a name="925438"> </a><h4>Compatibility </h4><dl><a name="925442"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925443"> </a><h4>See Also </h4><dl><a name="925447"> </a><p></p><dt><code><a href="TextMgr.html#925509"></code>TxtCharIsValid<code></a></code> </dl></dl></dl><a name="925450"> </a><br> <br> <br><h3> TxtCharIsPunct</h3><dl><dl><a name="925451"> </a><h4>Purpose </h4><dl><a name="925453"> </a><p></p><dt>Macro that indicates if a character is a punctuation mark. </dl><a name="925454"> </a><h4>Prototype </h4><dl><a name="925455"> </a><dt><code>TxtCharIsPunct (ch)</code></dl></dl><dl><a name="925456"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925457"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925458"> </a><h4>Result </h4><dl><a name="925459"> </a><p></p><dt>Returns <code>true</code> if the character is a punctuation mark, <code>false</code> otherwise. </dl></dl><dl><a name="925460"> </a><h4>Compatibility </h4><dl><a name="925464"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925467"> </a><br> <br> <br><h3> TxtCharIsSpace</h3><dl><dl><a name="925468"> </a><h4>Purpose </h4><dl><a name="925470"> </a><p></p><dt>Macro that indicates if a character is a whitespace character.</dl><a name="925471"> </a><h4>Prototype </h4><dl><a name="925472"> </a><dt><code>TxtCharIsSpace (ch)</code></dl></dl><dl><a name="925473"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925474"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925475"> </a><h4>Result </h4><dl><a name="925476"> </a><p></p><dt>Returns <code>true</code> if the character is whitespace such as a blank space, tab, or newline; <code>false</code> otherwise. </dl></dl><dl><a name="925477"> </a><h4>Compatibility </h4><dl><a name="925481"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925484"> </a><br> <br> <br><h3> TxtCharIsUpper</h3><dl><dl><a name="925485"> </a><h4>Purpose </h4><dl><a name="925487"> </a><p></p><dt>Macro that indicates if a character is an uppercase letter. </dl><a name="925488"> </a><h4>Prototype </h4><dl><a name="925489"> </a><dt><code>TxtCharIsUpper (ch)</code></dl></dl><dl><a name="925490"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925491"> </a><CODE><code>-&gt; ch</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925492"> </a><h4>Result </h4><dl><a name="925493"> </a><p></p><dt>Returns <code>true</code> if the character is an uppercase letter, <code>false</code> otherwise. </dl></dl><dl><a name="925494"> </a><h4>Compatibility </h4><dl><a name="925498"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925499"> </a><h4>See Also </h4><dl><a name="925506"> </a><p></p><dt><code><a href="TextMgr.html#925239"></code>TxtCharIsAlpha<code></a></code>, <code><a href="TextMgr.html#925398"></code>TxtCharIsLower<code></a></code> </dl></dl></dl><a name="925509"> </a><br> <br> <br><h3> TxtCharIsValid</h3><dl><dl><a name="925510"> </a><h4>Purpose </h4><dl><a name="925512"> </a><p></p><dt>Determine whether a character is valid character given the Palm OS character encoding. </dl><a name="925513"> </a><h4>Prototype </h4><dl><a name="925514"> </a><dt><code>Boolean TxtCharIsValid (WChar&nbsp;inChar)</code></dl></dl><dl><a name="925515"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925516"> </a><CODE><code>-&gt; inChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A character. <br></TD></TR></TABLE></dl><dl><a name="925517"> </a><h4>Result </h4><dl><a name="925518"> </a><p></p><dt>Returns <code>true</code> if <code>inChar</code> is a valid character; <code>false</code> if <code>inChar</code> is not a valid character. </dl></dl><dl><a name="925519"> </a><h4>Compatibility </h4><dl><a name="925523"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925524"> </a><h4>See Also </h4><dl><a name="925531"> </a><p></p><dt><code><a href="TextMgr.html#925079"></code>TxtCharAttr<code></a></code>, <code><a href="TextMgr.html#925423"></code>TxtCharIsPrint<code></a></code> </dl></dl></dl><a name="925534"> </a><br> <br> <br><h3> TxtCharSize</h3><dl><dl><a name="925535"> </a><h4>Purpose </h4><dl><a name="925537"> </a><p></p><dt>Return the number of bytes required to store the character in a string. </dl><a name="925538"> </a><h4>Prototype </h4><dl><a name="925539"> </a><dt><code>UInt16 TxtCharSize (WChar&nbsp;inChar)</code></dl></dl><dl><a name="925540"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925541"> </a><CODE><code>-&gt; inChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character. <br></TD></TR></TABLE></dl><dl><a name="925542"> </a><h4>Result </h4><dl><a name="925543"> </a><p></p><dt>The the number of bytes required to store the character in a string. </dl></dl><dl><a name="925544"> </a><h4>Comments </h4><dl><a name="925545"> </a><p></p><dt>Outside of strings, characters are always two-byte long <code>WChar</code> values; however, strings may store characters as a single-byte value. If the character can be represented by a single byte (its high-order byte is 0), it is stored in a string as a single-byte character. </dl><a name="925546"> </a><h4>Compatibility </h4><dl><a name="925550"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925551"> </a><h4>See Also </h4><dl><a name="925555"> </a><p></p><dt><code><a href="TextMgr.html#925151"></code>TxtCharBounds<code></a></code> </dl></dl></dl><a name="925558"> </a><br> <br> <br><h3> TxtCharWidth</h3><dl><dl><a name="925559"> </a><h4>Purpose </h4><dl><a name="925560"> </a><p></p><dt>Return the width required to display the specified character in the current font. If the specified character does not exist within the current font, the missing character symbol is substituted.</dl><a name="925561"> </a><h4>Prototype </h4><dl><a name="925562"> </a><dt><code>Int16 TxtCharWidth (WChar&nbsp;inChar)</code></dl></dl><dl><a name="925563"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925564"> </a><CODE><code>-&gt; inChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925565"> </a><h4>Result </h4><dl><a name="925566"> </a><p></p><dt>Returns the width of the specified character (in pixels).</dl></dl><dl><a name="925567"> </a><h4>Comments </h4><dl><a name="925571"> </a><p></p><dt>Use this function instead of <code><a href="Font.html#925012"></code>FntCharWidth<code></a></code> to determine the width of a single-byte or multi-byte character. </dl><a name="925572"> </a><h4>Compatibility </h4><dl><a name="925576"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925579"> </a><br> <br> <br><h3> TxtCharXAttr</h3><dl><dl><a name="925580"> </a><h4>Purpose </h4><dl><a name="925582"> </a><p></p><dt>Return the extended attribute bits for a character.</dl><a name="925583"> </a><h4>Prototype </h4><dl><a name="925584"> </a><dt><code>UInt16 TxtCharXAttr (WChar inChar)</code></dl></dl><dl><a name="925585"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925586"> </a><CODE><code>-&gt; inChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid character.<br></TD></TR></TABLE></dl><dl><a name="925587"> </a><h4>Result </h4><dl><a name="925588"> </a><p></p><dt>Returns an unsigned 16-bit value with one or more extended attribute bits set. For specific return values, look in the header files that are specific to certain character encodings (<code>CharLatin.h</code> or <code>CharShiftJIS.h</code>). </dl></dl><dl><a name="925589"> </a><h4>Comments </h4><dl><a name="925590"> </a><p></p><dt>To interpret the results, you must know the character encoding being used. Use <code><a href="FeatureManager.html#924918"></code>FtrGet<code></a></code> with <code>sysFtrNumEncoding</code> as the feature number to determine the character encoding. This returns one of the <code><a href="TextMgr.html#924927"></code>CharEncodingType<code></a></code> values. For example:</dl></dl><dl><a name="925597"> </a><br><code>WChar ch;<br>UInt16 encoding, attr; <br>...<br>attr = TxtCharXAttr(ch);<br>if (FtrGet(sysFtrCreator, sysFtrNumEncoding, <br>	 &amp;encoding) != 0)<br>	 encoding = charEncodingCP1252;;<br>if (encoding == charEncodingUTF8) {<br>}</code><br></dl><dl><a name="925598"> </a><h4>Compatibility </h4><dl><a name="925602"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925603"> </a><h4>See Also </h4><dl><a name="925607"> </a><p></p><dt><code><a href="TextMgr.html#925079"></code>TxtCharAttr<code></a></code> </dl></dl></dl><a name="925610"> </a><br> <br> <br><h3> TxtCompare</h3><dl><dl><a name="925611"> </a><h4>Purpose </h4><dl><a name="925613"> </a><p></p><dt>Performs a case-sensitive comparison of all or part of two text buffers.</dl><a name="925614"> </a><h4>Prototype </h4><dl><a name="925615"> </a><dt><code>Int16 TxtCompare (const&nbsp;Char*&nbsp;s1, UInt16&nbsp;s1Len, UInt16*&nbsp;s1MatchLen, const&nbsp;Char*&nbsp;s2, UInt16&nbsp;s2Len, UInt16*&nbsp;s2MatchLen)</code></dl></dl><dl><a name="925616"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925617"> </a><CODE><code>-&gt; s1</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the first text buffer to compare. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925618"> </a><CODE><code>-&gt; s1Len</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The length in bytes of the text pointed to by <code>s1</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925619"> </a><CODE><code>&lt;- s1MatchLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Points to the length in bytes of the text in <code>s1</code> that matched text in <code>s2</code>. Pass <code>NULL</code> for this parameter if you don't need to know this number. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925620"> </a><CODE><code>-&gt; s2</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the second text buffer to compare. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925621"> </a><CODE><code>-&gt; s2Len</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The length in bytes of the text pointed to by <code>s2</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925622"> </a><CODE><code>&lt;- s2MatchLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Points to the length in bytes of the text in <code>s2</code> that matched text in <code>s1</code>. Pass <code>NULL</code> for this parameter if you don't need to know this number. <br></TD></TR></TABLE></dl><dl><a name="925623"> </a><h4>Result </h4><dl><a name="925624"> </a><p></p><dt>Returns one of the following values: <p><a name="925638"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925627"> </a>&lt; 0 </td><td><a name="925629"> </a>If <code>s1</code> occurs before <code>s2</code> in alphabetical order.</td></tr><tr><td><a name="925631"> </a>&gt; 0 </td><td><a name="925633"> </a>If <code>s1</code> occurs after <code>s2</code> in alphabetical order.</td></tr><tr><td><a name="925635"> </a>0 </td><td><a name="925637"> </a>If the two substrings that were compared are equal. </td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925639"> </a><h4>Comments </h4><dl><a name="925640"> </a><p></p><dt>In certain character encodings (such as Shift JIS), one character may be accurately represented as either a single-byte character or a multi-byte character. <code>TxtCompare</code> accurately matches a single-byte character with its multi-byte equivalent. For this reason, the values returned in <code>s1MatchLen</code> and <code>s2MatchLen</code> are not always equal. <a name="925641"> </a><p></p><dt>This function performs a case-sensitive comparison. If you want to perform a case-insensitive comparison, use <code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code>.<a name="925645"> </a><p></p><dt>You must make sure that the parameters <code>s1</code> and <code>s2</code> point to the start of a a valid character. That is, they must point to the first byte of a multi-byte character or they must point to a single-byte character. If they don't, results are unpredictable. </dl><a name="925646"> </a><h4>Compatibility </h4><dl><a name="925650"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925651"> </a><h4>See Also </h4><dl><a name="925658"> </a><p></p><dt><code><a href="StringManager.html#925003"></code>StrCompare<code></a></code>, <code><a href="TextMgr.html#925718"></code>TxtFindString<code></a></code> </dl></dl></dl><a name="925661"> </a><br> <br> <br><h3> TxtEncodingName</h3><dl><dl><a name="925662"> </a><h4>Purpose </h4><dl><a name="925664"> </a><p></p><dt>Obtain a character encoding's name. </dl><a name="925665"> </a><h4>Prototype </h4><dl><a name="925666"> </a><dt><code>const&nbsp;Char* TxtEncodingName (CharEncodingType&nbsp;inEncoding)</code></dl></dl><dl><a name="925667"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925671"> </a><CODE><code>-&gt; inEncoding</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One of the values from <code><a href="TextMgr.html#924927"></code>CharEncodingType<code></a></code>, indicating a character encoding. <br></TD></TR></TABLE></dl><dl><a name="925672"> </a><h4>Result </h4><dl><a name="925673"> </a><p></p><dt>A constant string containing the name of the encoding. <p><a name="925703"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><p><a name="925676"> </a> <code>encodingNameAscii</code> </p></td><td><p><a name="925678"> </a> us ascii</p></td></tr><tr><td><p><a name="925680"> </a> <code>encodingNameISO8859_1</code> </p></td><td><p><a name="925682"> </a> ISO-8859-1</p></td></tr><tr><td><p><a name="925684"> </a> <code>encodingNameCP1252</code> </p></td><td><p><a name="925686"> </a> ISO-8859-1-Windows-3.1-Latin-1</p></td></tr><tr><td><p><a name="925688"> </a> <code>encodingNameShiftJIS</code> </p></td><td><p><a name="925690"> </a> Shift_JIS</p></td></tr><tr><td><p><a name="925692"> </a> <code>encodingNameCP932</code> </p></td><td><p><a name="925694"> </a> Windows-31J</p></td></tr><tr><td><p><a name="925696"> </a> <code>encodingNameUTF8</code> </p></td><td><p><a name="925698"> </a> UTF-8</p></td></tr><tr><td><p><a name="925700"> </a> <code>""</code> </p></td><td><p><a name="925702"> </a> The encoding is not known</p></td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="925704"> </a><h4>Comments </h4><dl><a name="925705"> </a><p></p><dt>Use this function to obtain the official name of the character encoding, suitable to pass to an Internet application or any other application that requires the character encoding's name to be passed along with the data.</dl><a name="925706"> </a><h4>Compatibility </h4><dl><a name="925710"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925711"> </a><h4>See Also </h4><dl><a name="925715"> </a><p></p><dt><code><a href="TextMgr.html#924927"></code>CharEncodingType<code></a></code> </dl></dl></dl><a name="925718"> </a><br> <br> <br><h3> TxtFindString</h3><dl><dl><a name="925719"> </a><h4>Purpose </h4><dl><a name="925721"> </a><p></p><dt>Perform a case-insensitive search for a string in another string. </dl><a name="925722"> </a><h4>Prototype </h4><dl><a name="925723"> </a><dt><code>Boolean TxtFindString (const&nbsp;Char*&nbsp;inSourceStr, const&nbsp;Char*&nbsp;inTargetStr, UInt32*&nbsp;outPos, UInt16*&nbsp;outLength)</code></dl></dl><dl><a name="925724"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925725"> </a><CODE><code>-&gt; inSourceStr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the string to be searched. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925726"> </a><CODE><code>-&gt; inTargetStr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Prepared version of the string to be found. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925730"> </a><CODE><code>&lt;- outPos</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the offset of the match in <code>inSourceStr</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925731"> </a><CODE><code>&lt;- outLength</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the length in bytes of the matching text. <br></TD></TR></TABLE></dl><dl><a name="925732"> </a><h4>Result </h4><dl><a name="925733"> </a><p></p><dt>Returns <code>true</code> if the function finds <code>inTargetStr</code> within <code>inSourceStr</code>; <code>false</code> otherwise. <a name="925734"> </a><p></p><dt>If found, the values pointed to by the <code>outPos</code> and <code>outLength</code> parameters are set to the starting offset and the length of the matching text. If not found, the values pointed to by <code>outPos</code> and <code>outLength</code> are set to 0. </dl></dl><dl><a name="925735"> </a><h4>Comments </h4><dl><a name="925739"> </a><p></p><dt>Use this function instead of <code><a href="Find.html#924952"></code>FindStrInStr<code></a></code> to support the global system find facility. This function contains an extra parameter, <code>outLength</code>, to specify the length of the text that matched. Pass this value to <code><a href="Find.html#924934"></code>FindSaveMatch<code></a></code> in the <code>appCustom</code> parameter. Then when your application receives <code>sysAppLaunchCmdGoTo</code>, the <code>matchCustom</code> field contains the length of the matching text. You use the length of matching text to highlight the match within the selected record.<a name="925743"> </a><p></p><dt>You must make sure that the parameters <code>inSourceStr</code> and <code>inTargetStr</code> point to the start of a valid character. That is, they must point to the first byte of a multi-byte character, or they must point to a single-byte character. If they don't, results are unpredictable. </dl><a name="925744"> </a><h4>Compatibility </h4><dl><a name="925748"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925749"> </a><h4>See Also </h4><dl><a name="925753"> </a><p></p><dt><code><a href="TextMgr.html#925029"></code>TxtCaselessCompare<code></a></code></dl></dl></dl><a name="925756"> </a><br> <br> <br><h3> TxtGetChar</h3><dl><dl><a name="925757"> </a><h4>Purpose </h4><dl><a name="925759"> </a><p></p><dt>Retrieve the character starting at the specified offset within a text buffer. </dl><a name="925760"> </a><h4>Prototype </h4><dl><a name="925761"> </a><dt><code>WChar TxtGetChar (const&nbsp;Char*&nbsp;inText, UInt32&nbsp;inOffset)</code></dl></dl><dl><a name="925762"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925763"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the text buffer to be searched. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925764"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. This offset must point to an inter-character boundary. <br></TD></TR></TABLE></dl><dl><a name="925765"> </a><h4>Result </h4><dl><a name="925766"> </a><p></p><dt>Returns the character at <code>inOffset</code> in <code>inText</code>. </dl></dl><dl><a name="925767"> </a><h4>Comments </h4><dl><a name="925768"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl><a name="925769"> </a><h4>Compatibility </h4><dl><a name="925773"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925774"> </a><h4>See Also </h4><dl><a name="925781"> </a><p></p><dt><code><a href="TextMgr.html#925784"></code>TxtGetNextChar<code></a></code>, <code><a href="TextMgr.html#926006"></code>TxtSetNextChar<code></a></code></dl></dl></dl><a name="925784"> </a><br> <br> <br><h3> TxtGetNextChar</h3><dl><dl><a name="925785"> </a><h4>Purpose </h4><dl><a name="925787"> </a><p></p><dt>Retrieve the character starting at the specified offset within a text buffer. </dl><a name="930432"> </a><h4>Prototype </h4><dl><a name="930433"> </a><dt><code>UInt16 TxtGetNextChar (const&nbsp;Char*&nbsp;inText, UInt32&nbsp;inOffset, WChar*&nbsp;outChar)</code></dl></dl><dl><a name="925790"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925791"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the text buffer to be searched. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925792"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. This offset must point to an inter-character boundary. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925793"> </a><CODE><code>&lt;- outChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The character at <code>inOffset</code> in <code>inText</code>. Pass <code>NULL</code> for this parameter if you don't need the character returned. <br></TD></TR></TABLE></dl><dl><a name="925794"> </a><h4>Result </h4><dl><a name="925795"> </a><p></p><dt>Returns the size in bytes of the character at <code>inOffset</code>. If <code>outChar</code> is not <code>NULL</code> upon entry, it points to the character at <code>inOffset</code> upon return.</dl></dl><dl><a name="925796"> </a><h4>Comments </h4><dl><a name="925797"> </a><p></p><dt>You can use this function to iterate through a text buffer character-by-character in this way: </dl></dl><dl><a name="925798"> </a><br><code>UInt16 i = 0;<br>while (i &lt; bufferLength) {<br>	 	 i += TxtGetNextChar(buffer, i, &amp;ch);<br>	 	 //do something with ch.<br>}</code><br><dl><a name="925799"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl></dl><dl><a name="925800"> </a><h4>Compatibility </h4><dl><a name="925804"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925805"> </a><h4>See Also </h4><dl><a name="925815"> </a><p></p><dt><code><a href="TextMgr.html#925756"></code>TxtGetChar<code></a></code>, <code><a href="TextMgr.html#925818"></code>TxtGetPreviousChar<code></a></code>, <code><a href="TextMgr.html#926006"></code>TxtSetNextChar<code></a></code></dl></dl></dl><a name="925818"> </a><br> <br> <br><h3> TxtGetPreviousChar</h3><dl><dl><a name="925819"> </a><h4>Purpose </h4><dl><a name="925821"> </a><p></p><dt>Retrieve the character before the specified offset within a text buffer. </dl><a name="925822"> </a><h4>Prototype </h4><dl><a name="925823"> </a><dt><code>UInt16 TxtGetPreviousChar (const&nbsp;Char*&nbsp;inText, UInt32&nbsp;inOffset, WChar*&nbsp;outChar)</code></dl></dl><dl><a name="925824"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925825"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the text buffer to be searched. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925826"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. This offset must point to an inter-character boundary. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925827"> </a><CODE><code>&lt;- outChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The character immediately preceding <code>inOffset</code> in <code>inText</code>. Pass <code>NULL</code> for this parameter if you don't need the character returned. <br></TD></TR></TABLE></dl><dl><a name="925828"> </a><h4>Result </h4><dl><a name="925829"> </a><p></p><dt>Returns the size in bytes of the character preceding <code>inOffset</code> in <code>inText</code>. If <code>outChar</code> is not <code>NULL</code> upon entry, then it points to the character preceding <code>inOffset</code> upon return. Returns 0 if <code>inOffset</code> is at the start of the buffer (that is, <code>inOffset</code> is 0). </dl></dl><dl><a name="925830"> </a><h4>Comments </h4><dl><a name="925831"> </a><p></p><dt>You can use this function to iterate through a text buffer character-by-character in this way: </dl></dl><dl><a name="925832"> </a><br><code>/* Find the start of the character containing the last byte. */</code><br></dl><dl><a name="925833"> </a><code>TxtCharBounds (buffer, bufferLength - 1, &amp;start, &amp;end);</code><br><a name="925834"> </a><code>i = start;</code><br><a name="925835"> </a><code>while (i &gt; 0) {</code><br><a name="925836"> </a><code>&nbsp&nbsp&nbsp 	 i -= TxtGetPreviousChar(buffer, i, &amp;ch);</code><br><a name="925837"> </a><code>&nbsp&nbsp&nbsp 	 //do something with ch.</code><br><a name="925838"> </a><code>}</code><br><dl><a name="925842"> </a><p></p><dt>This function is often slower to use than <code><a href="TextMgr.html#925784"></code>TxtGetNextChar<code></a></code> because it must determine the appropriate character boundaries if the byte immediately before the offset is valid in more than one location (start, middle, or end) of a multi-byte character. To do this, it must work backwards toward the beginning of the string until it finds an unambiguous byte. <a name="925843"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl></dl><dl><a name="925844"> </a><h4>Compatibility </h4><dl><a name="925848"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925851"> </a><br> <br> <br><h3> TxtGetTruncationOffset</h3><dl><dl><a name="925852"> </a><h4>Purpose </h4><dl><a name="925853"> </a><p></p><dt>Return the appropriate byte position for truncating a text buffer such that it is at most a specified number of bytes long. </dl><a name="925854"> </a><h4>Prototype </h4><dl><a name="925855"> </a><dt><code>UInt32 TxtGetTruncationOffset (const&nbsp;Char*&nbsp;inText, UInt32&nbsp;inOffset)</code></dl></dl><dl><a name="925856"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925857"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a text buffer. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925858"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. <br></TD></TR></TABLE></dl><dl><a name="925859"> </a><h4>Result </h4><dl><a name="925860"> </a><p></p><dt>Returns the appropriate byte offset for truncating <code>inText</code> at a valid inter-character boundary. The return value may be less than or equal to <code>inOffset</code>. </dl></dl><dl><a name="925861"> </a><h4>Comments </h4><dl><a name="925862"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl><a name="925863"> </a><h4>Compatibility </h4><dl><a name="925867"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="925870"> </a><br> <br> <br><h3> TxtMaxEncoding</h3><dl><dl><a name="925871"> </a><h4>Purpose </h4><dl><a name="925873"> </a><p></p><dt>Return the higher of two encodings.</dl><a name="925874"> </a><h4>Prototype </h4><dl><a name="925875"> </a><dt><code>CharEncodingType TxtMaxEncoding (CharEncodingType&nbsp;a, CharEncodingType&nbsp;b)</code></dl></dl><dl><a name="925876"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925877"> </a><CODE><code>-&gt; a</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A character encoding to compare. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925878"> </a><CODE><code>-&gt; b</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Another character encoding to compare. <br></TD></TR></TABLE></dl><dl><a name="925879"> </a><h4>Result </h4><dl><a name="925880"> </a><p></p><dt>Returns the higher of <code>a</code> or <code>b</code>. One character encoding is higher than another if it is more specific. For example code page 1252 is "higher" than ISO 8859-1 because it represents more characters than ISO 8859-1. </dl></dl><dl><a name="925881"> </a><h4>Comments </h4><dl><a name="925885"> </a><p></p><dt>This function is used by <code><a href="TextMgr.html#926036"></code>TxtStrEncoding<code></a></code> to determine the encoding required for a string. </dl><a name="925886"> </a><h4>Compatibility </h4><dl><a name="925890"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925891"> </a><h4>See Also </h4><dl><a name="934793"> </a><p></p><dt><code><a href="TextMgr.html#925175"></code>TxtCharEncoding<code></a></code>, <code><a href="TextMgr.html#924927"></code>CharEncodingType<code></a></code> </dl></dl></dl><a name="934797"> </a><br> <br> <br><h3> TxtNextCharSize</h3><dl><dl><a name="934798"> </a><h4>Purpose </h4><dl><a name="925905"> </a><p></p><dt>Macro that returns the size of the character starting at the specified offset within a text buffer. </dl><a name="925906"> </a><h4>Prototype </h4><dl><a name="925907"> </a><dt><code>TxtNextCharSize (inText, inOffset)</code></dl></dl><dl><a name="925908"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925909"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the text buffer to be searched. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925910"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. This offset must point to an inter-character boundary. <br></TD></TR></TABLE></dl><dl><a name="925911"> </a><h4>Result </h4><dl><a name="925912"> </a><p></p><dt>Returns (as a <code>UInt16</code>) the size in bytes of the character at <code>inOffset</code>. </dl></dl><dl><a name="925913"> </a><h4>Comments </h4><dl><a name="925914"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl><a name="925915"> </a><h4>Compatibility </h4><dl><a name="933931"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="933932"> </a><h4>See Also </h4><dl><a name="934102"> </a><p></p><dt><code><a href="TextMgr.html#925784"></code>TxtGetNextChar<code></a> </code></dl></dl></dl><a name="935442"> </a><br> <br> <br><h3> TxtParamString</h3><dl><dl><a name="935769"> </a><h4>Purpose </h4><dl><a name="935770"> </a><p></p><dt>Replace substrings within a string with the specified values.</dl><a name="935771"> </a><h4>Prototype </h4><dl><a name="935772"> </a><dt><code>Char* TxtParamString (const&nbsp;Char*&nbsp;inTemplate, const&nbsp;Char*&nbsp;param0, const&nbsp;Char*&nbsp;param1, const&nbsp;Char*&nbsp;param2, const&nbsp;Char*&nbsp;param3)</code></dl></dl><dl><a name="935773"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="935774"> </a><CODE>-&gt; <code>inTemplate</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The string containing the substrings to replace. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="935775"> </a><CODE>-&gt; <code>param0</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to replace ^0 with or <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="935776"> </a><CODE>-&gt; <code>param1</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to replace ^1 with or <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="935777"> </a><CODE>-&gt; <code>param2</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to replace ^2 with or <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="935778"> </a><CODE>-&gt; <code>param3</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to replace ^3 with or <code>NULL</code>. <br></TD></TR></TABLE></dl><dl><a name="935779"> </a><h4>Result </h4><dl><a name="935780"> </a><p></p><dt>Returns a locked handle to a newly allocated string in the dynamic heap that contains the appropriate substitutions. </dl></dl><dl><a name="935781"> </a><h4>Comments </h4><dl><a name="935782"> </a><p></p><dt>This function searches <code>inTemplate</code> for occurrences of the sequences ^0, ^1, ^2, and ^3. When it finds these, it replaces them with the corresponding string passed to this function. Multiple instances of each sequence will be replaced. <a name="935783"> </a><p></p><dt>You must make sure that the parameter inTemplate points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. <a name="935784"> </a><p></p><dt><code>TxtParamString</code> allocates space for the returned string in the dynamic heap. Your code is responsible for freeing this memory when it is no longer needed. </dl><a name="935785"> </a><h4>Compatibility </h4><dl><a name="935786"> </a><p></p><dt>Implemented if <a href="CompatibilityApdx.html#486514">3.5 New Feature Set</a> is present.</dl><a name="935787"> </a><h4>See Also </h4><dl><a name="935794"> </a><p></p><dt><code><a href="TextMgr.html#925982"></code>TxtReplaceStr<code></a></code>, <code><a href="Form.html#972840"></code>FrmCustomAlert<code></a></code> </dl></dl></dl><a name="933936"> </a><br> <br> <br><h3> TxtPreviousCharSize</h3><dl><dl><a name="933937"> </a><h4>Purpose </h4><dl><a name="925960"> </a><p></p><dt>Macro that returns the size of the character before the specified offset within a text buffer. </dl><a name="925961"> </a><h4>Prototype </h4><dl><a name="925962"> </a><dt><code>TxtPreviousCharSize (inText, inOffset)</code></dl></dl><dl><a name="925963"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925964"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the text buffer. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925965"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. This offset must point to an inter-character boundary. <br></TD></TR></TABLE></dl><dl><a name="925966"> </a><h4>Result </h4><dl><a name="925967"> </a><p></p><dt>Returns (as a <code>UInt16</code>) the size in bytes of the character preceding <code>inOffset</code> in <code>inText</code>. Returns 0 if <code>inOffset</code> is at the start of the buffer (that is, <code>inOffset</code> is 0). </dl></dl><dl><a name="925968"> </a><h4>Comments </h4><dl><a name="925969"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl><a name="925970"> </a><h4>Compatibility </h4><dl><a name="925974"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="925975"> </a><h4>See Also </h4><dl><a name="925979"> </a><p></p><dt><code><a href="TextMgr.html#925818"></code>TxtGetPreviousChar<code></a></code> </dl></dl></dl><a name="925982"> </a><br> <br> <br><h3> TxtReplaceStr</h3><dl><dl><a name="925983"> </a><h4>Purpose </h4><dl><a name="925984"> </a><p></p><dt>Replace a substring of a given format with another string. </dl><a name="925985"> </a><h4>Prototype </h4><dl><a name="925986"> </a><dt><code>UInt16 TxtReplaceStr (Char*&nbsp;ioStr, UInt16&nbsp;inMaxLen, const&nbsp;Char*&nbsp;inParamStr, UInt16&nbsp;inParamNum)</code></dl></dl><dl><a name="925987"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925988"> </a><CODE><code>&lt;-&gt; ioStr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The string in which to perform the replacing. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925989"> </a><CODE><code>-&gt; inMaxLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The maximum length in bytes that <code>ioStr</code> can become. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925990"> </a><CODE><code>-&gt; inParamStr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The string that <code>^</code><em>inParamNum</em> should be replaced with. If <code>NULL</code>, no changes are made. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925991"> </a><CODE><code>-&gt; inParamNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A single-digit number (0 to 9). <br></TD></TR></TABLE></dl><dl><a name="925992"> </a><h4>Result </h4><dl><a name="925993"> </a><p></p><dt>Returns the number of occurrences found and replaced. <a name="925994"> </a><p></p><dt>Returns a fatal error message if <code>inParamNum</code> is greater than 9.</dl></dl><dl><a name="925995"> </a><h4>Comments </h4><dl><a name="925996"> </a><p></p><dt>This function searches <code>ioStr</code> for occurrences of the string <code>^</code><em>inParamNum</em>, where <em>inParamNum</em> is any digit from 0 to 9. When it finds the string, it replaces it with <code>inParamStr</code>. Multiple instances will be replaced as long as the resulting string doesn't contain more than <code>inMaxLen</code> bytes, not counting the terminating null. <a name="925997"> </a><p></p><dt>You can set the <code>inParamStr</code> parameter to <code>NULL</code> to determine the required length of <code>ioStr</code> before actually doing the replacing. <code>TxtReplaceStr</code> returns the number of occurrences it finds of <code>^</code><em>inParamNum</em>. Multiply this value by the length of the <code>inParamStr</code> you intend to use to determine the appropriate length of <code>ioStr</code>. <a name="925998"> </a><p></p><dt>You must make sure that the parameter <code>ioStr</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl><a name="925999"> </a><h4>Compatibility </h4><dl><a name="926003"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="926006"> </a><br> <br> <br><h3> TxtSetNextChar</h3><dl><dl><a name="926007"> </a><h4>Purpose </h4><dl><a name="926008"> </a><p></p><dt>Set a character within a text buffer. </dl><a name="926009"> </a><h4>Prototype </h4><dl><a name="926010"> </a><dt><code>UInt16 TxtSetNextChar (Char*&nbsp;ioText, UInt32&nbsp;inOffset, WChar&nbsp;inChar)</code></dl></dl><dl><a name="926011"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926012"> </a><CODE><code>&lt;-&gt; ioText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a text buffer. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926013"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the buffer <code>inText</code>. This offset must point to an inter-character boundary. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926014"> </a><CODE><code>-&gt; inChar</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The character to replace the character at <code>inOffset</code> with. Must not be a virtual character.<br></TD></TR></TABLE></dl><dl><a name="926015"> </a><h4>Result </h4><dl><a name="926016"> </a><p></p><dt>Returns the size of <code>inChar</code>. </dl></dl><dl><a name="926017"> </a><h4>Comments </h4><dl><a name="926018"> </a><p></p><dt>This function replaces the character in <code>ioText</code> at the location <code>inOffset</code> with the character <code>inChar</code>. Note that there must be enough space at <code>inOffset</code> to write the character. <a name="926022"> </a><p></p><dt>You can use <code><a href="TextMgr.html#925534"></code>TxtCharSize<code></a></code> to determine the size of <code>inChar</code>. <a name="926023"> </a><p></p><dt>You must make sure that the parameter <code>ioText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl><a name="926024"> </a><h4>Compatibility </h4><dl><a name="926028"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="926029"> </a><h4>See Also </h4><dl><a name="926033"> </a><p></p><dt><code><a href="TextMgr.html#925784"></code>TxtGetNextChar<code></a></code></dl></dl></dl><a name="926036"> </a><br> <br> <br><h3> TxtStrEncoding</h3><dl><dl><a name="926037"> </a><h4>Purpose </h4><dl><a name="926039"> </a><p></p><dt>Return the encoding required to represent a string. </dl><a name="926040"> </a><h4>Prototype </h4><dl><a name="926041"> </a><dt><code>CharEncodingType TxtStrEncoding (const&nbsp;Char*&nbsp;inStr)</code></dl></dl><dl><a name="926042"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926043"> </a><CODE><code>-&gt; inStr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A string. Must not be <code>NULL</code>. <br></TD></TR></TABLE></dl><dl><a name="926044"> </a><h4>Result </h4><dl><a name="926048"> </a><p></p><dt>A <code><a href="TextMgr.html#924927"></code>CharEncodingType<code></a></code> value that indicates the encoding required to represent <code>inChar</code>. If any character in the string isn't recognizable, then <code>charEncodingUnknown</code> is returned. </dl></dl><dl><a name="926049"> </a><h4>Comments </h4><dl><a name="926050"> </a><p></p><dt>The encoding for the string is the maximum encoding of any character in that string. For example, if a two-character string contains a blank space and a &uuml;, the appropriate encoding is <code>charEncodingISO8859_1</code>. The blank space's minimum encoding is ASCII. The minimum encoding for the &uuml; is ISO 8859-1. The maximum of these two encodings is ISO 8859-1. <a name="926051"> </a><p></p><dt>Because Palm OS only supports a single character encoding at a time, the results of this function is always logically equal to or less than the encoding used on the current system. That is, you'll only receive a return value of <code>charEncodingISO8859_1</code> if you're running on a USA or European system. <a name="926052"> </a><p></p><dt>Use this function for informational purposes only. Your code should not assume that the character encoding returned by this function is the Palm OS system's character encoding. (Instead use <code>FtrGet</code> as shown in the <code><a href="TextMgr.html#925579"></code>TxtCharXAttr<code></a></code> function description.)</dl><a name="926056"> </a><h4>Compatibility </h4><dl><a name="926060"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="926061"> </a><h4>See Also </h4><dl><a name="926068"> </a><p></p><dt><code><a href="TextMgr.html#925175"></code>TxtCharEncoding<code></a></code>, <code><a href="TextMgr.html#925870"></code>TxtMaxEncoding<code></a></code> </dl></dl></dl><a name="926071"> </a><br> <br> <br><h3> TxtTransliterate</h3><dl><dl><a name="926072"> </a><h4>Purpose </h4><dl><a name="926074"> </a><p></p><dt>Converts the specified number of bytes in a text buffer using the specified operation. </dl><a name="926075"> </a><h4>Prototype </h4><dl><a name="926076"> </a><dt><code>Err TxtTransliterate (const&nbsp;Char*&nbsp;inSrcText, UInt16&nbsp;inSrcLength, Char*&nbsp;outDstText, UInt16*&nbsp;ioDstLength, TranslitOpType&nbsp;inOp)</code></dl></dl><dl><a name="926077"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926078"> </a><CODE><code>-&gt; inSrcText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a text buffer. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926079"> </a><CODE><code>-&gt; inSrcLength</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The length in bytes of <code>inSrcText</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926080"> </a><CODE><code>&lt;- outDstText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The output buffer containing the converted characters. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926081"> </a><CODE><code>&lt;-&gt;ioDstLength</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Upon entry, the maximum length of <code>outDstText</code>. Upon return, the actual length of <code>outDstText</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926083"> </a><CODE><code>-&gt; inOp</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A 16-bit unsigned value that specifies which transliteration operation is to be performed. The values possible for this field are specific to the character encoding used on a particular device. These operations are universally available: <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=35% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=25% VALIGN=TOP ALIGN=LEFT><a name="926085"> </a><CODE><code>translitOpUpperCase</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Converts the character to uppercase letters. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=35% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=25% VALIGN=TOP ALIGN=LEFT><a name="926087"> </a><CODE><code>translitOpLowerCase</code> </CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Converts the characters to lowercase letters. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=35% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=25% VALIGN=TOP ALIGN=LEFT><a name="926089"> </a><CODE><code>translitOpPreprocess</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Don't actually perform the operation. Instead, return in <code>ioDstLength</code> the amount of space required for the output text. <br></TD></TR></TABLE></dl><dl><a name="926090"> </a><h4>Result </h4><dl><a name="926091"> </a><p></p><dt>Returns one of the following values: <p><a name="926112"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="926094"> </a>0</td><td><a name="926096"> </a>Success</td></tr><tr><td><a name="926099"> </a><code>txtErrUnknownTranslitOp</code></td><td><a name="926101"> </a><code>inOp</code>'s value is not recognized</td></tr><tr><td><a name="926104"> </a><code>txtErrTranslitOverrun</code></td><td><a name="926106"> </a>If <code>inSrcText</code> and <code>outDstText</code> point to the same memory location and the operation has caused the function to overwrite unprocessed data in the input buffer. </td></tr><tr><td><a name="926109"> </a><code>txtErrTranslitOverflow</code></td><td><a name="926111"> </a>If <code>outDstText</code> is not large enough to contain the converted string. </td></tr></table><table><tr><td></table></div></p></dl></dl><dl><a name="926113"> </a><h4>Comments </h4><dl><a name="926114"> </a><p></p><dt><code>inSrcText</code> and <code>outDstText</code> may point to the same location if you want to perform the operation in place. However, you should be careful that the space required for <code>outDstText</code> is not larger than <code>inSrcText</code> so that you don't generate a <code>txtErrTranslitOverrun</code> error. <a name="926115"> </a><p></p><dt>For example, suppose on a Shift JIS encoded system, you want to convert a series of single-byte Japanese Katakana symbols to double-byte Katakana symbols. You cannot perform this operation in place because it replaces a single-byte character with a multi-byte character. When the first converted character is written to the buffer, it overwrites the second input character. Thus, a text overrun has occurred. <a name="926116"> </a><p></p><dt>You can ensure that you have enough space for the output by ORing your chosen operation with <code>translitOpPreprocess</code>. For example, to convert a string to uppercase letters, do the following:</dl></dl><dl><a name="926117"> </a><br><code>outSize = buf2Len;<br>error = TxtTransliterate(buf1, buf1len, &amp;buf2, &amp;outSize, translitOpUpperCase|translitOpPreprocess);</code><br></dl><dl><a name="926118"> </a><code>if (outSize &gt; buf2len) <br>	 	 /* allocate more memory for buf2 */</code><br><a name="926119"> </a><code>error = TxtTransliterate(buf1, buf1Len, &amp;buf2, &amp;outSize, translitOpUpperCase);</code><br><dl><a name="926120"> </a><p></p><dt>You must make sure that the parameter <code>inSrcText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl></dl><dl><a name="926121"> </a><h4>Compatibility </h4><dl><a name="926125"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl></dl></dl><a name="926128"> </a><br> <br> <br><h3> TxtWordBounds</h3><dl><dl><a name="926129"> </a><h4>Purpose </h4><dl><a name="926130"> </a><p></p><dt>Find the boundaries of a word of text that contains the character starting at the specified offset. </dl><a name="926131"> </a><h4>Prototype </h4><dl><a name="926132"> </a><dt><code>Boolean TxtWordBounds (const&nbsp;Char*&nbsp;inText, UInt32&nbsp;inLength, UInt32&nbsp;inOffset, UInt32*&nbsp;outStart, UInt32*&nbsp;outEnd)</code></dl></dl><dl><a name="926133"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926134"> </a><CODE><code>-&gt; inText</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a text buffer. Must not be <code>NULL</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926135"> </a><CODE><code>-&gt; inLength</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The length in bytes of the text pointed to by <code>inText</code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926136"> </a><CODE><code>-&gt; inOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A valid offset into the text buffer <code>inText</code>. This offset must point to the beginning of a character. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926137"> </a><CODE><code>&lt;- outStart</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The starting offset of the text word. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926138"> </a><CODE><code>&lt;- outEnd</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The ending offset of the text word. <br></TD></TR></TABLE></dl><dl><a name="926139"> </a><h4>Result </h4><dl><a name="926140"> </a><p></p><dt>Returns <code>true</code> if a word is found. Returns <code>false</code> if the word doesn't exist or is punctuation or whitespace. </dl></dl><dl><a name="926141"> </a><h4>Comments </h4><dl><a name="926142"> </a><p></p><dt>Assuming the ASCII encoding, if the text buffer contains the string "Hi! How are you?" and you pass 5 as the offset, <code>TxtWordBounds</code> returns the start and end of the word containing the character at offset 5, which is the character "o". Thus, <code>outStart</code> and <code>outEnd</code> would point to the start and end of the word "How". <a name="926143"> </a><p></p><dt>You must make sure that the parameter <code>inText</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </dl><a name="926144"> </a><h4>Compatibility </h4><dl><a name="926148"> </a><p></p><dt>Implemented only if <a href="CompatibilityApdx.html#484308">International Feature Set</a> is present.</dl><a name="926149"> </a><h4>See Also </h4><dl><a name="926158"> </a><p></p><dt><code><a href="TextMgr.html#925151"></code>TxtCharBounds<code></a></code>, <code><a href="TextMgr.html#925284"></code>TxtCharIsDelim<code></a></code> </dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="SystemManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="Window.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 49 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:28:49 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/TextMgr.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
</html>