<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/NetLibrary.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
<head><title>Net Library</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="ModemManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="NetworkUtils.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS SDK Reference</B></center><hr><br><a name="924905"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>54 Net Library</h1><dl><a name="924906"> </a><p></p><dt>This chapter describes the API available in the net library and its Berkeley sockets equivalents. The header file <code>NetMgr.h</code> declares the net library API. The chapter covers:<ul type="SQUARE"><a name="924911"> </a><br><li><a href="NetLibrary.html#924926">Net Library Data Structures</a><br><a name="924915"> </a><br><li><a href="NetLibrary.html#925207">Net Library Constants</a><br><a name="924919"> </a><br><li><a href="NetLibrary.html#925370">Net Library Functions</a><br></ul><a name="924922"> </a><p></p><dt>For more information on the net library, see the chapter <a href="NetworkCommunication.html#924904">"Network Communication"</a> in the <em>Palm OS Programmer's Companion</em>. <a name="924924"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Applications cannot directly use the net library to make wireless connections. Use the INetLib for wireless connections. <br><hr><br></blockquote></dl><a name="924926"> </a><h2> Net Library Data Structures</h2><a name="924943"> </a><h3> NetHostInfoBufType</h3><dl><a name="924945"> </a><p></p><dt>The <code>NetHostInfoBufType</code> struct contains information about a host. The <code><a href="NetLibrary.html#924984"></code>NetHostInfoType<code></a></code> struct, which maps to the <code>hostent</code> struct, points to fields in this struct for its information. <dl><a name="924949"> </a><br><code>typedef struct {</code><br></dl><dl><a name="924950"> </a><code>&nbsp&nbsp&nbsp NetHostInfoType	 	 	 	 	 	 	 	 hostInfo;</code><br><a name="924951"> </a><code>&nbsp&nbsp&nbsp Char	 	 	 	 	 	 name[netDNSMaxDomainName+1];</code><br><a name="924952"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;*	 	 	 	 	 	 aliasList[netDNSMaxAliases+1];</code><br><a name="924953"> </a><code>&nbsp&nbsp&nbsp Char	 	 	 	 	 	 aliases[netDNSMaxAliases] <br>	 	 	 	 	 	 	 	 [netDNSMaxAliases+1];</code><br><a name="924955"> </a><code>&nbsp&nbsp&nbsp NetIPAddr*	 	 	 	 	 	 addressList[netDNSMaxAddresses];</code><br><a name="924957"> </a><code>&nbsp&nbsp&nbsp NetIPAddr	 	 	 	 	 	 address[netDNSMaxAddresses];</code><br><a name="924958"> </a><code>} NetHostInfoBufType, *NetHostInfoBufPtr;</code><br></dl></dl><a name="924959"> </a><h4> Field Descriptions</h4><p><a name="924982"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="924962"> </a><code>hostInfo</code> </td><td><a name="924967"> </a>A <code><a href="NetLibrary.html#924984"></code>NetHostInfoType<code></a></code> struct, which maps to the Berkeley UNIX sockets <code>hostent</code> structure. </td></tr><tr><td><a name="924969"> </a><code>name</code> </td><td><a name="924971"> </a>Official host name.</td></tr><tr><td><a name="924973"> </a><code>aliasList</code><a name="924974"> </a><code>aliases</code> </td><td><a name="924976"> </a>An array of aliases for the host name.</td></tr><tr><td><a name="924978"> </a><code>addressList </code><a name="924979"> </a><code>address</code> </td><td><a name="924981"> </a>An array of pointers to 32-bit IP addresses in host byte order.</td></tr></table><table><tr><td></table></div></p><a name="924984"> </a><h3> NetHostInfoType</h3><dl><a name="924986"> </a><p></p><dt>The <code>NetHostInfoType</code> structure maps to the Berkeley UNIX sockets <code>hostent</code> structure. It is defined as follows:<dl><a name="924988"> </a><br><code>typedef struct {</code><br></dl><dl><a name="924989"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;*	 	 	 	 	 nameP;</code><br><a name="924990"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;**	 	 	 	 	 nameAliasesP;</code><br><a name="924991"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 addrType;</code><br><a name="945690"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 addrLen;</code><br><a name="945691"> </a><code>&nbsp&nbsp&nbsp UInt8&nbsp;**	 	 	 	 	 addrListP;</code><br><a name="945692"> </a><code>} NetHostInfoType, *NetHostInfoPtr;</code><br></dl></dl><a name="924995"> </a><h4> Field Descriptions</h4><p><a name="925020"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="924998"> </a><code>nameP</code> </td><td><a name="925000"> </a>Official host name.</td></tr><tr><td><a name="925002"> </a><code>nameAliasesP</code> </td><td><a name="925004"> </a>An array of aliases for the host name.</td></tr><tr><td><a name="925006"> </a><code>addrType</code> </td><td><a name="925008"> </a>The type of the return addresses. See <code><a href="NetLibrary.html#925087"></code>NetSocketAddrEnum<code></a></code>.</td></tr><tr><td><a name="925013"> </a><code>addrLen</code> </td><td><a name="925015"> </a>The length in bytes of the return addresses.</td></tr><tr><td><a name="925017"> </a><code>addrListP</code> </td><td><a name="925019"> </a>An array of pointers to addresses in host byte order.</td></tr></table><table><tr><td></table></div></p><a name="925022"> </a><h3> NetServInfoBufType</h3><dl><a name="925024"> </a><p></p><dt>The <code>NetServInfoBufType</code> struct contains information about a service. The <code><a href="NetLibrary.html#925058"></code>NetServInfoType<code></a></code> struct, which maps to the <code>servent</code> struct, points to fields in this struct for much of its information. <dl><a name="925028"> </a><br><code>struct {</code><br></dl><dl><a name="925029"> </a><code>&nbsp&nbsp&nbsp NetServInfoType servInfo;</code><br><a name="925030"> </a><code>&nbsp&nbsp&nbsp Char	 	 	 	 	 	 	 name[netServMaxName+1];</code><br><a name="925031"> </a><code>&nbsp&nbsp&nbsp Char *	 	 	 	 	 	 	 aliasList[netServMaxAliases+1];</code><br><a name="925032"> </a><code>&nbsp&nbsp&nbsp Char	 	 	 	 	 	 	 aliases[netServMaxAliases] [netServMaxName];</code><br><a name="925033"> </a><code>&nbsp&nbsp&nbsp Char	 	 	 	 	 	 	 protoName[netProtoMaxName+1];</code><br><a name="946219"> </a><code>&nbsp&nbsp&nbsp UInt8	 	 	 	 	 	 	 reserved;</code><br><a name="946650"> </a><code>} NetServInfoBufType, *NetServInfoBufPtr;</code><br></dl></dl><a name="925034"> </a><h4> Field Descriptions</h4><p><a name="925056"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925037"> </a><code>servInfo</code> </td><td><a name="925042"> </a>A <code><a href="NetLibrary.html#925058"></code>NetServInfoType<code></a></code> struct, which maps to the Berkeley UNIX sockets <code>servent</code> structure. </td></tr><tr><td><a name="925044"> </a><code>name</code></td><td><a name="925046"> </a>Official name of the service</td></tr><tr><td><a name="925048"> </a><code>aliasList</code><a name="925049"> </a><code>aliases</code> </td><td><a name="925051"> </a>Array of aliases for the service name.</td></tr><tr><td><a name="925053"> </a><code>protoName</code> </td><td><a name="925055"> </a>Name of the protocol to use. </td></tr><tr><td><a name="946229"> </a><code>reserved</code></td><td><a name="946231"> </a>Reserved for future use.</td></tr></table><table><tr><td></table></div></p><a name="925058"> </a><h3> NetServInfoType</h3><dl><a name="925061"> </a><p></p><dt>The <code>NetServInfoType</code> structure maps to the <code>servent</code> structure in Berkeley UNIX sockets API. It contains information about a service.<dl><a name="925062"> </a><br><code>struct {</code><br></dl><dl><a name="925063"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;*	 	 	 	 	 nameP;</code><br><a name="925064"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;**	 	 	 	 	 nameAliasesP;</code><br><a name="925065"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 port;</code><br><a name="925066"> </a><code>&nbsp&nbsp&nbsp Char&nbsp;*	 	 	 	 	 protoP;</code><br><a name="946651"> </a><code>} NetServInfoType, *NetServInfoPtr;</code><br></dl></dl><a name="925067"> </a><h4> Field Descriptions</h4><p><a name="925085"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925070"> </a><code>nameP</code> </td><td><a name="925072"> </a>Official name of the service</td></tr><tr><td><a name="925074"> </a><code>nameAliasesP</code> </td><td><a name="925076"> </a>Array of aliases for the service name.</td></tr><tr><td><a name="925078"> </a><code>port</code> </td><td><a name="925080"> </a>Port number for the service.</td></tr><tr><td><a name="925082"> </a><code>protoP</code> </td><td><a name="925084"> </a>Name of the protocol to use. </td></tr></table><table><tr><td></table></div></p><a name="925087"> </a><h3> NetSocketAddrEnum</h3><dl><a name="925089"> </a><p></p><dt>The <code>NetSocketAddrEnum</code> enum specifies the address types supported by the net library. <dl><a name="925090"> </a><br><code>typedef enum {</code><br></dl><dl><a name="925091"> </a><code>&nbsp&nbsp&nbsp netSocketAddrRaw = 0,</code><br><a name="925092"> </a><code>&nbsp&nbsp&nbsp netSocketAddrINET = 2</code><br><a name="925093"> </a><code>} NetSocketAddrEnum</code><br></dl></dl><a name="925094"> </a><h4> Value Descriptions</h4><p><a name="925104"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925097"> </a><code>netSocketAddrRaw</code> </td><td><a name="925099"> </a>Raw address. Supported in Palm OS<sup>&#174;</sup> version 3.0 and higher.</td></tr><tr><td><a name="925101"> </a><code>netSocketAddrINET</code> </td><td><a name="925103"> </a>IP address.</td></tr></table><table><tr><td></table></div></p><a name="925106"> </a><h3> NetSocketAddrINType</h3><dl><a name="925108"> </a><p></p><dt>The <code>NetSocketAddrINType</code> struct holds an internet socket address, that is, a socket that uses one of the internet protocols. This structure directly maps to the BSD UNIX <code>sockaddr_in</code> structure. <dl><a name="925110"> </a><br><code>typedef struct NetSocketAddrINType {</code><br></dl><dl><a name="925111"> </a><code>&nbsp&nbsp&nbsp Int16	 	 	 	 	 family;</code><br><a name="925112"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 port;</code><br><a name="925113"> </a><code>&nbsp&nbsp&nbsp NetIPAddr	 	 	 	 	 addr;</code><br><a name="925114"> </a><code>} NetSocketAddrINType;</code><br></dl></dl><a name="925115"> </a><h4> Field Descriptions</h4><p><a name="925129"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925118"> </a><code>family</code> </td><td><a name="925120"> </a>Address family in host byte order. This is either <code>netSocketAddrINET</code> or <code>netSocketAddrRaw</code>. </td></tr><tr><td><a name="925122"> </a><code>port</code> </td><td><a name="925124"> </a>The port in network byte order.</td></tr><tr><td><a name="925126"> </a><code>addr</code> </td><td><a name="925128"> </a>The IP address in network byte order. </td></tr></table><table><tr><td></table></div></p><a name="925131"> </a><h3> NetSocketAddrRawType</h3><dl><a name="925133"> </a><p></p><dt>The <code>NetSocketAddrRawType</code> structure holds a raw socket address. <dl><a name="925134"> </a><br><code>typedef struct NetSocketAddrRawType {</code><br></dl><dl><a name="925135"> </a><code>&nbsp&nbsp&nbsp Int16 family;</code><br><a name="925136"> </a><code>&nbsp&nbsp&nbsp UInt16 ifInstance;</code><br><a name="925137"> </a><code>&nbsp&nbsp&nbsp UInt32 ifCreator;</code><br><a name="925138"> </a><code>} NetSocketAddrRawType;</code><br></dl></dl><a name="925139"> </a><h4> Field Descriptions</h4><p><a name="925153"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925142"> </a><code>family</code> </td><td><a name="925144"> </a>Address family in host byte order. This is either <code>netSocketAddrINET</code> or <code>netSocketAddrRaw</code>. </td></tr><tr><td><a name="925146"> </a><code>ifInstance</code> </td><td><a name="925148"> </a>The instance number of the interface that the socket uses to send and receive data.</td></tr><tr><td><a name="925150"> </a><code>ifCreator</code> </td><td><a name="925152"> </a>The creator of the interface that the socket uses.</td></tr></table><table><tr><td></table></div></p><a name="925154"> </a><h4> Compatibility</h4><dl><a name="925155"> </a><p></p><dt>Raw sockets are supported in Palm OS<sup>&#174;</sup> version 3.0 and higher.</dl><a name="925157"> </a><h3> NetSocketAddrType</h3><dl><a name="925159"> </a><p></p><dt>The <code>NetSocketAddrType</code> structure holds a generic socket address. This struct can hold any type of address including Internet addresses. It directly maps to the BSD UNIX <code>sockaddr</code> structure. <a name="925161"> </a><p></p><dt>Note that this structure is the same size as <code>NetSocketAddrINType</code> and <code>NetSocketAddrRawType</code>. This means that one of those two structures can be used for parameters declared to be <code>NetSocketAddrType</code>. <dl><a name="925162"> </a><br><code>typedef struct NetSocketAddrType {</code><br></dl><dl><a name="925163"> </a><code>&nbsp&nbsp&nbsp Int16 family;</code><br><a name="925164"> </a><code>&nbsp&nbsp&nbsp UInt8 data[14];</code><br><a name="925165"> </a><code>} NetSocketAddrType;</code><br></dl></dl><a name="925166"> </a><h3> NetSocketRef</h3><dl><a name="925167"> </a><p></p><dt>The <code>NetSocketRef</code> defines a socket descriptor. The socket descriptor is created and returned by <code><a href="NetLibrary.html#928319"></code>NetLibSocketOpen<code></a></code>. It is used in any function that requires access to a socket. <dl><a name="925171"> </a><br><code>typedef Int16 NetSocketRef</code><br></dl></dl><a name="925173"> </a><h3> NetSocketTypeEnum</h3><dl><a name="925175"> </a><p></p><dt>The <code>NetSocketTypeEnum</code> enum specifies the available socket types. <dl><a name="925176"> </a><br><code>typedef enum {</code><br></dl><dl><a name="925177"> </a><code>&nbsp&nbsp&nbsp netSocketTypeStream=1,</code><br><a name="925178"> </a><code>&nbsp&nbsp&nbsp netSocketTypeDatagram=2,</code><br><a name="925179"> </a><code>&nbsp&nbsp&nbsp netSocketTypeRaw=3,</code><br><a name="925180"> </a><code>&nbsp&nbsp&nbsp netSocketTypeReliableMsg=4</code><br><a name="925181"> </a><code>} NetSocketTypeEnum</code><br></dl></dl><a name="925182"> </a><h4> Value Descriptions</h4><p><a name="925200"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925185"> </a><code>netSocketTypeStream</code> </td><td><a name="925187"> </a>Streams protocol over wireline.</td></tr><tr><td><a name="925189"> </a><code>netSocketTypeDatagram</code> </td><td><a name="925191"> </a>UDP protocol.</td></tr><tr><td><a name="925193"> </a><code>netSocketTypeRaw</code> </td><td><a name="925195"> </a>Raw mode. </td></tr></table><table><tr><td></table></div></p><a name="925207"> </a><h2> Net Library Constants</h2><a name="925256"> </a><h3> I/O Flags</h3><dl><a name="925257"> </a><p></p><dt>The I/O flags specify special handling instructions to functions that send and receive data. You can OR these values together to specify more than one.<p><a name="925258"> </a> </p><p><a name="925275"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925262"> </a><code>netIOFlagOutOfBand</code> </td><td><a name="925264"> </a>Process out-of-band data. Available for send calls only. </td></tr><tr><td><a name="925267"> </a><code>netIOFlagPeek</code> </td><td><a name="925269"> </a>Peek at incoming message without dequeuing it.</td></tr><tr><td><a name="925272"> </a><code>netIOFlagDontRoute</code> </td><td><a name="925274"> </a>Send without using routing. This constant is currently ignored. </td></tr></table><table><tr><td></table></div></p></dl><a name="925277"> </a><h3> Tracing Bits</h3><a name="925278"> </a>The tracing bits are used to set the level of event tracing. An application can get a list of events in the trace buffer using the <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code> call. <dl><a name="925282"> </a><p></p><dt>You can set the tracing for each network interface using <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> and for the net library in general with <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code>. <p><a name="925360"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925292"> </a><code>netTracingErrors </code></td><td><a name="925294"> </a>Record run-time errors. This is the default.</td></tr><tr><td><a name="925297"> </a><code>netTracingMsgs </code></td><td><a name="925299"> </a>Record application trace messages.</td></tr><tr><td><a name="925302"> </a><code>netTracingPkts </code></td><td><a name="925304"> </a>Record packets I/O. </td></tr><tr><td><a name="925310"> </a><code>netTracingFuncs </code></td><td><a name="925312"> </a>Record function flow.</td></tr><tr><td><a name="925315"> </a><code>netTracingAppMsgs </code></td><td><a name="925317"> </a>Record application messages sent using <code><a href="NetLibrary.html#928866"></code>NetLibTracePrintF<code></a></code> and <code><a href="NetLibrary.html#928902"></code>NetLibTracePutS<code></a></code>.</td></tr></table><table><tr><td></table></div></p></dl><a name="925370"> </a><h2> Net Library Functions</h2><a name="925372"> </a><br> <br> <br><h3> NetHToNL</h3><dl><dl><a name="925373"> </a><h4>Purpose </h4><dl><a name="925374"> </a><p></p><dt>Macro that converts a 32-bit value from host to network byte order.</dl><a name="925375"> </a><h4>Prototype </h4><dl><a name="925377"> </a><dt><code>NetHToNL (x)</code></dl></dl><dl><a name="925378"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925379"> </a><CODE>-&gt; <code>x</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>32-bit value to convert.<br></TD></TR></TABLE></dl><dl><a name="925380"> </a><h4>Result </h4><dl><a name="925381"> </a><p></p><dt>Returns <code>x</code> in network byte order.</dl></dl><dl><a name="925382"> </a><h4> Sockets Equivalent</h4><dl><a name="925383"> </a><p></p><dt><code>htonl()</code></dl><a name="925384"> </a><h4>See Also </h4><dl><a name="925394"> </a><p></p><dt><code><a href="NetLibrary.html#928960"></code>NetNToHS<code></a></code>, <code><a href="NetLibrary.html#928934"></code>NetNToHL<code></a></code>, <code><a href="NetLibrary.html#925397"></code>NetHToNS<code></a></code> </dl></dl></dl><a name="925397"> </a><br> <br> <br><h3> NetHToNS</h3><dl><dl><a name="925398"> </a><h4>Purpose </h4><dl><a name="925399"> </a><p></p><dt>Macro that converts a 16-bit value from host to network byte order.</dl><a name="925400"> </a><h4>Prototype </h4><dl><a name="925401"> </a><dt><code>NetHToNS (x)</code></dl></dl><dl><a name="925402"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925403"> </a><CODE>-&gt; <code>x</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>16-bit value to convert.<br></TD></TR></TABLE></dl><dl><a name="925404"> </a><h4>Result </h4><dl><a name="925405"> </a><p></p><dt>Returns <code>x</code> in network byte order.</dl></dl><dl><a name="925406"> </a><h4> Sockets Equivalent</h4><dl><a name="925407"> </a><p></p><dt><code>htons()</code></dl><a name="925408"> </a><h4>See Also </h4><dl><a name="925418"> </a><p></p><dt><code><a href="NetLibrary.html#928960"></code>NetNToHS<code></a></code>, <code><a href="NetLibrary.html#928934"></code>NetNToHL<code></a></code>, <code><a href="NetLibrary.html#925372"></code>NetHToNL<code></a></code> </dl></dl></dl><a name="925420"> </a><br> <br> <br><h3> NetLibAddrAToIN</h3><dl><dl><a name="925421"> </a><h4>Purpose </h4><dl><a name="925422"> </a><p></p><dt>Converts an ASCII string representing a dotted decimal IP address into a 32-bit IP address in network byte order.</dl><a name="925423"> </a><h4>Prototype </h4><dl><a name="925426"> </a><dt><code>NetIPAddr NetLibAddrAToIN (UInt16&nbsp;libRefnum, Char&nbsp;*a)</code></dl></dl><dl><a name="925427"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925428"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925429"> </a><CODE>-&gt; <code>a</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to ASCII dotted decimal string.<br></TD></TR></TABLE></dl><dl><a name="925430"> </a><h4>Result </h4><dl><a name="925431"> </a><p></p><dt>Returns a 32-bit network byte order IP address or -1 if <code>a</code> doesn't represent a dotted decimal IP address</dl></dl><dl><a name="925432"> </a><h4> Sockets Equivalent</h4><dl><a name="925433"> </a><p></p><dt><code>UInt32 inet_addr(char* cp)</code></dl><a name="925434"> </a><h4>See Also </h4><dl><a name="925438"> </a><p></p><dt><code><a href="NetLibrary.html#925440"></code>NetLibAddrINToA<code></a></code> </dl></dl></dl><a name="925440"> </a><br> <br> <br><h3> NetLibAddrINToA</h3><dl><dl><a name="925441"> </a><h4>Purpose </h4><dl><a name="925442"> </a><p></p><dt>Converts an IP address from 32-bit network byte order into a dotted decimal ASCII string.</dl><a name="925443"> </a><h4>Prototype </h4><dl><a name="925445"> </a><dt><code>Char * NetLibAddrINToA (UInt16&nbsp;libRefnum, NetIPAddr&nbsp;inet, Char&nbsp;*spaceP)</code></dl></dl><dl><a name="925447"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925448"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925449"> </a><CODE>-&gt; <code>inet</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>32-bit IP address in network byte order. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925450"> </a><CODE>&lt;- <code>spaceP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Buffer used to hold the return value.<br></TD></TR></TABLE></dl><dl><a name="925451"> </a><h4>Result </h4><dl><a name="925452"> </a><p></p><dt>Returns in <code>spaceP</code> the dotted decimal ASCII string representation of the IP address.</dl></dl><dl><a name="925453"> </a><h4> Sockets Equivalent</h4><dl><a name="925454"> </a><p></p><dt><code>char* inet_ntoa(struct in_addr in)</code></dl><a name="925455"> </a><h4>See Also </h4><dl><a name="925459"> </a><p></p><dt><code><a href="NetLibrary.html#925420"></code>NetLibAddrAToIN<code></a></code> </dl></dl></dl><a name="925462"> </a><br> <br> <br><h3> NetLibClose</h3><dl><dl><a name="925463"> </a><h4>Purpose </h4><dl><a name="925464"> </a><p></p><dt>Closes the net library.</dl><a name="925465"> </a><h4>Prototype </h4><dl><a name="925467"> </a><dt><code>Err NetLibClose (UInt16&nbsp;libRefnum, UInt16&nbsp;immediate)</code></dl></dl><dl><a name="925468"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925469"> </a><CODE>-&gt; <code>libRefnum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925470"> </a><CODE>-&gt; <code>immediate</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>If <code>true</code>, library will shut down immediately. If <code>false</code>, library will shut down only if close timer expires before another <code><a href="NetLibrary.html#927163"></code>NetLibOpen<code></a></code> is issued. <br></TD></TR></TABLE></dl><dl><a name="925474"> </a><h4>Result </h4><dl><a name="925475"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925476"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925478"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Library was not open.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925480"> </a><CODE><code>netErrStillOpen</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Not really an error; returned if library is still in use by another application. <br></TD></TR></TABLE></dl></dl><dl><a name="925481"> </a><h4> Sockets Equivalent</h4><dl><a name="925482"> </a><p></p><dt>None.</dl><a name="925483"> </a><h4>Comments </h4><dl><a name="925484"> </a><p></p><dt>Applications must call this function when they no longer need the net library. If the net library open count is greater than 1 before this call is made, the count is decremented and <code>netErrStillOpen</code> is returned. If the open count was 1, the library takes the following action:<ul type="SQUARE"><a name="925486"> </a><br><li>If <code>immediate</code> is <code>true</code>, the library shuts down immediately. All network interfaces are brought down, the net protocol stack task is terminated, and all memory used by the net library is freed. <br><a name="925487"> </a><br><li>If <code>immediate</code> is <code>false</code>, a close timer is created and this call returns immediately without actually bringing the net library down. Instead it leaves it up and running but marks it as in the "close-wait" state. It remains in this state until either the timer expires or another <code>NetLibOpen</code> is issued. If the timer expires, the library is shut down. If another <code>NetLibOpen</code> call is issued before the timer expires (possibly by another application), the timer is cancelled and the library is marked as fully open.<br></ul><a name="925488"> </a><p></p><dt>In most cases, you should pass <code>false</code> for <code>immediate</code>. This allows the user to quit one Internet application and launch another within a short period of time without having to wait through the process of closing down and then re-establishing dial-up network connections. </dl><a name="925489"> </a><h4>See Also </h4><dl><a name="925496"> </a><p></p><dt><code><a href="NetLibrary.html#927163"></code>NetLibOpen<code></a></code>, <code><a href="NetLibrary.html#927306"></code>NetLibOpenCount<code></a></code> </dl></dl></dl><a name="925884"> </a><br> <br> <br><h3> NetLibConnectionRefresh</h3><dl><dl><a name="925885"> </a><h4>Purpose </h4><dl><a name="925886"> </a><p></p><dt>This routine is a convenience call for applications. It checks the status of all connections and optionally tries to open any that were closed.</dl><a name="925887"> </a><h4>Prototype </h4><dl><a name="925888"> </a><dt><code>Err NetLibConnectionRefresh (UInt16&nbsp;refNum, Boolean&nbsp;refresh, UInt8&nbsp;*allInterfacesUpP, UInt16&nbsp;*&nbsp;netIFErrP) </code></dl></dl><dl><a name="925889"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925890"> </a><CODE><code>-&gt; refnum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925891"> </a><CODE><code>-&gt; refresh</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>If <code>true</code>, any connections that aren't currently open are opened.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925892"> </a><CODE><code>&lt;- allInterfacesUpP</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Set to <code>true</code> if all connections are open.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925893"> </a><CODE><code>&lt;- netIFErrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>First error encountered when reopening connections that were closed. (See <code><a href="NetLibrary.html#926816"></code>NetLibIFUp<code></a></code> for a list of possible values.) <br></TD></TR></TABLE></dl><dl><a name="925897"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925898"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925899"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><dl><a name="925901"> </a><p></p><dt><code>netErrBufTooSmall</code> <a name="925903"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> <a name="925905"> </a><p></p><dt><code>netErrNoInterfaces</code> </dl></dl><dl><a name="925906"> </a><h4> Sockets Equivalent</h4><dl><a name="925907"> </a><p></p><dt>None.</dl><a name="925908"> </a><h4>Comments </h4><dl><a name="925909"> </a><p></p><dt>This function determines whether a connection is up based on the internal status of the TCP/IP stack. To test the presence of a "physical connection" (phone line, modem, serial cable), a command should be sent once it's been determined that the logical connection is up. If the physical connection is broken, nothing returns and a timeout error eventually occurs. </dl></dl></dl><a name="925911"> </a><br> <br> <br><h3> NetLibDmReceive</h3><dl><dl><a name="925912"> </a><h4>Purpose </h4><dl><a name="925913"> </a><p></p><dt>Receive data from a socket directly into a database record.</dl><a name="925914"> </a><h4>Prototype </h4><dl><a name="925916"> </a><dt><code>Int16 NetLibDmReceive (UInt16&nbsp;libRefNum, NetSocketRef&nbsp;socket, void*&nbsp;recordP, UInt32&nbsp;recordOffset, UInt16&nbsp;rcvLen, UInt16&nbsp;flags, void*&nbsp;fromAddrP, UInt16&nbsp;*fromLenP, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="925917"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925918"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925919"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925920"> </a><CODE>&lt;- <code>recordP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to beginning of record to receive data into. Must be locked for use.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925921"> </a><CODE>-&gt; <code>recordOffset</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Offset from beginning of record to read data into.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925922"> </a><CODE>-&gt; <code>rcvLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum number of bytes to read.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925925"> </a><CODE>-&gt; <code>flags</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#925256">I/O Flags</a>."<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925927"> </a><CODE>&lt;- <code>fromAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to buffer to hold address of sender (<code>a <a href="NetLibrary.html#925157"></code>NetSocketAddrType<code></a></code> struct). Pass <code>NULL</code> if you don't need sender information. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925931"> </a><CODE>&lt;-&gt; <code>fromLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>On entry, size of <code>fromAddrP</code> buffer. On exit, actual size of returned address in <code>fromAddrP</code>. Pass <code>NULL</code> if you don't need sender information. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925932"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925933"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="925934"> </a><h4>Result </h4><dl><a name="925935"> </a><p></p><dt>Returns the number of bytes successfully received. If the return value is 0, the socket has been shut down by the remote host. If the return value is -1, an error has occurred and <code>errP</code> contains one of the following values: <TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925936"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925938"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925940"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="925942"> </a><p></p><dt><code>netErrParamErr</code><a name="925944"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="925947"> </a><p></p><dt><code>netErrWouldBlock</code><a name="925949"> </a><p></p><dt><code>netErrUserCancel</code> <a name="925951"> </a><p></p><dt><code>netErrOutOfMemory</code> </dl></dl></dl><dl><a name="925952"> </a><h4>Comments </h4><dl><a name="925956"> </a><p></p><dt>This call behaves similarly to <code><a href="NetLibrary.html#927329"></code>NetLibReceive<code></a></code> but reads the data directly into a database record, which is normally write-protected. The caller must pass a pointer to the start of the record and an offset into the record of where to start the read. </dl></dl></dl><a name="925959"> </a><br> <br> <br><h3> NetLibFinishCloseWait</h3><dl><dl><a name="925960"> </a><h4>Purpose </h4><dl><a name="925961"> </a><p></p><dt>Forces the net library to do a complete close if it's currently in the close-wait state.</dl><a name="925962"> </a><h4>Prototype </h4><dl><a name="925964"> </a><dt><code>Err NetLibFinishCloseWait (UInt16&nbsp;libRefnum)</code></dl></dl><dl><a name="925965"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925966"> </a><CODE>-&gt; <code>libRefnum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE></dl><dl><a name="925967"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925968"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925969"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><dl><a name="925971"> </a><p></p><dt><code>netErrTimeout</code> </dl></dl><dl><a name="925972"> </a><h4> Sockets Equivalent</h4><dl><a name="925973"> </a><p></p><dt>None.</dl><a name="925974"> </a><h4>Comments </h4><dl><a name="925975"> </a><p></p><dt>This call checks the current open state of the net library. If it's in the close-wait state (see <code><a href="NetLibrary.html#925462"></code>NetLibClose<code></a></code>), it forces the library to perform an immediate, complete close operation. </dl></dl></dl><a name="925980"> </a><br> <br> <br><h3> NetLibGetHostByAddr</h3><dl><dl><a name="925981"> </a><h4>Purpose </h4><dl><a name="925982"> </a><p></p><dt>Looks up a host name given its IP address.</dl><a name="925983"> </a><h4>Prototype </h4><dl><a name="925985"> </a><dt><code>NetHostInfoPtr NetLibGetHostByAddr (UInt16&nbsp;libRefnum, UInt8&nbsp;*addrP, UInt16&nbsp;len, UInt16&nbsp;type, NetHostInfoBufPtr&nbsp;bufP, Int32&nbsp;timeout, Err&nbsp;*errP)</code></dl></dl><dl><a name="925986"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925987"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925988"> </a><CODE>-&gt; <code>addrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>IP address of host to lookup.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925989"> </a><CODE>-&gt; <code>len</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length, in bytes, of <code>*addrP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925993"> </a><CODE>-&gt; <code>type</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Type of <code>addrP</code>. See <code><a href="NetLibrary.html#925087"></code>NetSocketAddrEnum<code></a></code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925997"> </a><CODE>&lt;- <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a <code><a href="NetLibrary.html#924943"></code>NetHostInfoBufType<code></a></code> struct in which to store the results of the lookup. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925998"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="925999"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is 0.<br></TD></TR></TABLE></dl><dl><a name="926000"> </a><h4>Result </h4><dl><a name="926004"> </a><p></p><dt>Returns a pointer to the <code><a href="NetLibrary.html#924984"></code>NetHostInfoType<code></a></code> portion of <code>bufP</code> that contains results of the lookup. If the return value is 0, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926005"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926007"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926009"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="926011"> </a><p></p><dt>n<code>etErrDNSNameTooLong</code><a name="926013"> </a><p></p><dt><code>netErrDNSBadName</code><a name="926015"> </a><p></p><dt><code>netErrDNSLabelTooLong</code><a name="926017"> </a><p></p><dt><code>netErrDNSAllocationFailure</code><a name="926019"> </a><p></p><dt><code>netErrDNSTimeout</code><a name="926021"> </a><p></p><dt><code>netErrDNSUnreachable</code><a name="926023"> </a><p></p><dt><code>netErrDNSFormat</code><a name="926025"> </a><p></p><dt><code>netErrDNSServerFailure</code><a name="926027"> </a><p></p><dt><code>netErrDNSNonexistantName</code><a name="926029"> </a><p></p><dt><code>netErrDNSNIY</code><a name="926031"> </a><p></p><dt><code>netErrDNSRefused</code><a name="926033"> </a><p></p><dt><code>netErrDNSImpossible</code><a name="926035"> </a><p></p><dt><code>netErrDNSNoRRS</code><a name="926037"> </a><p></p><dt><code>netErrDNSAborted</code><a name="926039"> </a><p></p><dt><code>netErrDNSBadProtocol</code><a name="926041"> </a><p></p><dt><code>netErrDNSTruncated</code><a name="926043"> </a><p></p><dt><code>netErrDNSNoRecursion</code><a name="926045"> </a><p></p><dt><code>netErrDNSIrrelevant</code><a name="926047"> </a><p></p><dt><code>netErrDNSNotInLocalCache</code><a name="926049"> </a><p></p><dt><code>netErrDNSNoPort</code></dl></dl></dl><dl><a name="926050"> </a><h4> Sockets Equivalent</h4><dl><a name="926051"> </a><p></p><dt><code>struct hostent* gethostbyaddr (char* addr, int len, int type);</code></dl><a name="926052"> </a><h4>Comments </h4><dl><a name="926053"> </a><p></p><dt>This call queries the domain name server(s) to look up a host name given its IP address.</dl><a name="926054"> </a><h4>See Also </h4><dl><a name="926058"> </a><p></p><dt><code><a href="NetLibrary.html#926060"></code>NetLibGetHostByName<code></a></code> </dl></dl></dl><a name="926060"> </a><br> <br> <br><h3> NetLibGetHostByName</h3><dl><dl><a name="926061"> </a><h4>Purpose </h4><dl><a name="926062"> </a><p></p><dt>Looks up a host IP address given a host name.</dl><a name="926063"> </a><h4>Prototype </h4><dl><a name="926065"> </a><dt><code>NetHostInfoPtr NetLibGetHostByName (UInt16&nbsp;libRefnum, Char&nbsp;*nameP, NetHostInfoBufPtr&nbsp;bufP, Int32&nbsp;timeout, Err&nbsp;*errP)</code></dl></dl><dl><a name="926066"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926067"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926068"> </a><CODE>-&gt; <code>nameP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Name of host to look up.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926072"> </a><CODE>&lt;- <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a <code><a href="NetLibrary.html#924943"></code>NetHostInfoBufType<code></a></code> struct in which to store the results of the lookup. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926073"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926074"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is 0.<br></TD></TR></TABLE></dl><dl><a name="926075"> </a><h4>Result </h4><dl><a name="926079"> </a><p></p><dt>Returns a pointer to the <code><a href="NetLibrary.html#924984"></code>NetHostInfoType<code></a></code> portion of <code>bufP</code>, which contains results of the lookup. If the return value is 0, an error has occurred and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926080"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926082"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926084"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="926086"> </a><p></p><dt>n<code>etErrDNSNameTooLong</code><a name="926088"> </a><p></p><dt><code>netErrDNSBadName</code><a name="926090"> </a><p></p><dt><code>netErrDNSLabelTooLong</code><a name="926092"> </a><p></p><dt><code>netErrDNSAllocationFailure</code><a name="926094"> </a><p></p><dt><code>netErrDNSTimeout</code><a name="926096"> </a><p></p><dt><code>netErrDNSUnreachable</code><a name="926098"> </a><p></p><dt><code>netErrDNSFormat</code><a name="926100"> </a><p></p><dt><code>netErrDNSServerFailure</code><a name="926102"> </a><p></p><dt><code>netErrDNSNonexistantName</code><a name="926104"> </a><p></p><dt><code>netErrDNSNIY</code><a name="926106"> </a><p></p><dt><code>netErrDNSRefused</code><a name="926108"> </a><p></p><dt><code>netErrDNSImpossible</code><a name="926110"> </a><p></p><dt><code>netErrDNSNoRRS</code><a name="926112"> </a><p></p><dt><code>netErrDNSAborted</code><a name="926114"> </a><p></p><dt><code>netErrDNSBadProtocol</code><a name="926116"> </a><p></p><dt><code>netErrDNSTruncated</code><a name="926118"> </a><p></p><dt><code>netErrDNSNoRecursion</code><a name="926120"> </a><p></p><dt><code>netErrDNSIrrelevant</code><a name="926122"> </a><p></p><dt><code>netErrDNSNotInLocalCache</code><a name="926124"> </a><p></p><dt><code>netErrDNSNoPort</code></dl></dl></dl><dl><a name="926125"> </a><h4> Sockets Equivalent</h4><dl><a name="926126"> </a><p></p><dt><code>struct hostent *gethostbyname(char* name);</code></dl><a name="926127"> </a><h4>Comments </h4><dl><a name="926128"> </a><p></p><dt>This call first checks the local name -&gt; IP address host table in the net library preferences. If the entry is not found, it then queries the domain name server(s). </dl><a name="926129"> </a><h4>See Also </h4><dl><a name="926136"> </a><p></p><dt><code><a href="NetLibrary.html#925980"></code>NetLibGetHostByAddr<code></a></code>, <code><a href="NetLibrary.html#926138"></code>NetLibGetMailExchangeByName<code></a></code> </dl></dl></dl><a name="926138"> </a><br> <br> <br><h3> NetLibGetMailExchangeByName</h3><dl><dl><a name="926139"> </a><h4>Purpose </h4><dl><a name="926140"> </a><p></p><dt>Looks up the name of a host to use for a given mail exchange. </dl><a name="926141"> </a><h4>Prototype </h4><dl><a name="926143"> </a><dt><code>Int16 NetLibGetMailExchangeByName (UInt16&nbsp;libRefNum, Char&nbsp;*mailNameP, UInt16&nbsp;maxEntries, Char&nbsp;hostNames[][netDNSMaxDomainName+1], UInt16&nbsp;priorities[], Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="926144"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926145"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926146"> </a><CODE>-&gt; <code>mailNameP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Name of the mail exchange to look up.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926147"> </a><CODE>-&gt; <code>maxEntries</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum number of host names to return.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926148"> </a><CODE>&lt;- <code>hostNames</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Array of character strings of length <code>netDNSMaxDomainName+1</code>. The host name results are stored in this array. This array must be able to hold at least <code>maxEntries</code> host names. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926149"> </a><CODE>&lt;- <code>priorities</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Array of <code>Word</code>s. The priorities of each host name found are stored in this array. This array must be at least <code>maxEntries</code> in length.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926150"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926151"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is less than 0.<br></TD></TR></TABLE></dl><dl><a name="926152"> </a><h4>Result </h4><dl><a name="926153"> </a><p></p><dt>Returns the number of entries successfully found. If the return value is a negative number, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926154"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926156"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926158"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="926160"> </a><p></p><dt><code>netErrDNSNameTooLong</code><a name="926162"> </a><p></p><dt><code>netErrDNSBadName</code><a name="926164"> </a><p></p><dt><code>netErrDNSLabelTooLong</code><a name="926166"> </a><p></p><dt><code>netErrDNSAllocationFailure</code><a name="926168"> </a><p></p><dt><code>netErrDNSTimeout</code><a name="926170"> </a><p></p><dt><code>netErrDNSUnreachable</code><a name="926172"> </a><p></p><dt><code>netErrDNSFormat</code><a name="926174"> </a><p></p><dt><code>netErrDNSServerFailure</code><a name="926176"> </a><p></p><dt><code>netErrDNSNonexistantName</code><a name="926178"> </a><p></p><dt><code>netErrDNSNIY</code><a name="926180"> </a><p></p><dt><code>netErrDNSRefused</code><a name="926182"> </a><p></p><dt><code>netErrDNSImpossible</code><a name="926184"> </a><p></p><dt><code>netErrDNSNoRRS</code><a name="926186"> </a><p></p><dt><code>netErrDNSAborted</code><a name="926188"> </a><p></p><dt><code>netErrDNSBadProtocol</code><a name="926190"> </a><p></p><dt><code>netErrDNSTruncated</code><a name="926192"> </a><p></p><dt><code>netErrDNSNoRecursion</code><a name="926194"> </a><p></p><dt><code>netErrDNSIrrelevant</code><a name="926196"> </a><p></p><dt><code>netErrDNSNotInLocalCache</code><a name="926198"> </a><p></p><dt><code>netErrDNSNoPort</code></dl></dl></dl><dl><a name="926199"> </a><h4> Sockets Equivalent</h4><dl><a name="926200"> </a><p></p><dt>None</dl><a name="926201"> </a><h4>Comments </h4><dl><a name="926202"> </a><p></p><dt>This call looks up the name(s) of host(s) to use for sending an e-mail. The caller passes the name of the mail exchange in <code>mailNameP</code> and gets back a list of host names to which the mail message can be sent. </dl><a name="926203"> </a><h4>See Also </h4><dl><a name="926210"> </a><p></p><dt><code><a href="NetLibrary.html#925980"></code>NetLibGetHostByAddr<code></a></code>, <code><a href="NetLibrary.html#926060"></code>NetLibGetHostByName<code></a></code> </dl></dl></dl><a name="926212"> </a><br> <br> <br><h3> NetLibGetServByName</h3><dl><dl><a name="926213"> </a><h4>Purpose </h4><dl><a name="926214"> </a><p></p><dt>Looks up the port number for a standard TCP/IP service, given the desired protocol.</dl><a name="926215"> </a><h4>Prototype </h4><dl><a name="926217"> </a><dt><code>NetServInfoPtr NetLibGetServByName (UInt16&nbsp;libRefnum, const&nbsp;Char&nbsp;*servNameP, const&nbsp;Char&nbsp;*protoNameP, NetServInfoBufPtr&nbsp;bufP, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="926218"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926219"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926220"> </a><CODE>-&gt; <code>servNameP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Name of the service to look up. Possible services are "echo", "discard", "daytime", "qotd", "chargen", "ftp-data", "ftp", "telnet", "smtp", "time", "name", "finger", "pop2", "pop3", "nntp", "imap2".<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926221"> </a><CODE>-&gt; <code>protoNameP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Desired protocol to use, either "udp" or "tcp". <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926225"> </a><CODE>&lt;- <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a <code><a href="NetLibrary.html#925022"></code>NetServInfoBufType<code></a></code> struct in which to store the results of the lookup. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926226"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926227"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is 0.<br></TD></TR></TABLE></dl><dl><a name="926228"> </a><h4>Result </h4><dl><a name="926232"> </a><p></p><dt>Returns a pointer to the <code><a href="NetLibrary.html#925058"></code>NetServInfoType<code></a></code> portion of <code>bufP</code> that contains results of the lookup. If the return value is 0, and error has occurred and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926233"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926235"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926237"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="926239"> </a><p></p><dt><code>netErrUnknownProtocol</code><a name="926241"> </a><p></p><dt><code>netErrUnknownService</code></dl></dl></dl><dl><a name="926242"> </a><h4> Sockets Equivalent</h4><dl><a name="926243"> </a><p></p><dt><code>struct servent* getservbyname(char* addr, char*&nbsp;proto);</code></dl><a name="926244"> </a><h4>Comments </h4><dl><a name="926245"> </a><p></p><dt>This call is a convenience call for looking up a standard port number given the name of a service and the protocol to use. </dl><a name="926246"> </a><h4>See Also </h4><dl><a name="926250"> </a><p></p><dt><code><a href="NetLibrary.html#926060"></code>NetLibGetHostByName<code></a></code> </dl></dl></dl><a name="926252"> </a><br> <br> <br><h3> NetLibIFAttach</h3><dl><dl><a name="926253"> </a><h4>Purpose </h4><dl><a name="926254"> </a><p></p><dt>Attach a new network interface.</dl><a name="926255"> </a><h4>Prototype </h4><dl><a name="926257"> </a><dt><code>Err NetLibIFAttach (UInt16&nbsp;libRefnum, UInt32&nbsp;ifCreator, UInt16&nbsp;ifInstance, Int32&nbsp;timeout)</code></dl></dl><dl><a name="926258"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926259"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926260"> </a><CODE>-&gt; <code>ifCreator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Creator of interface to attach.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926261"> </a><CODE>-&gt; <code>ifInstance</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Instance number of interface to attach. The instance number is one of the values returned by <code><a href="NetLibrary.html#926358"></code>NetLibIFGet<code></a></code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926265"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Timeout in ticks; -1 means infinite timeout.<br></TD></TR></TABLE></dl><dl><a name="926266"> </a><h4>Result </h4><dl><a name="926267"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926268"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><dl><a name="926270"> </a><p></p><dt><code>netErrInterfaceNotFound</code><a name="926272"> </a><p></p><dt><code>netErrTooManyInterfaces</code></dl></dl></dl><dl><a name="926273"> </a><h4> Sockets Equivalent</h4><dl><a name="926274"> </a><p></p><dt>None</dl><a name="926275"> </a><h4>Comments </h4><dl><a name="926276"> </a><p></p><dt>This call can be used to attach a new network interface to the net library. Network interfaces are self-contained databases of type <code>'neti'</code>. The <code>ifCreator</code> parameter to this function is used to locate the network interface database of the given creator. <a name="926277"> </a><p></p><dt>If the net library is already open when this call is made, the network interface's database will be located and then called to initialize itself and attach itself to the protocol stack in real time. If the net library is not open when this call is made, the creator and instance number of the interface are stored in the net library's preferences database and the interface is initialized and attached to the stack the next time the net library is opened. </dl><a name="926278"> </a><h4>See Also </h4><dl><a name="926285"> </a><p></p><dt><code><a href="NetLibrary.html#926358"></code>NetLibIFGet<code></a></code>, <code><a href="NetLibrary.html#926287"></code>NetLibIFDetach<code></a></code> </dl></dl></dl><a name="926287"> </a><br> <br> <br><h3> NetLibIFDetach</h3><dl><dl><a name="926288"> </a><h4>Purpose </h4><dl><a name="926289"> </a><p></p><dt>Detach a network interface from the protocol stack.</dl><a name="926290"> </a><h4>Prototype </h4><dl><a name="926292"> </a><dt><code>Err NetLibIFDetach (UInt16&nbsp;libRefnum, UInt32&nbsp;ifCreator, UInt16&nbsp;ifInstance, Int32&nbsp;timeout)</code></dl></dl><dl><a name="926293"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926294"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926295"> </a><CODE>-&gt; <code>ifCreator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Creator of interface to detach.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926296"> </a><CODE>-&gt; <code>ifInstance</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Instance number of interface to detach.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926297"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Timeout in ticks; -1 means infinite timeout.<br></TD></TR></TABLE></dl><dl><a name="926298"> </a><h4>Result </h4><dl><a name="926299"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926300"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><dl><a name="926302"> </a><p></p><dt><code>netErrInterfaceNotFound</code></dl></dl></dl><dl><a name="926303"> </a><h4> Sockets Equivalent</h4><dl><a name="926304"> </a><p></p><dt>None</dl><a name="926305"> </a><h4>Comments </h4><dl><a name="926306"> </a><p></p><dt>If the net library is already open when this call is made, the interface is brought down and detached from the protocol stack in real time. If the net library is not open when this call is made, the creator and instance number of the interface are removed in the net library's preferences database and the interface is not attached the next time the library is opened. </dl><a name="926307"> </a><h4>See Also </h4><dl><a name="926314"> </a><p></p><dt><code><a href="NetLibrary.html#926358"></code>NetLibIFGet<code></a></code>, <code><a href="NetLibrary.html#926252"></code>NetLibIFAttach<code></a></code> </dl></dl></dl><a name="926316"> </a><br> <br> <br><h3> NetLibIFDown</h3><dl><dl><a name="926317"> </a><h4>Purpose </h4><dl><a name="926318"> </a><p></p><dt>Bring an interface down and hang up a connection.</dl><a name="926319"> </a><h4>Prototype </h4><dl><a name="926321"> </a><dt><code>Err NetLibIFDown (UInt16&nbsp;libRefnum, UInt32&nbsp;ifCreator, UInt16&nbsp;ifInstance, Int32&nbsp;timeout)</code></dl></dl><dl><a name="926322"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926323"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926324"> </a><CODE>-&gt; <code>ifCreator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Creator of interface to attach.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926325"> </a><CODE>-&gt; <code>ifInstance</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Instance number of interface to attach.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926326"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Timeout in ticks; -1 means wait forever.<br></TD></TR></TABLE></dl><dl><a name="926327"> </a><h4>Result </h4><dl><a name="926328"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926329"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926331"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="926333"> </a><p></p><dt><code>netErrInterfaceNotFound</code></dl></dl></dl><dl><a name="926334"> </a><h4> Sockets Equivalent</h4><dl><a name="926335"> </a><p></p><dt>None</dl><a name="926336"> </a><h4>Comments </h4><dl><a name="926337"> </a><p></p><dt>The net library must be open before this call can be made. For dial-up interfaces, this call terminates a connection and hangs up the modem if necessary. <a name="926341"> </a><p></p><dt><code><a href="NetLibrary.html#925462"></code>NetLibClose<code></a></code> automatically brings down any attached interfaces, so this routine doesn't normally have to be called. <a name="926342"> </a><p></p><dt>If the interface is already down, this routine returns immediately with no error. </dl><a name="926343"> </a><h4>See Also </h4><dl><a name="926353"> </a><p></p><dt><code><a href="NetLibrary.html#926358"></code>NetLibIFGet<code></a></code>, <code><a href="NetLibrary.html#926252"></code>NetLibIFAttach<code></a></code>, <code><a href="NetLibrary.html#926287"></code>NetLibIFDetach<code></a></code>, <code><a href="NetLibrary.html#926816"></code>NetLibIFUp<code></a></code> </dl></dl></dl><a name="926358"> </a><br> <br> <br><h3> NetLibIFGet</h3><dl><dl><a name="926359"> </a><h4>Purpose </h4><dl><a name="926360"> </a><p></p><dt>Get the creator and instance number of an installed interface by index.</dl><a name="926361"> </a><h4>Prototype </h4><dl><a name="926363"> </a><dt><code>Err NetLibIFGet (UInt16&nbsp;libRefnum, UInt16&nbsp;index, UInt16&nbsp;*&nbsp;ifCreatorP, UInt16&nbsp;*&nbsp;ifInstanceP)</code></dl></dl><dl><a name="926364"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926365"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926366"> </a><CODE>-&gt; <code>index</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Index of the interface to get. Indices start at 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926367"> </a><CODE>&lt;- <code>ifCreatorP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The interface's creator. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926368"> </a><CODE>&lt;- <code>ifInstanceP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The interface's instance number.<br></TD></TR></TABLE></dl><dl><a name="926369"> </a><h4>Result </h4><dl><a name="926370"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926371"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926373"> </a><CODE><code>netErrInvalidInterface</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Index too high<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926375"> </a><CODE><code>netErrPrefNotFound</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>No current value for setting.<br></TD></TR></TABLE></dl></dl><dl><a name="926376"> </a><h4> Sockets Equivalent</h4><dl><a name="926377"> </a><p></p><dt>None</dl><a name="926378"> </a><h4>Comments </h4><dl><a name="926379"> </a><p></p><dt>To get a list of all installed interfaces, call this function with successively increasing indices starting from 0 until the error <code>netErrInvalidInterface</code> is returned. <a name="926380"> </a><p></p><dt>The <code>ifCreator</code> and <code>ifInstance</code> values returned from this call can then be used with the <code><a href="NetLibrary.html#927759"></code>NetLibSettingGet<code></a></code> call to get more information about that particular interface. </dl><a name="926384"> </a><h4>See Also </h4><dl><a name="926393"> </a><p></p><dt><code><a href="NetLibrary.html#926252"></code>NetLibIFAttach<code></a></code>, <code><a href="NetLibrary.html#926287"></code>NetLibIFDetach<code></a></code>, "<a href="NetworkCommunication.html#925128">Settings for Interface Selection</a>" in the <em>Palm OS Programmer's Companion</em> </dl></dl></dl><a name="926396"> </a><br> <br> <br><h3> NetLibIFSettingGet</h3><dl><dl><a name="926397"> </a><h4>Purpose </h4><dl><a name="926398"> </a><p></p><dt>Retrieves a network interface specific setting.</dl><a name="926399"> </a><h4>Prototype </h4><dl><a name="926401"> </a><dt><code>Err NetLibIFSettingGet (UInt16&nbsp;libRefnum, UInt32&nbsp;ifCreator, UInt16&nbsp;ifInstance, UInt16&nbsp;setting, void&nbsp;*valueP, UInt16&nbsp;*valueLenP)</code></dl></dl><dl><a name="926402"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926403"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926404"> </a><CODE>-&gt; <code>ifCreator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Creator of the network interface.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926405"> </a><CODE>-&gt; <code>ifInstance</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Instance number of the network interface.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926406"> </a><CODE>-&gt; <code>setting</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Setting to retrieve; one of the <code>NetIFSettingEnum</code> constants.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926408"> </a><CODE>&lt;- <code>valueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Space for return value of setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926409"> </a><CODE>&lt;-&gt; <code>valueLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>On entry, size of <code>valueP</code>. On exit, actual size of setting.<br></TD></TR></TABLE></dl><dl><a name="926410"> </a><h4>Result </h4><dl><a name="926411"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926412"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926414"> </a><CODE><code>netErrUnknownSetting</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Invalid setting constant.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926416"> </a><CODE><code>netErrPrefNotFound</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>No current value for setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926418"> </a><CODE><code>netErrBufTooSmall</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>valueP</code> was too small to hold entire setting. Setting value was truncated to fit in <code>valueP</code>.<br></TD></TR></TABLE><dl><a name="926420"> </a><p></p><dt><code>netErrUnimplemented</code><a name="926422"> </a><p></p><dt><code>netErrInterfaceNotFound</code><a name="926424"> </a><p></p><dt><code>netErrBufWrongSize</code></dl></dl></dl><dl><a name="926425"> </a><h4> Sockets Equivalent</h4><dl><a name="926426"> </a><p></p><dt>None</dl><a name="926427"> </a><h4>Comments </h4><dl><a name="926428"> </a><p></p><dt>This call can be used to retrieve the current value of any network interface setting. The caller must pass a pointer to a buffer to hold the return value (value<code>P</code>), the size of the buffer (<code>*valueLenP</code>), and the setting ID (<code>setting</code>). The setting ID is one of the constants in the <code>NetIFSettingEnum</code> type. <a name="926430"> </a><p></p><dt>Some settings, such as the login script, are variable size. For these types of settings, you can obtain the actual size required for the buffer by passing 0 for <code>*valueLenP</code>. The required size is returned in <code>valueLenP</code>. <a name="926434"> </a><p></p><dt><a href="NetLibrary.html#934002">Table 54.1</a> lists the network interface settings and the size of each setting. Some are only applicable to certain types of interfaces. Settings not applicable to a specific interface can be safely ignored and not set to any particular value.<p><a name="926742"> </a> </p><p><div> <table border="3"><caption><B><a name="934002"> </a><h4>Table 54.1	 Network Interface Settings&nbsp;</h4></B></caption><tr><th><a name="926439"> </a><strong>netIFSetting...</strong></th><th><a name="926441"> </a><strong>Type</strong></th><th><a name="926443"> </a><strong>Description</strong></th></tr><tr><td><a name="926445"> </a>ResetAll</td><td><a name="926447"> </a>void</td><td><a name="926452"> </a>Use with <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> only. This clears all other settings for the interface to their default values.</td></tr><tr><td><a name="926454"> </a>Up</td><td><a name="926456"> </a>UInt8</td><td><a name="926458"> </a>Read-only. <code>true</code> if interface is currently up.</td></tr><tr><td><a name="926460"> </a>Name</td><td><a name="926462"> </a>Char[32]</td><td><a name="926464"> </a>Read-only. Name of this interface.</td></tr><tr><td><a name="926466"> </a>ReqIPAddr</td><td><a name="926468"> </a>UInt32</td><td><a name="926470"> </a>IP address of interface. </td></tr><tr><td><a name="926472"> </a>SubnetMask</td><td><a name="926474"> </a>UInt32</td><td><a name="926476"> </a>Subnet mask for interface. Doesn't need to be specified for PPP or SLIP type connections.</td></tr><tr><td><a name="926478"> </a>Broadcast</td><td><a name="926480"> </a>UInt32</td><td><a name="926482"> </a>Broadcast address for interface. Doesn't need to be specified for PPP or SLIP type connections.</td></tr><tr><td><a name="926484"> </a>Username</td><td><a name="926486"> </a>Char[32]</td><td><a name="926488"> </a>User name. Only required if the login script uses the user name substitution escape sequence in it. Call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0 to remove this setting. </td></tr><tr><td><a name="926493"> </a>Password</td><td><a name="926495"> </a>Char[32]</td><td><a name="926497"> </a>Password. Only required if the login script uses the password substitution escape sequence in it. Call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0 to remove this setting. If the login script uses password substitution and no password setting is set, the user will be prompted for a password at connect time. </td></tr><tr><td><a name="926520"> </a>AuthUsername</td><td><a name="926522"> </a>Char[32]</td><td><a name="926524"> </a>Authentication user name. Only required if the authentication protocol uses a different user name than the what's in the <code>netIFSettingUsername</code> setting. If this setting is empty (<code>valueLen</code> of 0), the Username setting will be used instead. Call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0 to remove this setting. </td></tr><tr><td><a name="926529"> </a>AuthPassword</td><td><a name="926531"> </a>Char[32]</td><td><a name="926533"> </a>Authentication password. If "$" then the user will be prompted for the authentication password at connect time. Else, if 0 length, then the <code>netIFSettingPassword</code> setting or the result of its prompt will be used instead. Call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0 to remove this setting. </td></tr><tr><td><a name="926538"> </a>ServiceName</td><td><a name="926540"> </a>Char[]</td><td><a name="926542"> </a>Service name. Used for display purposes while showing the connection progress dialog box. Call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0 to remove this setting. </td></tr><tr><td><a name="926547"> </a>LoginScript</td><td><a name="926549"> </a>Char[]</td><td><a name="926551"> </a>Login script. Only required if the particular service requires a login sequence. Call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0 to remove this setting. See below for a description of the login script format.</td></tr><tr><td><a name="926556"> </a>ConnectLog</td><td><a name="926558"> </a>Char[]</td><td><a name="926560"> </a>Connect log. Generally, this setting is just retrieved, not set. It contains a log of events from the most recent login. To clear this setting, call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0. </td></tr><tr><td><a name="926565"> </a>InactivityTimeout</td><td><a name="926567"> </a>UInt16</td><td><a name="926569"> </a>Maximum number of seconds of inactivity allowed. Set to 0 to ignore. </td></tr><tr><td><a name="926571"> </a>EstablishmentTimeout</td><td><a name="926573"> </a>UInt16</td><td><a name="926575"> </a>Maximum delay, in seconds, allowed between each stage of connection establishment or login script line. Must be non-zero. </td></tr><tr><td><a name="926577"> </a>DynamicIP</td><td><a name="926579"> </a>UInt8</td><td><a name="926581"> </a>If non-zero, negotiate for an IP address. If <code>false</code>, the IP address specified in the <code>netIFSettingReqIPAddr</code> setting will be used. Default is <code>false</code>. </td></tr><tr><td><a name="926583"> </a>VJCompEnable</td><td><a name="926585"> </a>UInt8</td><td><a name="926587"> </a>If non-zero, enable VJ header compression. Default is <code>true</code> for PPP, <code>false</code> for SLIP, and <code>true</code> for CSLIP. </td></tr><tr><td><a name="926589"> </a>VJCompSlots</td><td><a name="926591"> </a>UInt8</td><td><a name="926593"> </a>Number of slots to use for VJ compression. Default is 4 for PPP and 16 for SLIP and CSLIP. More slots require more memory so it is best to keep this number to a minimum. </td></tr><tr><td><a name="926595"> </a>MTU</td><td><a name="926597"> </a>UInt16</td><td><a name="926599"> </a>Maximum transmission unit in octets. Currently not implemented in SLIP or PPP.</td></tr><tr><td><a name="926601"> </a>AsyncCtlMap</td><td><a name="926603"> </a>UInt32</td><td><a name="926605"> </a>Bit mask of characters to escape for PPP. Default is 0.</td></tr><tr><td><a name="926607"> </a>PortNum</td><td><a name="926609"> </a>UInt16</td><td><a name="926611"> </a>Which serial communication port to use. Port 0 is the only port available on the device. </td></tr><tr><td><a name="926613"> </a>BaudRate</td><td><a name="926615"> </a>UInt32</td><td><a name="926617"> </a>Serial port baud rate to use in bits per second. </td></tr><tr><td><a name="926619"> </a>FlowControl</td><td><a name="926621"> </a>UInt8</td><td><a name="926623"> </a>If bit 0 is 1, use hardware handshaking on the serial port. Default is no hardware handshaking. </td></tr><tr><td><a name="926625"> </a>StopBits</td><td><a name="926627"> </a>UInt8</td><td><a name="926629"> </a>Number of stop bits. Default is 1.</td></tr><tr><td><a name="926631"> </a>ParityOn</td><td><a name="926633"> </a>UInt8</td><td><a name="926635"> </a><code>true</code> if parity detection enabled. Default is <code>false</code>.</td></tr><tr><td><a name="926637"> </a>ParityEven</td><td><a name="926639"> </a>UInt8</td><td><a name="926641"> </a><code>true</code> for even parity detection. Default is <code>true</code>.</td></tr><tr><td><a name="926643"> </a>UseModem</td><td><a name="926645"> </a>UInt8</td><td><a name="926647"> </a>If <code>true</code>, dial-up through modem. If <code>false</code>, go direct over serial port</td></tr><tr><td><a name="926649"> </a>PulseDial</td><td><a name="926651"> </a>UInt8</td><td><a name="926653"> </a>If <code>true</code>, pulse dial modem. Else, tone dial. Default is tone dial.</td></tr><tr><td><a name="926655"> </a>ModemInit</td><td><a name="926657"> </a>Char[]</td><td><a name="926659"> </a>Zero-terminated modem initialization string, not including the "AT". If not specified (<code>valueLen</code> of 0), the modem initialization string from system preferences are used.</td></tr><tr><td><a name="926661"> </a>ModemPhone</td><td><a name="926663"> </a>Char[]</td><td><a name="926665"> </a>Zero-terminated modem phone number string. Only required if <code>netIFSettingUseModem</code> is true.</td></tr><tr><td><a name="926667"> </a>RedialCount</td><td><a name="926669"> </a>UInt16</td><td><a name="926671"> </a>Number of times to redial modem when trying to establish a connection. Only required if <code>netIFSettingUseModem</code> is true.</td></tr><tr><td><a name="926694"> </a>DNSQuery</td><td><a name="926696"> </a>UInt8</td><td><a name="926698"> </a><code>true</code> if PPP queries for DNS address. The default is <code>true</code>. </td></tr><tr><td><a name="926700"> </a>TraceBits</td><td><a name="926702"> </a>UInt32</td><td><a name="926707"> </a>A bitfield of various trace bits. See "<a href="NetLibrary.html#925277">Tracing Bits</a>."<dl><a name="926708"> </a><p></p><dt>An application can get a list of events in the trace buffer using the <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code> call. Each interface has its own trace bits setting so that trace event recording in each interface can be selectively enabled or disabled. </dl></td></tr><tr><td><a name="926719"> </a>ActualIPAddr</td><td><a name="926721"> </a>UInt32</td><td><a name="926723"> </a>Read-only. The actual IP address that the interface ends up using. The login script execution engine stores the result of the "g" (get IP address) command here as does the PPP negotiation logic.</td></tr><tr><td><a name="926725"> </a>ServerIPAddr</td><td><a name="926727"> </a>UInt32</td><td><a name="926729"> </a>Read-only. The IP address of the PPP server we're connected to. </td></tr><tr><td><a name="926731"> </a>BringDownOnPowerDown</td><td><a name="926733"> </a>UInt8</td><td><a name="926735"> </a><code>true</code> if the interface is brought down when the Palm OS<sup>&#174;</sup> device is turned off. </td></tr><tr><td><a name="926737"> </a>RawMode</td><td><a name="926739"> </a>UInt32</td><td><a name="926741"> </a>Specifies if the interface is in raw mode. The net library places an interface in raw mode when it is bound to a raw socket in the raw domain. Raw sockets are available in Palm OS version 3.0 and higher. </td></tr></table><table><tr><td></table></div></p></dl><a name="926743"> </a><h4>See Also </h4><dl><a name="926750"> </a><p></p><dt><code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code>, <code><a href="NetLibrary.html#927759"></code>NetLibSettingGet<code></a></code>, <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code>, <a href="NetworkCommunication.html#925166">"Interface Specific Settings"</a> in the <em>Palm OS Programmer's Companion</em> </dl></dl></dl><a name="926758"> </a><br> <br> <br><h3> NetLibIFSettingSet</h3><dl><dl><a name="926759"> </a><h4>Purpose </h4><dl><a name="926760"> </a><p></p><dt>Sets a network interface specific setting.</dl><a name="926761"> </a><h4>Prototype </h4><dl><a name="926763"> </a><dt><code>Err NetLibIFSettingSet (UInt16&nbsp;libRefnum, UInt32&nbsp;ifCreator, UInt16&nbsp;ifInstance, UInt16&nbsp;setting, void*&nbsp;valueP, UInt16&nbsp;valueLen)</code></dl></dl><dl><a name="926764"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926765"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926766"> </a><CODE>-&gt; <code>ifCreator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Creator of the network interface.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926767"> </a><CODE>-&gt; <code>ifInstance</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Instance number of the network interface.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926768"> </a><CODE>-&gt; <code>setting</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The setting to set, one of the <code>NetIFSettingEnum</code> constants. See <a href="NetLibrary.html#934002">Table 54.1</a>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926773"> </a><CODE>-&gt; <code>valueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Space new value of setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926774"> </a><CODE>-&gt; <code>valueLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size of new setting.<br></TD></TR></TABLE></dl><dl><a name="926775"> </a><h4>Result </h4><dl><a name="926776"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926777"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926779"> </a><CODE><code>netErrUnknownSetting</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Invalid setting constant.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926781"> </a><CODE><code>netErrPrefNotFound</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>No current value for setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926783"> </a><CODE><code>netErrBufTooSmall</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>valueP</code> was too small to hold entire setting. Setting value was truncated to fit in <code>valueP</code>.<br></TD></TR></TABLE><dl><a name="926785"> </a><p></p><dt><code>netErrUnimplemented</code><a name="926787"> </a><p></p><dt><code>netErrInterfaceNotFound</code><a name="926789"> </a><p></p><dt><code>netErrBufWrongSize</code><a name="926791"> </a><p></p><dt><code>netErrReadOnlySetting</code></dl></dl></dl><dl><a name="926792"> </a><h4> Sockets Equivalent</h4><dl><a name="926793"> </a><p></p><dt>None</dl><a name="926794"> </a><h4>Comments </h4><dl><a name="926795"> </a><p></p><dt>This call can be used to set the current value of any network interface setting. The caller must pass a pointer to a buffer which holds the new value (<code>valueP</code>), the size of the buffer (<code>valueLen</code>), and the setting ID (<code>setting</code>). <a name="926799"> </a><p></p><dt>See <code><a href="NetLibrary.html#926396"></code>NetLibIFSettingGet<code></a></code> for an explanation of each of the settings. <a name="926800"> </a><p></p><dt>Of particular interest is the <code>netIFSettingResetAll</code> setting, which, if used, resets all settings for the interface to their default values. When using this setting, <code>valueP</code> and <code>valueLen</code> are ignored.</dl><a name="926801"> </a><h4>See Also </h4><dl><a name="926808"> </a><p></p><dt><code><a href="NetLibrary.html#926396"></code>NetLibIFSettingGet<code></a></code>, <code><a href="NetLibrary.html#927759"></code>NetLibSettingGet<code></a></code>, <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a>,</code> <a href="NetworkCommunication.html#925166">"Interface Specific Settings"</a> in the <em>Palm OS Programmer's Companion</em></dl></dl></dl><a name="926816"> </a><br> <br> <br><h3> NetLibIFUp</h3><dl><dl><a name="926817"> </a><h4>Purpose </h4><dl><a name="926818"> </a><p></p><dt>Bring an interface up and establish a connection.</dl><a name="926819"> </a><h4>Prototype </h4><dl><a name="926821"> </a><dt><code>Err NetLibIFUp (UInt16&nbsp;libRefnum, UInt32&nbsp;ifCreator, UInt16&nbsp;ifInstance)</code></dl></dl><dl><a name="926822"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926823"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926824"> </a><CODE>-&gt; <code>ifCreator</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Creator of interface to attach.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926825"> </a><CODE>-&gt; <code>ifInstance</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Instance number of interface to attach.<br></TD></TR></TABLE></dl><dl><a name="926826"> </a><h4>Result </h4><dl><a name="926827"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926828"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926830"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="926832"> </a><p></p><dt><code>netErrInterfaceNotFound</code><a name="926834"> </a><p></p><dt><code>netErrUserCancel</code><a name="926836"> </a><p></p><dt><code>netErrBadScript</code><a name="926838"> </a><p></p><dt><code>netErrPPPTimeout</code><a name="926840"> </a><p></p><dt><code>netErrAuthFailure</code><a name="926842"> </a><p></p><dt><code>netErrPPPAddressRefused</code></dl></dl></dl><dl><a name="926843"> </a><h4> Sockets Equivalent</h4><dl><a name="926844"> </a><p></p><dt>None</dl><a name="926845"> </a><h4>Comments </h4><dl><a name="926846"> </a><p></p><dt>The net library must be open before this call can be made. For dial-up interfaces, this call will dial up the modem if necessary and run through the connect script to establish the connection. <a name="926853"> </a><p></p><dt>If the interface is already up, this routine returns immediately with no error. This call doesn't take a timeout parameter because it relies on each interface to have its own established timeout setting. </dl><a name="926854"> </a><h4>See Also </h4><dl><a name="926864"> </a><p></p><dt><code><a href="NetLibrary.html#926358"></code>NetLibIFGet<code></a></code>, <code><a href="NetLibrary.html#926252"></code>NetLibIFAttach<code></a></code>, <code><a href="NetLibrary.html#926287"></code>NetLibIFDetach<code></a></code>, <code><a href="NetLibrary.html#926316"></code>NetLibIFDown<code></a></code> </dl></dl></dl><a name="926869"> </a><br> <br> <br><h3> NetLibMaster</h3><dl><dl><a name="926870"> </a><h4>Purpose </h4><dl><a name="926871"> </a><p></p><dt>Retrieves the network statistics, interface statistics, and the contents of the trace buffer. </dl><a name="926872"> </a><h4>Prototype </h4><dl><a name="926874"> </a><dt><code>Err NetLibMaster (UInt16&nbsp;libRefnum, UInt16&nbsp;cmd, NetMasterPBPtr&nbsp;pbP, Int32&nbsp;timeout)&nbsp;</code></dl></dl><dl><a name="926876"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926877"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926879"> </a><CODE>-&gt; <code>cmd</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Function to perform (<code>NetMasterEnum</code> type). The following commands are supported:<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926883"> </a><CODE><code><a href="NetLibrary.html#926920"></code>netMasterInterfaceInfo<code></a><a href="NetLibrary.html#927046"></code>netMasterInterfaceStats<code></a><a href="NetLibrary.html#927124"></code>netMasterIPStats<code></a><a href="NetLibrary.html#927128"></code>netMasterICMPStats<code></a><a href="NetLibrary.html#927132"></code>netMasterUDPStats<code></a><a href="NetLibrary.html#927136"></code>netMasterTCPStats<code></a></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><code><a href="NetLibrary.html#926920"></code>netMasterInterfaceInfo<code></a><a href="NetLibrary.html#927046"></code>netMasterInterfaceStats<code></a><a href="NetLibrary.html#927124"></code>netMasterIPStats<code></a><a href="NetLibrary.html#927128"></code>netMasterICMPStats<code></a><a href="NetLibrary.html#927132"></code>netMasterUDPStats<code></a><a href="NetLibrary.html#927136"></code>netMasterTCPStats<code></a><a href="NetLibrary.html#927140"></code>netMasterTraceEventGet<code></a></code><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926902"> </a><CODE>&lt;-&gt; <code>pbP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Command parameter block.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926903"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Timeout in ticks; -1 means wait forever.<br></TD></TR></TABLE></dl><dl><a name="926904"> </a><h4>Result </h4><dl><a name="926905"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926906"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="926908"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="926910"> </a><p></p><dt><code>netErrParamErr</code><a name="926912"> </a><p></p><dt><code>netErrUnimplemented</code></dl></dl></dl><dl><a name="926913"> </a><h4> Sockets Equivalent</h4><dl><a name="926914"> </a><p></p><dt>None</dl><a name="926915"> </a><h4>Comments </h4><dl><a name="926916"> </a><p></p><dt>This call allows applications to get detailed information about the net library. This information is usually helpful in debugging network configuration problems. <a name="926917"> </a><p></p><dt>This function takes a command word (<code>cmd</code>) and parameter block pointer (<code>pbP</code>) as arguments and returns its results in the parameter block on exit. Which values you must specify in the parameter block and which values are returned are specific to the command you specify. </dl></dl></dl><a name="926920"> </a><h4> netMasterInterfaceInfo </h4><dl><a name="926921"> </a><p></p><dt>The <code>pbP-&gt;interfaceInfo</code> struct specifies interface information. <p><a name="927043"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="926924"> </a><code>-&gt;</code></td><td><a name="926926"> </a><code>index </code></td><td><a name="926928"> </a>Index of interface to fetch info about.</td></tr><tr><td><a name="926930"> </a><code>&lt;-</code></td><td><a name="926932"> </a><code>creator</code></td><td><a name="926934"> </a>Creator of interface.</td></tr><tr><td><a name="926936"> </a><code>&lt;-</code></td><td><a name="926938"> </a><code>instance</code></td><td><a name="926940"> </a>Instance of interface.</td></tr><tr><td><a name="926942"> </a><code>&lt;-</code></td><td><a name="926944"> </a><code>netIFP</code></td><td><a name="926946"> </a>Private interface info pointer.</td></tr><tr><td><a name="926948"> </a><code>&lt;-</code></td><td><a name="926950"> </a><code>drvrName</code></td><td><a name="926952"> </a>Driver type that interface uses ("PPP", "SLIP", etc.).</td></tr><tr><td><a name="926954"> </a><code>&lt;-</code></td><td><a name="926956"> </a><code>hwName</code></td><td><a name="926958"> </a>Hardware driver name ("Serial Library", etc.).</td></tr><tr><td><a name="926960"> </a><code>&lt;-</code></td><td><a name="926962"> </a><code>localNetHdrLen</code></td><td><a name="926964"> </a>Number of bytes in local net header.</td></tr><tr><td><a name="926966"> </a><code>&lt;-</code></td><td><a name="926968"> </a><code>localNetTrailerLen</code> </td><td><a name="926970"> </a>Number of bytes in local net trailer.</td></tr><tr><td><a name="926972"> </a><code>&lt;-</code></td><td><a name="926974"> </a><code>localNetMaxFrame</code></td><td><a name="926976"> </a>Local net maximum frame size.</td></tr><tr><td><a name="926978"> </a><code>&lt;-</code></td><td><a name="926980"> </a><code>ifName</code></td><td><a name="926982"> </a>Interface name with instance number concatenated.</td></tr><tr><td><a name="926984"> </a><code>&lt;-</code></td><td><a name="926986"> </a><code>driverUp</code></td><td><a name="926988"> </a><code>true</code> if interface driver is up.</td></tr><tr><td><a name="926990"> </a><code>&lt;-</code></td><td><a name="926992"> </a><code>ifUp</code></td><td><a name="926994"> </a><code>true</code> if interface media layer is up.</td></tr><tr><td><a name="926996"> </a><code>&lt;-</code></td><td><a name="926998"> </a><code>hwAddrLen</code></td><td><a name="927000"> </a>Length of interface's hardware address.</td></tr><tr><td><a name="927002"> </a><code>&lt;-</code></td><td><a name="927004"> </a><code>hwAddr</code></td><td><a name="927006"> </a>Interface's hardware address.</td></tr><tr><td><a name="927008"> </a><code>&lt;-</code></td><td><a name="927010"> </a><code>mtu</code></td><td><a name="927012"> </a>Maximum transfer unit of interface.</td></tr><tr><td><a name="927014"> </a><code>&lt;-</code></td><td><a name="927016"> </a><code>speed</code></td><td><a name="927018"> </a>Speed in bits per second.</td></tr><tr><td><a name="927020"> </a><code>&lt;-</code></td><td><a name="927022"> </a><code>lastStateChange</code></td><td><a name="927024"> </a>Time in milliseconds of last state change.</td></tr><tr><td><a name="927026"> </a><code>&lt;-</code></td><td><a name="927028"> </a><code>ipAddr</code></td><td><a name="927030"> </a>IP address of interface.</td></tr><tr><td><a name="927032"> </a><code>&lt;-</code></td><td><a name="927034"> </a><code>subnetMask</code></td><td><a name="927036"> </a>Subnet mask of local network.</td></tr><tr><td><a name="927038"> </a><code>&lt;-</code></td><td><a name="927040"> </a><code>broadcast</code></td><td><a name="927042"> </a>Broadcast address of local network.</td></tr></table><table><tr><td></table></div></p></dl><a name="927046"> </a><h4> netMasterInterfaceStats</h4><dl><a name="927047"> </a><p></p><dt>The <code>pbP-&gt;interfaceStats</code> structure specifies interface statistics.<p><a name="927121"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="927050"> </a><code>-&gt;</code></td><td><a name="927052"> </a><code>index </code></td><td><a name="927054"> </a>Index of interface to fetch info about.</td></tr><tr><td><a name="927056"> </a><code>&lt;-</code></td><td><a name="927058"> </a><code>inOctets</code></td><td><a name="927060"> </a>Number of octets received.</td></tr><tr><td><a name="927062"> </a><code>&lt;-</code></td><td><a name="927064"> </a><code>inUcastPkts</code></td><td><a name="927066"> </a>Number of packets received.</td></tr><tr><td><a name="927068"> </a><code>&lt;-</code></td><td><a name="927070"> </a><code>inNUcastPkts</code></td><td><a name="927072"> </a>Number of broadcast packets received.</td></tr><tr><td><a name="927074"> </a><code>&lt;-</code></td><td><a name="927076"> </a><code>inDiscards</code></td><td><a name="927078"> </a>Number of incoming packets that were discarded.</td></tr><tr><td><a name="927080"> </a><code>&lt;-</code></td><td><a name="927082"> </a><code>inErrors</code></td><td><a name="927084"> </a>Number of packet errors encountered.</td></tr><tr><td><a name="927086"> </a><code>&lt;-</code></td><td><a name="927088"> </a><code>inUnknownProtos </code></td><td><a name="927090"> </a>Number of unknown protocols encountered.</td></tr><tr><td><a name="927092"> </a><code>&lt;-</code></td><td><a name="927094"> </a><code>outOctets</code></td><td><a name="927096"> </a>Number octets sent.</td></tr><tr><td><a name="927098"> </a><code>&lt;-</code></td><td><a name="927100"> </a><code>outUcastPkts</code></td><td><a name="927102"> </a>Number of packets sent.</td></tr><tr><td><a name="927104"> </a><code>&lt;-</code></td><td><a name="927106"> </a><code>outNUcastPkts</code></td><td><a name="927108"> </a>Number of broadcast packets sent.</td></tr><tr><td><a name="927110"> </a><code>&lt;-</code></td><td><a name="927112"> </a><code>outDiscards</code></td><td><a name="927114"> </a>Number of packets discarded.</td></tr><tr><td><a name="927116"> </a><code>&lt;-</code></td><td><a name="927118"> </a><code>outErrors</code></td><td><a name="927120"> </a>Number of outbound packet errors.</td></tr></table><table><tr><td></table></div></p></dl><a name="927124"> </a><h4> netMasterIPStats</h4><dl><a name="927125"> </a><p></p><dt>The <code>pbP-&gt;ipStats</code> structure contains statistics about the IP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </dl><a name="927128"> </a><h4> netMasterICMPStats</h4><dl><a name="927129"> </a><p></p><dt>The <code>pbP-&gt;icmpStats</code> structure contains statistics about the ICMP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </dl><a name="927132"> </a><h4> netMasterUDPStats</h4><dl><a name="927133"> </a><p></p><dt>The <code>pbP-&gt;udpStats</code> structure contains statistics about the UDP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </dl><a name="927136"> </a><h4> netMasterTCPStats</h4><dl><a name="927137"> </a><p></p><dt>The <code>pbP-&gt;tcpStats</code> structure contains statistics about the TCP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </dl><a name="927140"> </a><h4> netMasterTraceEventGet</h4><dl><a name="927141"> </a><p></p><dt>The <code>pbP-&gt;traceEventGet</code> structure contains a trace event. <p><a name="927155"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="927144"> </a><code>-&gt;</code></td><td><a name="927146"> </a><code>index</code></td><td><a name="927148"> </a>Index of event to fetch.</td></tr><tr><td><a name="927150"> </a><code>&lt;-</code></td><td><a name="927152"> </a><code>textP</code></td><td><a name="927154"> </a>Pointer to text string to return event in. Should be at least 256 bytes long.</td></tr></table><table><tr><td></table></div></p><dl><a name="927156"> </a><h4>See Also </h4><dl><a name="927160"> </a><p></p><dt><code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code> </dl></dl></dl><a name="927163"> </a><br> <br> <br><h3> NetLibOpen</h3><dl><dl><a name="927164"> </a><h4>Purpose </h4><dl><a name="927165"> </a><p></p><dt>Opens and initializes the net library.</dl><a name="927166"> </a><h4>Prototype </h4><dl><a name="927168"> </a><dt><code>Err NetLibOpen (UInt16&nbsp;libRefnum, UInt16&nbsp;*netIFErrP)</code></dl></dl><dl><a name="927169"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927170"> </a><CODE>-&gt; <code>libRefnum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927171"> </a><CODE>&lt;- <code>netIFErrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>First error encountered when bringing up network interfaces. (See <code><a href="NetLibrary.html#926816"></code>NetLibIFUp<code></a></code> for a list of possible values.) <br></TD></TR></TABLE></dl><dl><a name="927175"> </a><h4>Result </h4><dl><a name="927176"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927177"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927179"> </a><CODE><code>netErrAlreadyOpen</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Not really an error; returned if library was already open and the open count was simply incremented.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927181"> </a><CODE>n<code>etErrOutOfMemory</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Not enough memory available to open the library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927183"> </a><CODE><code>netErrNoInterfaces</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Incorrect setup.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927185"> </a><CODE><code>netErrPrefNotFound</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Incorrect setup.<br></TD></TR></TABLE></dl></dl><dl><a name="927186"> </a><h4>Comments </h4><dl><a name="927187"> </a><p></p><dt>Applications must call this function before using the net library. If the net library was already open, <code>NetLibOpen</code> increments its open count. Otherwise, it opens the library, initializes it, starts up the net protocol stack component of the library as a separate task, and brings up all attached network interfaces. <a name="927188"> </a><p></p><dt><code>NetLibOpen</code> uses settings saved in the net library's preferences database during initialization. These settings include the interfaces to attach, the IP addresses, etc. It's assumed that these settings have been previously set up by a preference panel or equivalent so an application doesn't normally have to set them up before calling <code>NetLibOpen</code>. <a name="927191"> </a><p></p><dt>If any of the attached interfaces fails to come up, *<code>netIFErrP</code> will contain the error number of the first interface that encountered a problem.</dl><a name="927207"> </a><h4>See Also </h4><dl><a name="927217"> </a><p></p><dt><code><a href="SystemManager.html#925491"></code>SysLibFind<code></a></code>, <code><a href="NetLibrary.html#925462"></code>NetLibClose<code></a></code>, <code><a href="NetLibrary.html#927306"></code>NetLibOpenCount<code></a></code> </dl></dl></dl><a name="927306"> </a><br> <br> <br><h3> NetLibOpenCount</h3><dl><dl><a name="927307"> </a><h4>Purpose </h4><dl><a name="927309"> </a><p></p><dt>Retrieves the open count of the net library.</dl><a name="927310"> </a><h4>Prototype </h4><dl><a name="927312"> </a><dt><code>Err NetLibOpenCount (UInt16&nbsp;libRefnum, UInt16&nbsp;*countP)</code></dl></dl><dl><a name="927313"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927314"> </a><CODE>-&gt; <code>libRefnum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927315"> </a><CODE>&lt;- <code>countP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains the open count of the net library upon return. <br></TD></TR></TABLE></dl><dl><a name="927316"> </a><h4>Result </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927317"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE></dl><dl><a name="927318"> </a><h4> Sockets Equivalent</h4><dl><a name="927319"> </a><p></p><dt>None.</dl><a name="927320"> </a><h4>Comments </h4><dl><a name="927321"> </a><p></p><dt>This call will most likely only be used by the Network preferences panel. Most applications will simply call <code><a href="NetLibrary.html#927163"></code>NetLibOpen<code></a></code> unconditionally during startup and <code><a href="NetLibrary.html#925462"></code>NetLibClose<code></a></code> when they exit. </dl></dl></dl><a name="927329"> </a><br> <br> <br><h3> NetLibReceive</h3><dl><dl><a name="927330"> </a><h4>Purpose </h4><dl><a name="927331"> </a><p></p><dt>Receive data from a socket into a single buffer.</dl><a name="927332"> </a><h4>Prototype </h4><dl><a name="927334"> </a><dt><code>Int16 NetLibReceive (UInt16&nbsp;libRefNum, NetSocketRef&nbsp;socket, void*&nbsp;bufP, UInt16&nbsp;bufLen, UInt16&nbsp;flags, void*&nbsp;fromAddrP, UInt16&nbsp;*&nbsp;fromLenP, Int32&nbsp;timeout, Err*&nbsp;errP);</code></dl></dl><dl><a name="927335"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927336"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927337"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927338"> </a><CODE>&lt;- <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to buffer to hold received data.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927339"> </a><CODE>-&gt; <code>bufLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length of <code>bufP</code> buffer.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927342"> </a><CODE>-&gt; <code>flags</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#925256">I/O Flags</a>."<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927344"> </a><CODE>&lt;- <code>fromAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to buffer to hold address of sender (a <code><a href="NetLibrary.html#925157"></code>NetSocketAddrType<code></a></code>).<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927348"> </a><CODE>&lt;-&gt; <code>fromLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>On entry, size of <code>fromAddrP</code> buffer. On exit, actual size of returned address in <code>fromAddrP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927349"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927350"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="927351"> </a><h4>Result </h4><dl><a name="927352"> </a><p></p><dt>Returns the number of bytes successfully received. If the return value is 0, the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927353"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927355"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927357"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="927359"> </a><p></p><dt><code>netErrParamErr</code><a name="927361"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="927363"> </a><p></p><dt><code>netErrWouldBlock</code><a name="927365"> </a><p></p><dt><code>netErrUserCancel</code> </dl></dl></dl><dl><a name="927366"> </a><h4> Sockets Equivalent</h4><dl><a name="927367"> </a><p></p><dt><code>int recvfrom (int&nbsp;socket, const&nbsp;void*&nbsp;bufP, int&nbsp;bufLen, int&nbsp;flags, const&nbsp;void*&nbsp;fromAddrP, int*&nbsp;fromLenP);</code><a name="927368"> </a><p></p><dt><code>int recv(int&nbsp;socket, const&nbsp;void*&nbsp;bufP, int&nbsp;bufLen, int&nbsp;flags);</code><a name="927369"> </a><p></p><dt><code>int read(int&nbsp;socket, const&nbsp;void*&nbsp;bufP, int&nbsp;bufLen);</code></dl><a name="927370"> </a><h4>Comments </h4><dl><a name="927371"> </a><p></p><dt>For stream-based sockets, this call reads whatever bytes are available and returns the number of bytes actually read into the caller's buffer. If there is no data available, this call will block until at least one byte arrives, until the socket is shut down by the remote host, or until a timeout occurs. <a name="927372"> </a><p></p><dt>For datagram-based sockets, this call reads a complete datagram and returns the number of bytes in the datagram. If the caller's buffer is not large enough to hold the entire datagram, the end of the datagram is discarded. If a datagram is not available, this call will block until one arrives, or until the call times out. <a name="927381"> </a><p></p><dt>The data is read into a single buffer pointed to by <code>bufP</code>.</dl><a name="927382"> </a><h4>See Also </h4><dl><a name="927395"> </a><p></p><dt><code><a href="NetLibrary.html#927329"></code>NetLibReceive<code></a></code>, <code><a href="NetLibrary.html#925911"></code>NetLibDmReceive<code></a></code>, <code><a href="NetworkUtils.html#924937"></code>NetUReadN<code></a></code>, <code><a href="NetLibrary.html#927575"></code>NetLibSend<code></a></code>, <code><a href="NetLibrary.html#927671"></code>NetLibSendPB<code></a></code> </dl></dl></dl><a name="927400"> </a><br> <br> <br><h3> NetLibReceivePB</h3><dl><dl><a name="927401"> </a><h4>Purpose </h4><dl><a name="927402"> </a><p></p><dt>Receive data from a socket into a multi-buffer gather-read array.</dl><a name="927403"> </a><h4>Prototype </h4><dl><a name="927405"> </a><dt><code>Int16 NetLibReceivePB (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, NetIOParamType*&nbsp;pbP, UInt16&nbsp;flags, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="927406"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927407"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927408"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927409"> </a><CODE>-&gt; <code>pbP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to parameter block containing buffer info. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927412"> </a><CODE>-&gt; <code>flags</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#925256">I/O Flags</a>."<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927414"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927415"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="927416"> </a><h4>Result </h4><dl><a name="927417"> </a><p></p><dt>Returns the number of bytes successfully received. Returns 0 if the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927418"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927420"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927422"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="927424"> </a><p></p><dt><code>netErrParamErr</code><a name="927426"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="927428"> </a><p></p><dt><code>netErrWouldBlock</code></dl></dl></dl><dl><a name="927429"> </a><h4> Sockets Equivalent</h4><dl><a name="927430"> </a><p></p><dt><code>int recvmsg (int socket, const struct msghdr* pbP, int flags);</code></dl><a name="927431"> </a><h4>Comments </h4><dl><a name="927433"> </a><p></p><dt>The <code>pbP</code> parameter is a pointer to a <code>NetIOParamType</code> structure. <code>NetIOParamType</code> is defined as follows:</dl></dl><dl><a name="927435"> </a><br><code>typedef struct {</code><br></dl><dl><a name="927436"> </a><code>&nbsp&nbsp&nbsp UInt8&nbsp;*	 	 	 	 	 	 addrP;</code><br><a name="927437"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 	 addrLen;</code><br><a name="927438"> </a><code>&nbsp&nbsp&nbsp NetIOVecPtr	 	 	 	 	 	 iov;</code><br><a name="927439"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 	 iovLen;</code><br><a name="927440"> </a><code>&nbsp&nbsp&nbsp UInt8&nbsp;*	 	 	 	 	 	 accessRights;</code><br><a name="927441"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 	 	 	 	 accessRightsLen;</code><br><a name="927442"> </a><code>} NetIOParamType, *NetIOParamPtr;</code><br><dl><a name="927443"> </a><p></p><dt>You provide the following information in this struct:<p><a name="927473"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="927446"> </a><code>addrP</code> </td><td><a name="927448"> </a>Address of sender, set by <code>NetLibReceivePB</code>. Set to 0 if you don't require this field. </td></tr><tr><td><a name="927450"> </a><code>addrLen</code> </td><td><a name="927452"> </a>Length of <code>*addrP</code>.</td></tr><tr><td><a name="927454"> </a><code>iov</code> </td><td><a name="946476"> </a>Array of buffers into which the data should be received. <code>NetIOVecPtr</code> is a pointer to a <code>NetIOVecType</code> structure, which has two fields:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927459"> </a><CODE><code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to a buffer.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927460"> </a><CODE><code>bufLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length of <code>bufP</code>. <br></TD></TR></TABLE></td></tr><tr><td><a name="927462"> </a><code>iovLen</code> </td><td><a name="927464"> </a>Length of the <code>iov</code> array.</td></tr><tr><td><a name="927466"> </a><code>accessRights</code> </td><td><a name="927468"> </a>Access rights. This field currently isn't used and should be set to 0. </td></tr><tr><td><a name="927470"> </a><code>accessRightsLen</code> </td><td><a name="927472"> </a>Length of the <code>*accessRights</code>. This field currently isn't used and should be set to 0. </td></tr></table><table><tr><td></table></div></p><a name="927474"> </a><p></p><dt>For stream-based sockets, this call reads whatever bytes are available and returns the number of bytes actually read into the caller's buffer. If no data is available, this call will block until at least one byte arrives, until the socket is shut down by the remote host, or until a timeout occurs. <a name="927475"> </a><p></p><dt>For datagram-based sockets, this call reads a complete datagram and returns the number of bytes in the datagram. If the caller's buffer is not large enough to hold the entire datagram, the end of the datagram is discarded. If a datagram is not available, this call will block until one arrives, or until the call times out. <a name="927484"> </a><p></p><dt>The data is read into the gather-read array specified by the <code>pbP-&gt;iov</code> array. </dl></dl><dl><a name="927485"> </a><h4>See Also </h4><dl><a name="927495"> </a><p></p><dt><code><a href="NetLibrary.html#927329"></code>NetLibReceive<code></a></code>, <code><a href="NetLibrary.html#925911"></code>NetLibDmReceive<code></a></code>, <code><a href="NetLibrary.html#927575"></code>NetLibSend<code></a></code>, <code><a href="NetLibrary.html#927671"></code>NetLibSendPB<code></a></code> </dl></dl></dl><a name="927500"> </a><br> <br> <br><h3> NetLibSelect</h3><dl><dl><a name="927501"> </a><h4>Purpose </h4><dl><a name="927502"> </a><p></p><dt>Blocks until I/O is ready on one or more descriptors, where a descriptor can represent socket input, socket output, or a user input event like a pen tap or key press.</dl><a name="927503"> </a><h4>Prototype </h4><dl><a name="927505"> </a><dt><code>Int16 NetLibSelect (UInt16&nbsp;libRefnum, UInt16&nbsp;width, NetFDSetType*&nbsp;readFDs, NetFDSetType*&nbsp;writeFDs, NetFDSetType*&nbsp;exceptFDs, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="927506"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927507"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927508"> </a><CODE>-&gt; <code>width</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Number of descriptor bits to check in the <code>readFDs</code>, <code>writeFDs</code>, and <code>exceptFDs</code> descriptor sets. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927510"> </a><CODE>&lt;-&gt; <code>readFDs</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to 32-bit <code>NetFDSetType</code> containing set of bits representing descriptors to check for input.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927511"> </a><CODE>&lt;-&gt; <code>writeFDs</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to 32-bit <code>NetFDSetType</code> containing set of bits representing descriptors to check for output.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927512"> </a><CODE>&lt;-&gt; <code>exceptFDs</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to 32-bit <code>NetFDSetType</code> containing set of bits representing descriptors to check for exception conditions. This parameter is ignored. Upon return, its bits are always cleared.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927513"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927514"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="927515"> </a><h4>Result </h4><dl><a name="927516"> </a><p></p><dt>Returns the sum total number of ready file descriptors in *<code>readFDs</code>, *<code>writeFDs</code>, and *<code>exceptFDs</code>. Returns 0 upon timeout. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927517"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927518"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927520"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE></dl></dl><dl><a name="927521"> </a><h4> Sockets Equivalent</h4><dl><a name="927522"> </a><p></p><dt><code>int select (int width, fd_set* readfds, fd_set*&nbsp;writefds, fd_set* exceptfds, struct&nbsp;timeval* timeout);</code></dl><a name="927523"> </a><h4>Comments </h4><dl><a name="927524"> </a><p></p><dt>This call blocks until one or more descriptors are ready for I/O. In the Palm OS environment, a descriptor is either a <code>NetSocketRef</code> or the "stdin" descriptor, <code>sysFileDescStdIn</code>. The <code>sysFileDescStdIn</code> descriptor will be ready for input whenever a user event is available like a pen tap or key press. <a name="927526"> </a><p></p><dt>The caller should set which bits in each descriptor set need to be checked by using the <code>netFDZero</code> and <code>netFDSet</code> macros. After this call returns, the macro <code>netFDIsSet</code> can be used to determine which descriptors in each set are actually ready. <a name="927530"> </a><p></p><dt>On exit, the total number of ready descriptors is returned and each descriptor set is updated with the appropriate bits set for each ready descriptor in that set. <a name="927539"> </a><p></p><dt>The following example illustrates how to use this call to check for input on a socket or a user event:<br></dl></dl><dl><a name="927540"> </a><code>&nbsp&nbsp&nbsp Err	      err;</code><br><a name="927541"> </a><code>&nbsp&nbsp&nbsp NetSocketRef	    socket;</code><br><a name="927542"> </a><code>&nbsp&nbsp&nbsp NetFDSetType	    readFDs,writeFDs,exceptFDs;</code><br><a name="927543"> </a><code>&nbsp&nbsp&nbsp Int16	        numFDs;</code><br><a name="927544"> </a><code>&nbsp&nbsp&nbsp UInt16	        width;</code><br><a name="927545"> </a><code></code><br><a name="927546"> </a><code>&nbsp&nbsp&nbsp // Create the descriptor sets</code><br><a name="927547"> </a><code>&nbsp&nbsp&nbsp netFDZero(&amp;readFDs);</code><br><a name="927548"> </a><code>&nbsp&nbsp&nbsp netFDZero(&amp;writeFDs);</code><br><a name="927549"> </a><code>&nbsp&nbsp&nbsp netFDZero(&amp;exceptFDs);</code><br><a name="927550"> </a><code>&nbsp&nbsp&nbsp netFDSet(sysFileDescStdIn, &amp;readFDs);</code><br><a name="927551"> </a><code>&nbsp&nbsp&nbsp netFDSet(socket, &amp;readFDs);</code><br><a name="927552"> </a><code></code><br><a name="927553"> </a><code>&nbsp&nbsp&nbsp // Calculate the max descriptor number and </code><br><a name="927554"> </a><code>&nbsp&nbsp&nbsp // use that +1 as the max width. </code><br><a name="927555"> </a><code>&nbsp&nbsp&nbsp // Alternatively, we could simply use the </code><br><a name="927557"> </a><code>&nbsp&nbsp&nbsp // constant netFDSetSize as the width which </code><br><a name="927558"> </a><code>&nbsp&nbsp&nbsp // is simpler but makes the NetLibSelect call </code><br><a name="927559"> </a><code>&nbsp&nbsp&nbsp // slightly slower. </code><br><a name="927560"> </a><code>&nbsp&nbsp&nbsp width = sysFileDescStdIn;</code><br><a name="927561"> </a><code>&nbsp&nbsp&nbsp if (socket &gt; width) width = socket;</code><br><a name="927562"> </a><code></code><br><a name="927563"> </a><code>&nbsp&nbsp&nbsp // Wait for any one of the descriptors to be </code><br><a name="927564"> </a><code>&nbsp&nbsp&nbsp // ready.</code><br><a name="927565"> </a><code>&nbsp&nbsp&nbsp numFDs = NetLibSelect(AppNetRefnum, width+1,</code><br><a name="927566"> </a><code>&nbsp&nbsp&nbsp 	 &amp;readFDs, &amp;writeFDs, &amp;exceptFDs,</code><br><a name="927567"> </a><code>&nbsp&nbsp&nbsp 	 AppNetTimeout, &amp;err);</code><br><dl><a name="927568"> </a><p></p><dt>Also see the <code>NetSample</code> example application in the <code>Palm OS Examples</code> folder. The function <code>CmdTelnet</code> in the file <code>CmdTelnet.c</code> shows how to use the Berkeley sockets <code>select</code> function and how to interpret the results. </dl></dl><dl><a name="927569"> </a><h4>See Also </h4><dl><a name="927573"> </a><p></p><dt><code><a href="NetLibrary.html#928465"></code>NetLibSocketOptionSet<code></a></code> </dl></dl></dl><a name="927575"> </a><br> <br> <br><h3> NetLibSend</h3><dl><dl><a name="927576"> </a><h4>Purpose </h4><dl><a name="927577"> </a><p></p><dt>Send data to a socket from a single buffer.</dl><a name="927578"> </a><h4>Prototype </h4><dl><a name="927580"> </a><dt><code>Int16 NetLibSend (UInt16 libRefNum, NetSocketRef&nbsp;socket, void*&nbsp;bufP, UInt16&nbsp;bufLen, UInt16 flags, void*&nbsp;toAddrP, UInt16&nbsp;toLen, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="927581"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927582"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927583"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927584"> </a><CODE>-&gt; <code>bufP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to data to write.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927585"> </a><CODE>-&gt; <code>bufLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length of data to write<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927588"> </a><CODE>-&gt; <code>flags</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#925256">I/O Flags</a>."<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927590"> </a><CODE>-&gt; <code>toAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Address to send to (a pointer to a <code><a href="NetLibrary.html#925157"></code>NetSocketAddrType<code></a></code>), or 0.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927594"> </a><CODE>-&gt; <code>toLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size of <code>toAddrP</code> buffer.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927595"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927596"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="927597"> </a><h4>Result </h4><dl><a name="927598"> </a><p></p><dt>Returns the number of bytes successfully sent. Returns 0 if the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927599"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927601"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927603"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="927605"> </a><p></p><dt><code>netErrParamErr</code><a name="927607"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="927609"> </a><p></p><dt><code>netErrMessageTooBig</code><a name="927611"> </a><p></p><dt><code>netErrSocketNotConnected</code><a name="927613"> </a><p></p><dt><code>netErrSocketClosedByRemote</code><a name="927615"> </a><p></p><dt><code>netErrIPCantFragment</code><a name="927617"> </a><p></p><dt><code>netErrIPNoRoute</code><a name="927619"> </a><p></p><dt><code>netErrIPNoSrc</code><a name="927621"> </a><p></p><dt><code>netErrIPNoDst</code><a name="927623"> </a><p></p><dt><code>netErrIPktOverflow</code><a name="927625"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> <a name="927627"> </a><p></p><dt><code>netErrOutOfPackets</code> <a name="927629"> </a><p></p><dt><code>netErrInterfaceNotFound</code> <a name="927631"> </a><p></p><dt><code>netErrInterfaceDown</code> <a name="927633"> </a><p></p><dt><code>netErrUnreachableDest</code> <a name="927635"> </a><p></p><dt><code>netErrNoMultiPktAddr</code> <a name="927637"> </a><p></p><dt><code>netErrWouldBlock</code> </dl></dl></dl><dl><a name="927638"> </a><h4> Sockets Equivalent</h4><dl><a name="927639"> </a><p></p><dt><code>int sendto(int socket, const void* bufP, int&nbsp;bufLen, int flags, const void* toAddrP, int&nbsp;toLen);</code><a name="927640"> </a><p></p><dt><code>int send(int socket, const void* bufP, int bufLen, int flags);</code><a name="927641"> </a><p></p><dt><code>int write(int socket, const void* bufP, int&nbsp;bufLen,);</code></dl><a name="927642"> </a><h4>Comments </h4><dl><a name="927643"> </a><p></p><dt>This call attempts to write data to the specified socket and returns the number of bytes actually sent, which may be less than or equal to the requested number of bytes. The data is passed in a single buffer that <code>bufP</code> points to.<a name="927644"> </a><p></p><dt>For datagram sockets, you must only send a single packet at a time. If the data is too large to fit in a single UDP packet (1536 bytes), no data is sent and -1 is returned.<a name="927650"> </a><p></p><dt>The <code>toAddrP</code> field applies only to datagram sockets without an existing connection. An error is returned if the datagram socket was previously connected and <code>toAddrP</code> is specified. Stream-based sockets, by definition, must have a connection established with a remote host before data can be written. Raw sockets (supported in Palm OS version 3.0 and higher) must construct the entire IP header, including the destination address, before data can be sent; thus, the address is taken from the data to be sent. <a name="927651"> </a><p></p><dt>If there isn't enough buffer space to send any data, this call will block until there is enough buffer space, or until a timeout.<a name="927652"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>For stream-based sockets, this call may write only a portion of the desired data. It always returns the number of bytes actually written. Consequently, the caller should be prepared to call this routine repeatedly until the desired number of bytes have been written, or until it returns 0 or -1. <hr><br></blockquote></dl><a name="927653"> </a><h4>See Also </h4><dl><a name="927663"> </a><p></p><dt><code><a href="NetLibrary.html#927671"></code>NetLibSendPB<code></a></code>, <code><a href="NetworkUtils.html#925065"></code>NetUWriteN<code></a></code>, <code><a href="NetLibrary.html#927329"></code>NetLibReceive<code></a></code>, <code><a href="NetLibrary.html#927400"></code>NetLibReceivePB<code></a></code>, <code><a href="NetLibrary.html#925911"></code>NetLibDmReceive<code></a></code> </dl></dl></dl><a name="927671"> </a><br> <br> <br><h3> NetLibSendPB</h3><dl><dl><a name="927672"> </a><h4>Purpose </h4><dl><a name="927673"> </a><p></p><dt>Send data to a socket from a scatter-write array.</dl><a name="927674"> </a><h4>Prototype </h4><dl><a name="927676"> </a><dt><code>Int16 NetLibSendPB (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, NetIOParamType*&nbsp;pbP, UInt16&nbsp;flags, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="927677"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927678"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927679"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927680"> </a><CODE>-&gt; <code>pbP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to parameter block containing buffer info. See the description in <code><a href="NetLibrary.html#927400"></code>NetLibReceivePB<code></a></code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927686"> </a><CODE>-&gt; <code>flags</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#925256">I/O Flags</a>."<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927688"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927689"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="927690"> </a><h4>Result </h4><dl><a name="927691"> </a><p></p><dt>Returns the number of bytes successfully sent. Returns 0 if the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927692"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927694"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927696"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="927698"> </a><p></p><dt><code>netErrParamErr</code><a name="927700"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="927702"> </a><p></p><dt><code>netErrMessageTooBig</code><a name="927704"> </a><p></p><dt><code>netErrSocketNotConnected</code><a name="953941"> </a><p></p><dt><code>netErrSocketClosedByRemote</code><a name="927708"> </a><p></p><dt><code>netErrIPCantFragment</code><a name="927710"> </a><p></p><dt><code>netErrIPNoRoute</code><a name="927712"> </a><p></p><dt><code>netErrIPNoSrc</code><a name="927714"> </a><p></p><dt><code>netErrIPNoDst</code><a name="927716"> </a><p></p><dt><code>netErrIPktOverflow</code><a name="927718"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> <a name="927720"> </a><p></p><dt><code>netErrOutOfPackets</code> <a name="927722"> </a><p></p><dt><code>netErrInterfaceNotFound</code> <a name="927724"> </a><p></p><dt><code>netErrInterfaceDown</code> <a name="927726"> </a><p></p><dt><code>netErrUnreachableDest</code> <a name="927728"> </a><p></p><dt><code>netErrNoMultiPktAddr</code> <a name="927730"> </a><p></p><dt><code>netErrWouldBlock</code> </dl></dl></dl><dl><a name="927731"> </a><h4> Sockets Equivalent</h4><dl><a name="927732"> </a><p></p><dt><code>int sendmsg(int socket, const struct msghdr* pbP, int flags);</code></dl><a name="927733"> </a><h4>Comments </h4><dl><a name="927734"> </a><p></p><dt>This call attempts to write data to the given socket and returns the number of bytes actually sent, which may be less than or equal to the requested number of bytes. The data is passed in the scatter-write array specified in the <code>pbP</code> parameter block. <a name="927735"> </a><p></p><dt>For datagram sockets, you must only send a single packet at a time. If the data is too large to fit in a single UDP packet, no data is sent and -1 is returned.<a name="927741"> </a><p></p><dt>The <code>toAddrP</code> field applies only to datagram sockets without an existing connection. An error is returned if the datagram socket was previously connected and <code>toAddrP</code> is specified. Stream-based sockets, by definition, must have a connection established with a remote host before data can be written. Raw sockets (supported in Palm OS version 3.0 and higher) must construct the entire IP header, including the destination address, before data can be sent; thus, the address is taken from the data to be sent. <a name="927742"> </a><p></p><dt>If there isn't enough buffer space to send any data, this call will block until there is space, or until a timeout.<a name="927743"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>For stream-based sockets, this call may write only a portion of the desired data. It always returns the number of bytes actually written. Consequently, the caller should be prepared to call this routine repeatedly until the desired number of bytes have been written, or until it returns 0 or -1. <hr><br></blockquote></dl><a name="927744"> </a><h4>See Also </h4><dl><a name="927754"> </a><p></p><dt><code><a href="NetLibrary.html#927575"></code>NetLibSend<code></a></code>, <code><a href="NetLibrary.html#927329"></code>NetLibReceive<code></a></code>, <code><a href="NetLibrary.html#927400"></code>NetLibReceivePB<code></a></code>, <code><a href="NetLibrary.html#925911"></code>NetLibDmReceive<code></a></code> </dl></dl></dl><a name="927759"> </a><br> <br> <br><h3> NetLibSettingGet</h3><dl><dl><a name="927760"> </a><h4>Purpose </h4><dl><a name="927761"> </a><p></p><dt>Retrieves a general setting.</dl><a name="927762"> </a><h4>Prototype </h4><dl><a name="927764"> </a><dt><code>Err NetLibSettingGet (UInt16&nbsp;libRefnum, UInt16&nbsp;setting, void*&nbsp;valueP, UInt16*&nbsp;valueLenP)</code></dl></dl><dl><a name="927765"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927766"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927767"> </a><CODE>-&gt; <code>setting</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Setting to retrieve, one of the <code>NetSettingEnum</code> constants.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927769"> </a><CODE>&lt;- <code>valueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Space for return value of setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927770"> </a><CODE>&lt;-&gt; <code>valueLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>On entry, size of <code>valueP</code>. On exit, actual size of setting.<br></TD></TR></TABLE></dl><dl><a name="927771"> </a><h4>Result </h4><dl><a name="927772"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927773"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927775"> </a><CODE><code>netErrUnknownSetting</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Invalid setting constant<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927777"> </a><CODE><code>netErrPrefNotFound</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>No current value for setting<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927779"> </a><CODE><code>netErrBufTooSmall</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>valueP</code> was too small to hold entire setting. Setting value was truncated to fit in <code>valueP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927781"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE></dl></dl><dl><a name="927782"> </a><h4> Sockets Equivalent</h4><dl><a name="927783"> </a><p></p><dt>None</dl><a name="927784"> </a><h4>Comments </h4><dl><a name="927785"> </a><p></p><dt>This call retrieves the current value of any general setting. The caller must pass a pointer to a buffer to hold the return value (<code>valueP</code>), the size of the buffer (*<code>valueLenP</code>), and the setting ID (<code>setting</code>). The setting ID is one of the <code>NetSettingEnum</code> constants in the <code>netSettingEnum</code> type. <a name="927787"> </a><p></p><dt>Some settings, such as the host table, are variable size. For these types of settings, you can obtain the actual size required for the buffer by passing 0 for <code>*valueLenP</code>. The required size is returned in <code>valueLenP</code>. <a name="927791"> </a><p></p><dt><a href="NetLibrary.html#935306">Table 54.2</a> lists the general settings and the type of each setting.<p><a name="927903"> </a> </p><p><div> <table border="3"><caption><B><a name="935306"> </a><h4>Table 54.2	 Net Library General Settings&nbsp;</h4></B></caption><tr><th><a name="927796"> </a><strong>netSetting...</strong></th><th><a name="927798"> </a><strong>Type</strong></th><th><a name="927800"> </a><strong>Description</strong></th></tr><tr><td><a name="927802"> </a>ResetAll</td><td><a name="927804"> </a>void</td><td><a name="927809"> </a>Used for <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code> only. This will clear all other settings to their default values.</td></tr><tr><td><a name="927811"> </a>PrimaryDNS</td><td><a name="927813"> </a>UInt32</td><td><a name="927815"> </a>IP address of primary DNS server. This setting must be set to a non-zero IP address in order to support any of the name lookup calls. </td></tr><tr><td><a name="927817"> </a>SecondaryDNS</td><td><a name="927819"> </a>UInt32</td><td><a name="927821"> </a>IP address of secondary DNS server. Set to 0 to have stack ignore this setting.</td></tr><tr><td><a name="927823"> </a>DefaultRouter</td><td><a name="927825"> </a>UInt32</td><td><a name="927827"> </a>IP address of default router. Default value is 0 which is appropriate for most implementations with only one attached interface (besides loopback). Packets with destination IP addresses that don't lie in the subnet of an attached interface will be sent to this router through the default interface specified by the <code>netSettingDefaultIFCreator</code>/<code>netSettingDefaultIFInstance</code> pair.</td></tr><tr><td><a name="927829"> </a>DefaultIFCreator</td><td><a name="927831"> </a>UInt32</td><td><a name="927833"> </a>Creator of the default network interface. Default value is 0, which is appropriate for most implementations. Packets with destination IP addresses that don't lie in the subnet of a directly attached interface are sent through this interface. If this setting is 0, the stack automatically makes the first non-loopback interface the default interface. </td></tr><tr><td><a name="927835"> </a>DefaultIFInstance</td><td><a name="927837"> </a>UInt16</td><td><a name="927839"> </a>Instance number of the default network interface. Packets with destination IP addresses that don't lie in the subnet of an attached interface are sent through the default interface. Default value is 0.</td></tr><tr><td><a name="927841"> </a>HostName</td><td><a name="927843"> </a>Char[]</td><td><a name="927845"> </a>A zero-terminated character string of 64 bytes or less containing the host name of this machine. This setting is not actually used by the stack. It's present mainly for informative purposes and to support the <code>gethostname</code>/<code>sethostname</code> sockets API calls. To clear the host name, call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a valueLen of 0.</td></tr><tr><td><a name="927852"> </a>DomainName</td><td><a name="927854"> </a>Char[]</td><td><a name="927856"> </a>A zero-terminated character string of 256 bytes or less containing the default domain. This default domain name is appended to all host names before name lookups are performed. If the name is not found, the host name is looked up again without appending the domain name to it. To have the stack not use the domain name, call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0. </td></tr><tr><td><a name="927861"> </a>HostTbl</td><td><a name="927863"> </a>Char[]</td><td><a name="927865"> </a>A null-terminated character string containing the host table. This table is consulted first before sending a DNS query to the DNS server(s). To have the stack not use a host table, call <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code> with a <code>valueLen</code> of 0. The format of a host table is a series of lines separated by `\n' in the following format:<dl><dl><a name="927869"> </a><br><code>host.company.com A 111.222.333.444</code><br></dl></dl></td></tr><tr><td><a name="927871"> </a>CloseWaitTime</td><td><a name="927873"> </a>UInt32</td><td><a name="927875"> </a>The close-wait time in milliseconds. This setting must be specified. See the discussion of the <code><a href="NetLibrary.html#925462"></code>NetLibClose<code></a></code> call for an explanation of the close-wait time.</td></tr><tr><td><a name="927880"> </a>TraceBits</td><td><a name="927882"> </a>UInt32</td><td><a name="927887"> </a>A bitfield of various trace bits. See "<a href="NetLibrary.html#925277">Tracing Bits</a>." Default value is (<code>netTracingErrors | netTracingAppMsgs</code>). An application can get a list of events in the trace buffer using the <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code> call. </td></tr><tr><td><a name="927892"> </a>TraceSize</td><td><a name="927894"> </a>UInt32</td><td><a name="927896"> </a>Maximum trace buffer size in bytes. Setting this setting always clears the existing trace buffer. Default is 2 KB. </td></tr><tr><td><a name="927898"> </a>TraceRoll</td><td><a name="927900"> </a>UInt8</td><td><a name="927902"> </a>Boolean value, default is <code>true</code> (non-zero). If <code>true</code>, trace buffer will roll over when it fills. If <code>false</code>, tracing will stop as soon as trace buffer fills. </td></tr></table><table><tr><td></table></div></p></dl><a name="927904"> </a><h4>See Also </h4><dl><a name="927911"> </a><p></p><dt><code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code>, <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code>, <code><a href="NetLibrary.html#926396"></code>NetLibIFSettingGet<code></a></code>, <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code> </dl></dl></dl><a name="927919"> </a><br> <br> <br><h3> NetLibSettingSet</h3><dl><dl><a name="927920"> </a><h4>Purpose </h4><dl><a name="927921"> </a><p></p><dt>Sets a general setting.</dl><a name="927922"> </a><h4>Prototype </h4><dl><a name="927924"> </a><dt><code>Err NetLibSettingSet (UInt16&nbsp;libRefnum, UInt16&nbsp;setting, void*&nbsp;valueP, UInt16&nbsp;valueLen)</code></dl></dl><dl><a name="927925"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927926"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927928"> </a><CODE>-&gt; <code>setting</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Setting to set; one of the <code>NetSettingEnum</code> constants. See <a href="NetLibrary.html#935306">Table 54.2</a>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927932"> </a><CODE>-&gt; <code>valueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>New value for the setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927933"> </a><CODE>-&gt; <code>valueLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size of new setting.<br></TD></TR></TABLE></dl><dl><a name="927934"> </a><h4>Result </h4><dl><a name="927935"> </a><p></p><dt>Returns one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927936"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Success.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927938"> </a><CODE><code>netErrUnknownSetting</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Invalid setting constant.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927940"> </a><CODE><code>netErrInvalidSettingSize</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>valueLen</code> was invalid for the given setting.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927942"> </a><CODE><code>netErrBufTooSmall</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>valueP</code> was too small to hold entire setting. Setting value was truncated to fit in <code>valueP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927944"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927946"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE></dl></dl><dl><a name="927947"> </a><h4> Sockets Equivalent</h4><dl><a name="927948"> </a><p></p><dt>None</dl><a name="927949"> </a><h4>Comments </h4><dl><a name="927950"> </a><p></p><dt>This call can be used to set the current value of any general setting. The caller must pass a pointer to a buffer which holds the new value (<code>valueP</code>), the size of the buffer (<code>valueLen</code>), and the setting ID (<code>setting</code>). The setting ID is one of the<code> netSettingXXX</code> constants in the <code>NetSettingEnum</code> type. <a name="927954"> </a><p></p><dt>See <code><a href="NetLibrary.html#927759"></code>NetLibSettingGet<code></a></code> for an explanation of each of the settings. <a name="927955"> </a><p></p><dt>Of particular interest is the <code>netSettingResetAll</code> setting, which, if used, will reset all general settings to their default values. When using this setting, <code>valueP</code> and <code>valueLen</code> are ignored.</dl><a name="927956"> </a><h4>See Also </h4><dl><a name="927963"> </a><p></p><dt><code><a href="NetLibrary.html#927759"></code>NetLibSettingGet<code></a></code>, <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code>, <code><a href="NetLibrary.html#926758"></code>NetLibIFSettingSet<code></a></code>, <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code> </dl></dl></dl><a name="927971"> </a><br> <br> <br><h3> NetLibSocketAccept</h3><dl><dl><a name="927972"> </a><h4>Purpose </h4><dl><a name="927973"> </a><p></p><dt>Accept a connection from a stream-based socket.</dl><a name="927974"> </a><h4>Prototype </h4><dl><a name="927976"> </a><dt><code>Int16 NetLibSocketAccept (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, NetSocketAddrType*&nbsp;sockAddrP, Int16*&nbsp;addrLenP, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="927977"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927978"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927979"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927980"> </a><CODE>&lt;- <code>sockAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Address of remote host is returned here.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927981"> </a><CODE>&lt;-&gt;<code>addrLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>On entry, length of <code>sockAddrP</code> buffer in bytes. On exit, length of returned address stored in *<code>sockAddrP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927982"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927983"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="927984"> </a><h4>Result </h4><dl><a name="927985"> </a><p></p><dt>Returns the <code>NetSocketRef</code> of the new socket. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927986"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927988"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="927990"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="927992"> </a><p></p><dt><code>netErrParamErr</code><a name="927994"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="953893"> </a><p></p><dt><code>netErrSocketNotConnected</code><a name="953865"> </a><p></p><dt><code>netErrSocketClosedByRemote</code><a name="928000"> </a><p></p><dt><code>netErrWrongSocketType</code><a name="928002"> </a><p></p><dt><code>netErrSocketNotListening</code><a name="928004"> </a><p></p><dt><code>netErrUnimplemented</code> </dl></dl></dl><dl><a name="928005"> </a><h4> Sockets Equivalent</h4><dl><a name="928006"> </a><p></p><dt><code>int accept (int socket, void* sockAddrP, int*&nbsp;addrLenP);</code></dl><a name="928007"> </a><h4>Comments </h4><dl><a name="928008"> </a><p></p><dt>Accepts the next connection request from a remote client. This call is only applicable to stream-based sockets. Before calling <code>NetLibSocketAccept</code> on a socket, a server application needs to:<ul type="SQUARE"><a name="928013"> </a><br><li>Open the socket (<code><a href="NetLibrary.html#928319"></code>NetLibSocketOpen<code></a></code>). <br><a name="928017"> </a><br><li>Bind the socket to a local address (<code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>).<br><a name="928018"> </a><br><li>Set the maximum pending connection-request queue length (<code><a href="NetLibrary.html#928246"></code>NetLibSocketListen<code></a></code>). <br></ul><a name="928022"> </a><p></p><dt><code>NetLibSocketAccept</code> will block until a successful connection request is obtained from a remote client. After a successful connection is made, this call returns with the address of the remote host in <code>*sockAddrP</code> and the socket descriptor of a <strong>new</strong> socket as the return value. You then use the new socket to send and receive data. </dl><a name="928023"> </a><h4>See Also </h4><dl><a name="928030"> </a><p></p><dt><code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>, <code><a href="NetLibrary.html#928246"></code>NetLibSocketListen<code></a></code> </dl></dl></dl><a name="928032"> </a><br> <br> <br><h3> NetLibSocketAddr</h3><dl><dl><a name="928033"> </a><h4>Purpose </h4><dl><a name="928034"> </a><p></p><dt>Returns the local and remote addresses currently associated with a socket.</dl><a name="928035"> </a><h4>Prototype </h4><dl><a name="928037"> </a><dt><code>Int16 NetLibSocketAddr (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socketRef, NetSocketAddrType*&nbsp;locAddrP, Int16*&nbsp;locAddrLenP, NetSocketAddrType*&nbsp;remAddrP, Int16*&nbsp;remAddrLenP, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928038"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928039"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928040"> </a><CODE>-&gt; <code>socketRef</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928041"> </a><CODE>&lt;- <code>locAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Local address of socket is returned here.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928042"> </a><CODE>&lt;-&gt;<code>locAddrLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>On entry, length of <code>locAddrP</code> buffer in bytes. On exit, length of returned address stored in *<code>locAddrP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928043"> </a><CODE>&lt;- <code>remAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Address of remote host is returned here.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928044"> </a><CODE>&lt;-&gt;<code>remAddrLenP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>On entry, length of <code>remAddrP</code> buffer in bytes. On exit, length of returned address stored in *<code>remAddrP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928045"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928046"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928047"> </a><h4>Result </h4><dl><a name="928048"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If the return value is -1, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928049"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928051"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928053"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928055"> </a><p></p><dt><code>netErrParamErr</code><a name="928057"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928059"> </a><p></p><dt><code>netErrSocketClosedByRemote</code><a name="928061"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> </dl></dl></dl><dl><a name="928062"> </a><h4> Sockets Equivalent</h4><dl><a name="928063"> </a><p></p><dt><code>int getpeername (int s, struct sockaddr* name, int*&nbsp;namelen);</code><a name="928064"> </a><p></p><dt><code>int getsockname (int s, struct sockaddr* name, int*&nbsp;namelen);</code></dl><a name="928065"> </a><h4>Comments </h4><dl><a name="928066"> </a><p></p><dt>This call is mainly useful for stream-based sockets. It allows the caller to find out what address was bound to a connected socket and the address of the remote host that it's connected to. <a name="928067"> </a><p></p><dt>In Palm OS version 3.0 and higher, if you pass a raw socket to this function, it returns the instance number and creator of the interface to which the socket is bound. </dl><a name="928068"> </a><h4>See Also </h4><dl><a name="928075"> </a><p></p><dt><code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>, <code><a href="NetLibrary.html#928189"></code>NetLibSocketConnect<code></a></code>, <code><a href="NetLibrary.html#927971"></code>NetLibSocketAccept<code></a></code> </dl></dl></dl><a name="928080"> </a><br> <br> <br><h3> NetLibSocketBind</h3><dl><dl><a name="928081"> </a><h4>Purpose </h4><dl><a name="928082"> </a><p></p><dt>Assign a local address to a socket.</dl><a name="928083"> </a><h4>Prototype </h4><dl><a name="946359"> </a><dt><code>Int16 NetLibSocketBind (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, NetSocketAddrType*&nbsp;sockAddrP, Int16&nbsp;addrLen, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928086"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928087"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928088"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928089"> </a><CODE>-&gt; <code>sockAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the address to give to the socket. This can be a <code><a href="NetLibrary.html#925106"></code>NetSocketAddrINType<code></a></code> or a <code><a href="NetLibrary.html#925131"></code>NetSocketAddrRawType<code></a></code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928096"> </a><CODE>-&gt; <code>addrLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length of address in *<code>sockAddrP</code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928097"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928098"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928099"> </a><h4>Result </h4><dl><a name="928100"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928101"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928103"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928105"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928107"> </a><p></p><dt><code>netErrParamErr</code><a name="928109"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928111"> </a><p></p><dt><code>netErrSocketAlreadyConnected </code><a name="928113"> </a><p></p><dt><code>netErrSocketClosedByRemote </code><a name="928115"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> </dl></dl></dl><dl><a name="928116"> </a><h4> Sockets Equivalent</h4><dl><a name="928117"> </a><p></p><dt><code>int bind (int socket, const void* sockAddrP, int&nbsp;addrLen);</code></dl><a name="928118"> </a><h4>Comments </h4><dl><a name="928119"> </a><p></p><dt>Applications that want to wait for an incoming connection request from a remote host must call this function. After calling <code>NetLibSocketBind</code>, applications can call <code><a href="NetLibrary.html#928246"></code>NetLibSocketListen<code></a></code> and then <code><a href="NetLibrary.html#927971"></code>NetLibSocketAccept<code></a></code> to make the socket ready to accept connection requests.</dl><a name="928126"> </a><h4> Compatibility</h4><dl><a name="928127"> </a><p></p><dt>Raw sockets are only supported in Palm OS version 3.0 and higher. See <code><a href="NetLibrary.html#928319"></code>NetLibSocketOpen<code></a></code> for instructions on how to bind raw sockets. </dl><a name="928131"> </a><h4>See Also </h4><dl><a name="928138"> </a><p></p><dt><code><a href="NetLibrary.html#928189"></code>NetLibSocketConnect<code></a></code>, <code><a href="NetLibrary.html#928246"></code>NetLibSocketListen<code></a></code>, <code><a href="NetLibrary.html#927971"></code>NetLibSocketAccept<code></a></code> </dl></dl></dl><a name="928143"> </a><br> <br> <br><h3> NetLibSocketClose</h3><dl><dl><a name="928144"> </a><h4>Purpose </h4><dl><a name="928145"> </a><p></p><dt>Close a socket.</dl><a name="928146"> </a><h4>Prototype </h4><dl><a name="928148"> </a><dt><code>Int16 NetLibSocketClose (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928149"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928150"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928151"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928152"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928153"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928154"> </a><h4>Result </h4><dl><a name="928155"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928156"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928158"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928160"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928162"> </a><p></p><dt><code>netErrParamErr</code><a name="928164"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928166"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> </dl></dl></dl><dl><a name="928167"> </a><h4> Sockets Equivalent</h4><dl><a name="928168"> </a><p></p><dt><code>int close(int socket);</code></dl><a name="928169"> </a><h4>Comments </h4><dl><a name="928170"> </a><p></p><dt>Closes down a socket and frees all memory associated with it. </dl><a name="928180"> </a><h4>See Also </h4><dl><a name="928187"> </a><p></p><dt><code><a href="NetLibrary.html#928319"></code>NetLibSocketOpen<code></a></code>, <code><a href="NetLibrary.html#928827"></code>NetLibSocketShutdown<code></a></code> </dl></dl></dl><a name="928189"> </a><br> <br> <br><h3> NetLibSocketConnect</h3><dl><dl><a name="928190"> </a><h4>Purpose </h4><dl><a name="928191"> </a><p></p><dt>Assign a destination address to a socket and initiate three-way handshake if it's stream based.</dl><a name="928192"> </a><h4>Prototype </h4><dl><a name="928194"> </a><dt><code>Int16 NetLibSocketConnect (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, NetSocketAddrType*&nbsp;sockAddrP, Int16&nbsp;addrLen, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928195"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928196"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928197"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928198"> </a><CODE>-&gt; <code>sockAddrP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to address to connect to.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928199"> </a><CODE>-&gt; <code>addrLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Length of address in *<code>sockAddrP.</code><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928200"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928201"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928202"> </a><h4>Result </h4><dl><a name="928203"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928204"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928206"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928208"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928210"> </a><p></p><dt><code>netErrParamErr</code><a name="928212"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928214"> </a><p></p><dt><code>netErrSocketBusy</code></dl><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928216"> </a><CODE><code>netErrNoInterfaces</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Incorrect setup.<br></TD></TR></TABLE><dl><a name="928218"> </a><p></p><dt><code>netErrPortInUse</code><a name="928220"> </a><p></p><dt><code>netErrQuietTimeNotElapsed</code><a name="928222"> </a><p></p><dt><code>netErrInternal</code><a name="928224"> </a><p></p><dt><code>netErrSocketAlreadyConnected </code><a name="928226"> </a><p></p><dt><code>netErrSocketClosedByRemote</code><a name="928228"> </a><p></p><dt><code>netErrTooManyTCPConnections</code><a name="928230"> </a><p></p><dt><code>netErrWouldBlock</code> <a name="928232"> </a><p></p><dt><code>netErrWrongSocketType</code> <a name="928234"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> </dl></dl></dl><dl><a name="928235"> </a><h4> Sockets Equivalent</h4><dl><a name="928236"> </a><p></p><dt><code>int connect (int socket, const void* sockAddrP, int&nbsp;addrLen);</code></dl><a name="928237"> </a><h4>See Also </h4><dl><a name="928244"> </a><p></p><dt><code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>, <code><a href="NetworkUtils.html#924961"></code>NetUTCPOpen<code></a></code> </dl></dl></dl><a name="928246"> </a><br> <br> <br><h3> NetLibSocketListen</h3><dl><dl><a name="928247"> </a><h4>Purpose </h4><dl><a name="928248"> </a><p></p><dt>Put a stream-based socket into passive listen mode.</dl><a name="928249"> </a><h4>Prototype </h4><dl><a name="928251"> </a><dt><code>Int16 NetLibSocketListen (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, UInt16&nbsp;queueLen, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928252"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928253"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928254"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928255"> </a><CODE>-&gt; <code>queueLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum number of pending connections allowed.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928256"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928257"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928258"> </a><h4>Result </h4><dl><a name="928259"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928260"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928262"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928264"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928266"> </a><p></p><dt><code>netErrParamErr</code><a name="928268"> </a><p></p><dt><code>netErrOutOfResources</code><a name="928270"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928272"> </a><p></p><dt><code>netErrSocketBusy</code></dl><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928274"> </a><CODE><code>netErrNoInterfaces</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Incorrect setup.<br></TD></TR></TABLE><dl><a name="928276"> </a><p></p><dt><code>netErrPortInUse</code><a name="928278"> </a><p></p><dt><code>netErrInternal</code><a name="928280"> </a><p></p><dt><code>netErrSocketAlreadyConnected </code><a name="953922"> </a><p></p><dt><code>netErrSocketClosedByRemote</code><a name="928284"> </a><p></p><dt><code>netErrWrongSocketType</code><a name="928294"> </a><p></p><dt><code>netErrQuietTimeNotElapsed</code> <a name="928296"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> </dl></dl></dl><dl><a name="928297"> </a><h4> Sockets Equivalent</h4><dl><a name="928298"> </a><p></p><dt><code>int listen (int socket, int queueLen);</code></dl><a name="928299"> </a><h4>Comments </h4><dl><a name="928300"> </a><p></p><dt>Sets the maximum allowable length of the queue for pending connections. This call is only applicable to stream-based (TCP/IP) sockets. <a name="928301"> </a><p></p><dt>After a socket is created and bound to a local address using <code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>, a server application can call <code>NetLibSocketListen</code> and then <code><a href="NetLibrary.html#927971"></code>NetLibSocketAccept<code></a></code> to accept connections from remote clients. <a name="928309"> </a><p></p><dt>The <code>queueLen</code> is currently quietly limited to 1 (higher values are ignored).</dl><a name="928310"> </a><h4>See Also </h4><dl><a name="928317"> </a><p></p><dt><code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>, <code><a href="NetLibrary.html#927971"></code>NetLibSocketAccept<code></a></code> </dl></dl></dl><a name="928319"> </a><br> <br> <br><h3> NetLibSocketOpen</h3><dl><dl><a name="928320"> </a><h4>Purpose </h4><dl><a name="928321"> </a><p></p><dt>Open a new socket.</dl><a name="928322"> </a><h4>Prototype </h4><dl><a name="928325"> </a><dt><code>NetSocketRef NetLibSocketOpen (UInt16&nbsp;libRefnum, NetSocketAddrEnum&nbsp;domain, NetSocketTypeEnum&nbsp;type, Int16&nbsp;protocol, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928326"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928327"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928331"> </a><CODE>-&gt; <code>domain</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Address domain. See <code><a href="NetLibrary.html#925087"></code>NetSocketAddrEnum<code></a></code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928332"> </a><CODE>-&gt; <code>type</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Desired type of connection. See <code><a href="NetLibrary.html#925173"></code>NetSocketTypeEnum<code></a></code>.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928336"> </a><CODE>-&gt; <code>protocol</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Protocol to use. This parameter is currently ignored. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928337"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>For raw sockets in the <code>netSocketAddrINET</code> domain, specify one of the following:<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=35% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=25% VALIGN=TOP ALIGN=LEFT><a name="928339"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=35% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=25% VALIGN=TOP ALIGN=LEFT><a name="928341"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=35% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=25% VALIGN=TOP ALIGN=LEFT><a name="928343"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928344"> </a><CODE></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>For all other socket types or for raw sockets in the raw domain, this parameter is ignored. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928345"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928346"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928347"> </a><h4>Result </h4><dl><a name="928348"> </a><p></p><dt>Returns the <code>NetSocketRef</code> of the opened socket or -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928349"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928351"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928353"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928355"> </a><p></p><dt><code>netErrParamErr</code><a name="928357"> </a><p></p><dt><code>netErrNoMoreSockets</code><a name="928359"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> <a name="928361"> </a><p></p><dt><code>netErrOutOfMemory</code> </dl></dl></dl><dl><a name="928362"> </a><h4> Sockets Equivalent</h4><dl><a name="928363"> </a><p></p><dt><code>int socket(int domain, int type, int protocol);</code></dl><a name="928364"> </a><h4>Comments </h4><dl><a name="928365"> </a><p></p><dt>Allocates memory for a new socket and opens it. <a name="928366"> </a><p></p><dt>Raw sockets are supported in Palm OS version 3.0 and higher. Two types of raw sockets are supported:<ul type="SQUARE"><a name="928368"> </a><br><li>Raw sockets in the <code>netSocketAddrINET</code> domain<br><dl><a name="928369"> </a><p></p><dt>In this case, you must bind the socket to an IP address using <code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>, passing a <code><a href="NetLibrary.html#925106"></code>NetSocketAddrINType<code></a></code> structure for the socket address. The port field is ignored.<a name="928376"> </a><p></p><dt>For applications that use raw sockets in the INET domain, the net library checks the destination IP address of all incoming packets to see if it matches any of those raw sockets. If it does, the packet is enqueued directly into the matching socket and is <strong>not</strong> passed to the protocol stack. <a name="928377"> </a><p></p><dt>When an application sends data through raw sockets in the IP domain, the net library packages the data into a packet and passes it directly to the interface's send routine. You are responsible for forming the entire IP header, including any necessary checksums, source and destination IP address, and so on. </dl><a name="928379"> </a><br><li>Raw sockets in the <code>netSocketAddrRaw</code> domain with no protocol<br><dl><a name="928380"> </a><p></p><dt>In this case, you must bind the socket to an interface using <code><a href="NetLibrary.html#928080"></code>NetLibSocketBind<code></a></code>, passing a <code><a href="NetLibrary.html#925131"></code>NetSocketAddrRawType<code></a></code> structure for the socket address. The instance and creator specify which interface the caller wants to receive raw packets from. <a name="928387"> </a><p></p><dt>When an interface is bound to a raw socket with no protocol, the net library places that interface into raw mode. In raw mode, the interface passes all incoming packets, no matter what the link layer protocol, to its raw receive function. <a name="928388"> </a><p></p><dt>When an application sends data through a raw socket with no protocol, the net library packages the data into a packet and passes it directly to the interface's send routine. <a name="928389"> </a><p></p><dt>The interface remains in raw mode until the raw socket is closed.</dl></ul></dl><a name="928398"> </a><h4> Compatibility</h4><dl><a name="928399"> </a><p></p><dt>Raw sockets supported only in Palm OS version 3.0 and higher.</dl><a name="928400"> </a><h4>See Also </h4><dl><a name="928407"> </a><p></p><dt><code><a href="NetLibrary.html#928143"></code>NetLibSocketClose<code></a></code>, <code><a href="NetworkUtils.html#924961"></code>NetUTCPOpen<code></a></code> </dl></dl></dl><a name="928409"> </a><br> <br> <br><h3> NetLibSocketOptionGet </h3><dl><dl><a name="928410"> </a><h4>Purpose </h4><dl><a name="928411"> </a><p></p><dt>Retrieves the current value of a socket option.</dl><a name="928412"> </a><h4>Prototype </h4><dl><a name="928414"> </a><dt><code>Int16 NetLibSocketOptionGet (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, UInt16&nbsp;level, UInt16&nbsp;option, void*&nbsp;optValueP, UInt16&nbsp;*&nbsp;optValueLenP, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928415"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928416"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928417"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928418"> </a><CODE>-&gt; <code>level</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Level of the option, one of the <code>NetSocketOptLevelEnum</code> constants. See <code><a href="NetLibrary.html#928465"></code>NetLibSocketOptionSet<code></a></code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928424"> </a><CODE>-&gt; <code>option</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One of the <code>NetSocketOptEnum</code> constants. See <code><a href="NetLibrary.html#928465"></code>NetLibSocketOptionSet<code></a></code>. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928428"> </a><CODE>&lt;- <code>optValueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to variable holding new value of option.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928429"> </a><CODE>&lt;-&gt; <code>optValueLenP</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>Size of variable pointed to by <code>optValueP</code> on entry. Actual size of return value on exit. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928430"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928431"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928432"> </a><h4>Result </h4><dl><a name="928433"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928434"> </a><CODE>0<code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT></code>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928436"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928438"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928440"> </a><p></p><dt><code>netErrParamErr</code><a name="928442"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928444"> </a><p></p><dt><code>netErrUnimplemented</code><a name="928446"> </a><p></p><dt><code>netErrWrongSocketType</code><a name="928448"> </a><p></p><dt><code>netErrInvalidSettingSize</code> </dl></dl></dl><dl><a name="928449"> </a><h4> Sockets Equivalent</h4><dl><a name="928450"> </a><p></p><dt><code>int getsockopt (int socket, int level, int option, const void* optValueP, int* optValueLenP);</code></dl><a name="928451"> </a><h4>Comments </h4><dl><a name="928452"> </a><p></p><dt>Returns the current value of a socket option. The caller passes a pointer to a variable to hold the returned value (in <code>optValueP</code>) and the size of this variable (in <code>*optValueLenP</code>). On exit, <code>*optValueP</code> is updated with the actual size of the return value. <a name="928453"> </a><p></p><dt>For all of the fixed size options (every option except <code>netSocketOptIPOptions</code>), <code>*optValueLenP</code> is unmodified on exit and this call does its best to return the value in the caller's desired type size. <a name="928454"> </a><p></p><dt>For compatibility with existing Internet applications, this call is quite flexible on the <code>*optValueLenP</code> parameter. If the desired type for an option is <code>FLAG</code>, this call supports an <code>*optValueLenP</code> of 1, 2, or 4. If the desired type for an option is <code>int</code>, it supports an <code>*optValueLenP</code> of 2 or 4. <a name="928458"> </a><p></p><dt>See <code><a href="NetLibrary.html#928465"></code>NetLibSocketOptionSet<code></a></code> for a list of available options. </dl><a name="928459"> </a><h4>See Also </h4><dl><a name="928463"> </a><p></p><dt><code><a href="NetLibrary.html#928465"></code>NetLibSocketOptionSet<code></a></code> </dl></dl></dl><a name="928465"> </a><br> <br> <br><h3> NetLibSocketOptionSet </h3><dl><dl><a name="928466"> </a><h4>Purpose </h4><dl><a name="928467"> </a><p></p><dt>Set a socket option.</dl><a name="928468"> </a><h4>Prototype </h4><dl><a name="928470"> </a><dt><code>Int16 NetLibSocketOptionSet (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, UInt16&nbsp;level, UInt16&nbsp;option, void*&nbsp;optValueP, UInt16&nbsp;optValueLen, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928471"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928472"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928473"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928474"> </a><CODE>-&gt; <code>level</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Level of the option, one of the <code>NetSocketOptLevelEnum</code> constants. See the comments section. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928477"> </a><CODE>-&gt; <code>option</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>One of the <code>NetSocketOptEnum</code> constants. See the comments section. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928478"> </a><CODE>-&gt; <code>optValueP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Pointer to the variable holding the new value of the option.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928479"> </a><CODE>-&gt; <code>optValueLen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Size of variable pointed to by <code>optValueP.</code><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928480"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928481"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928482"> </a><h4>Result </h4><dl><a name="928483"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928484"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928486"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928488"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928490"> </a><p></p><dt><code>netErrParamErr</code><a name="928492"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928494"> </a><p></p><dt><code>netErrUnimplemented</code><a name="928496"> </a><p></p><dt><code>netErrWrongSocketType</code><a name="928498"> </a><p></p><dt><code>netErrInvalidSettingSize</code> </dl></dl></dl><dl><a name="928499"> </a><h4> Sockets Equivalent</h4><dl><a name="928500"> </a><p></p><dt><code>int setsockopt (int socketRef, int level, int&nbsp;option, const void* optValueP, int&nbsp;optValueLen);</code></dl><a name="928501"> </a><h4>Comments </h4><dl><a name="928502"> </a><p></p><dt>Sets various options associated with a socket. The caller passes a pointer to the new option value in <code>optValueP</code> and the size of the option in <code>optValueLen</code>. <a name="928506"> </a><p></p><dt><a href="NetLibrary.html#935885">Table 54.3</a> lists the available options. <ul type="SQUARE"><a name="928507"> </a><br><li>The Level column specifies the option level, which is one of the <code>netSocketOptLevelXXX</code> constants. <br><a name="928508"> </a><br><li>The Option column lists the option, which is one of the <code>netSocketOptXXX</code> constants. <br><a name="928509"> </a><br><li>The G/S column lists whether this option can be fetched with the <code><a href="NetLibrary.html#928409"></code>NetLibSocketOptionGet<code></a></code> call (G) and/or set (S) with this call. <br><a name="928513"> </a><br><li>The type column lists the data type of the option. <br><a name="928514"> </a><br><li>The I column specifies whether or not this option is currently implemented.<br><p><a name="928817"> </a> </p><p><div> <table border="3"><caption><B><a name="935885"> </a><h4>Table 54.3	 Net Library Socket Options&nbsp;</h4></B></caption><tr><th><a name="928520"> </a><strong>netSocket<br>OptLevel... </strong></th><th><a name="928522"> </a><strong><br>netSocketOpt...</strong></th><th><a name="928524"> </a><strong><br>G/S</strong></th><th><a name="928526"> </a><strong><br>Type </strong></th><th><a name="928528"> </a><strong><br>I</strong></th><th><a name="928530"> </a><strong><br>Description</strong></th></tr><tr><td><a name="928532"> </a>IP</td><td><a name="928534"> </a>IPOptions </td><td><a name="928536"> </a>GS</td><td><a name="928538"> </a>UInt8[]</td><td><a name="928540"> </a>N</td><td><a name="928542"> </a>Options in IP Header</td></tr><tr><td><a name="928544"> </a>TCP</td><td><a name="928546"> </a>TCPNoDelay</td><td><a name="928548"> </a>GS</td><td><a name="928550"> </a>FLAG</td><td><a name="928552"> </a>Y</td><td><a name="928554"> </a>Don't delay send to coalesce packets</td></tr><tr><td><a name="928556"> </a>TCP</td><td><a name="928558"> </a>TCPMaxSeg</td><td><a name="928560"> </a>G</td><td><a name="928562"> </a>int</td><td><a name="928564"> </a>Y</td><td><a name="928566"> </a>Get TCP maximum segment size</td></tr><tr><td><a name="928568"> </a>Socket</td><td><a name="928570"> </a>SockDebug</td><td><a name="928572"> </a>GS</td><td><a name="928574"> </a>FLAG</td><td><a name="928576"> </a>N</td><td><a name="928578"> </a>Turn on recording of debug info</td></tr><tr><td><a name="928580"> </a>Socket</td><td><a name="928582"> </a>SockAcceptConn</td><td><a name="928584"> </a>G</td><td><a name="928586"> </a>FLAG</td><td><a name="928588"> </a>N</td><td><a name="928590"> </a>Socket has had listen</td></tr><tr><td><a name="928592"> </a>Socket</td><td><a name="928594"> </a>SockReuseAddr</td><td><a name="928596"> </a>GS</td><td><a name="928598"> </a>FLAG</td><td><a name="928600"> </a>N</td><td><a name="928602"> </a>Allow local address reuse</td></tr><tr><td><a name="928604"> </a>Socket</td><td><a name="928606"> </a>SockKeepAlive</td><td><a name="928608"> </a>GS</td><td><a name="928610"> </a>FLAG</td><td><a name="928612"> </a>Y</td><td><a name="928614"> </a>Keep connections alive</td></tr><tr><td><a name="928616"> </a>Socket</td><td><a name="928618"> </a>SockDontRoute</td><td><a name="928620"> </a>GS</td><td><a name="928622"> </a>FLAG</td><td><a name="928624"> </a>N</td><td><a name="928626"> </a>Just use interface addresses</td></tr><tr><td><a name="928628"> </a>Socket</td><td><a name="928630"> </a>SockBroadcast</td><td><a name="928632"> </a>GS</td><td><a name="928634"> </a>FLAG</td><td><a name="928636"> </a>N</td><td><a name="928638"> </a>Permit sending of broadcast messages</td></tr><tr><td><a name="928640"> </a>Socket</td><td><a name="928642"> </a>SockUseLoopback</td><td><a name="928644"> </a>GS</td><td><a name="928646"> </a>FLAG</td><td><a name="928648"> </a>N</td><td><a name="928650"> </a>Bypass hardware when possible</td></tr><tr><td><a name="928652"> </a>Socket</td><td><a name="928654"> </a>SockLinger</td><td><a name="928656"> </a>GS</td><td><a name="928658"> </a>NetSocket<br>LingerType </td><td><a name="928660"> </a>Y</td><td><a name="928662"> </a>Linger on close if data present<a name="928664"> </a><code>NetSocketLingerType</code> is a structure with two fields: <code>onOff</code> (<code>true</code> or <code>false</code>) and <code>time</code> (linger time in seconds).</td></tr><tr><td><a name="928666"> </a>Socket</td><td><a name="928668"> </a>SockOOBInLine</td><td><a name="928670"> </a>GS</td><td><a name="928672"> </a>FLAG</td><td><a name="928674"> </a>N</td><td><a name="928676"> </a>Leave received OOB data in-line</td></tr><tr><td><a name="928678"> </a>Socket</td><td><a name="928680"> </a>SockSndBufSize</td><td><a name="928682"> </a>GS</td><td><a name="928684"> </a>int</td><td><a name="928686"> </a>N</td><td><a name="928688"> </a>Send buffer size</td></tr><tr><td><a name="928690"> </a>Socket</td><td><a name="928692"> </a>SockRcvBufSize</td><td><a name="928694"> </a>GS</td><td><a name="928696"> </a>int</td><td><a name="928698"> </a>N</td><td><a name="928700"> </a>Receive buffer size</td></tr><tr><td><a name="928702"> </a>Socket</td><td><a name="928704"> </a>SockSndLowWater </td><td><a name="928706"> </a>GS</td><td><a name="928708"> </a>int</td><td><a name="928710"> </a>N</td><td><a name="928712"> </a>Send low-water mark</td></tr><tr><td><a name="928714"> </a>Socket</td><td><a name="928716"> </a>SockRcvLowWater </td><td><a name="928718"> </a>GS</td><td><a name="928720"> </a>int</td><td><a name="928722"> </a>N</td><td><a name="928724"> </a>Receive low-water mark</td></tr><tr><td><a name="928726"> </a>Socket</td><td><a name="928728"> </a>SockSndTimeout</td><td><a name="928730"> </a>GS</td><td><a name="928732"> </a>int</td><td><a name="928734"> </a>N</td><td><a name="928736"> </a>Send timeout</td></tr><tr><td><a name="928738"> </a>Socket</td><td><a name="928740"> </a>SockRcvTimeout</td><td><a name="928742"> </a>GS</td><td><a name="928744"> </a>int</td><td><a name="928746"> </a>N</td><td><a name="928748"> </a>Receive timeout</td></tr><tr><td><a name="928750"> </a>Socket</td><td><a name="928752"> </a>SockErrorStatus</td><td><a name="928754"> </a>G</td><td><a name="928756"> </a>int</td><td><a name="928758"> </a>Y</td><td><a name="928760"> </a>Get error status and clear</td></tr><tr><td><a name="928762"> </a>Socket</td><td><a name="928764"> </a>SockSocketType</td><td><a name="928766"> </a>G</td><td><a name="928768"> </a>int</td><td><a name="928770"> </a>Y</td><td><a name="928772"> </a>Get socket type</td></tr><tr><td><a name="928774"> </a>Socket</td><td><a name="928776"> </a>SockNonBlocking</td><td><a name="928778"> </a>GS</td><td><a name="928780"> </a>FLAG</td><td><a name="928782"> </a>Y</td><td><a name="928784"> </a>Set non-blocking mode on/off</td></tr></table><table><tr><td></table></div></p></ul><a name="928818"> </a><p></p><dt>For compatibility with existing Internet applications, this call is quite flexible on the <code>optValueLen</code> parameter. If the desired type for an option is <code>FLAG</code>, this call accepts an <code>optValueLen</code> of 1, 2, or 4. If the desired type for an option is <code>int</code>, it accepts an <code>optValueLen</code> of 2 or 4. <a name="928819"> </a><p></p><dt>Except for the <code>netSocketOptSockNonBlocking</code> option, all options listed above have equivalents in the sockets API. The <code>netSocketOptSockNonBlocking</code> option was added to this call in the net library in order to implement the functionality of the UNIX <code>fcntl()</code> control call, which can be used to turn nonblocking mode on and off for sockets. </dl><a name="928821"> </a><h4>See Also </h4><dl><a name="928825"> </a><p></p><dt><code><a href="NetLibrary.html#928409"></code>NetLibSocketOptionGet<code></a></code> </dl></dl></dl><a name="928827"> </a><br> <br> <br><h3> NetLibSocketShutdown</h3><dl><dl><a name="928828"> </a><h4>Purpose </h4><dl><a name="928829"> </a><p></p><dt>Shut down a socket in one or both directions.</dl><a name="928830"> </a><h4>Prototype </h4><dl><a name="928832"> </a><dt><code>Int16 NetLibSocketShutdown (UInt16&nbsp;libRefnum, NetSocketRef&nbsp;socket, Int16&nbsp;direction, Int32&nbsp;timeout, Err*&nbsp;errP)</code></dl></dl><dl><a name="928833"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928834"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928835"> </a><CODE>-&gt; <code>socket</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Descriptor for the open socket.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928836"> </a><CODE>-&gt; <code>direction</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Direction to shut down. One of the <code>NetSocketDirEnum</code> constants. Specifically:<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928839"> </a><CODE><code>netSocketDirInputnetSocketDirOutput</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT><code>netSocketDirInputnetSocketDirOutputnetSocketDirBoth</code><br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928842"> </a><CODE>-&gt; <code>timeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Maximum timeout in system ticks; -1 means wait forever. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928843"> </a><CODE>&lt;- <code>errP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Contains an error code if the return value is -1.<br></TD></TR></TABLE></dl><dl><a name="928844"> </a><h4>Result </h4><dl><a name="928845"> </a><p></p><dt>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:<TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928846"> </a><CODE>0</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>No error.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928848"> </a><CODE><code>netErrTimeout</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Call timed out. <br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928850"> </a><CODE><code>netErrNotOpen</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>The referenced net library has not been opened yet. <br></TD></TR></TABLE><dl><a name="928852"> </a><p></p><dt><code>netErrParamErr</code><a name="928854"> </a><p></p><dt><code>netErrSocketNotOpen</code><a name="928856"> </a><p></p><dt><code>netErrNoMultiPktAddr</code> <a name="928858"> </a><p></p><dt><code>netErrOutOfCmdBlocks</code> </dl></dl></dl><dl><a name="928859"> </a><h4> Sockets Equivalent</h4><dl><a name="928860"> </a><p></p><dt><code>int shutdown (int socket, int direction);</code></dl><a name="928861"> </a><h4>Comments </h4><dl><a name="928862"> </a><p></p><dt>Shuts down communication in one or both directions on a socket. <a name="928863"> </a><p></p><dt>If direction is <code>netSocketDirInput</code>, the socket is marked as down in the receive direction and further read operations from it return a <code>netErrSocketInputShutdown</code> error. </dl></dl></dl><a name="928866"> </a><br> <br> <br><h3> NetLibTracePrintF</h3><dl><dl><a name="928867"> </a><h4>Purpose </h4><dl><a name="928868"> </a><p></p><dt>Store debugging information in the net library's trace buffer. </dl><a name="928869"> </a><h4>Prototype </h4><dl><a name="928871"> </a><dt><code>Err NetLibTracePrintF (UInt16&nbsp;libRefnum, Char&nbsp;*formatStr, ...)</code></dl></dl><dl><a name="928872"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928873"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928874"> </a><CODE>-&gt; <code>formatStr</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>A <code>printf</code> style format string.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928875"> </a><CODE>-&gt; ...</CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Arguments to the format string.<br></TD></TR></TABLE></dl><dl><a name="928876"> </a><h4>Result </h4><dl><a name="928878"> </a><p></p><dt>Returns 0 upon success or <code>netErrNotOpen</code> if the net library has not been opened. </dl></dl><dl><a name="928879"> </a><h4> Sockets Equivalent</h4><dl><a name="928880"> </a><p></p><dt>None</dl><a name="928881"> </a><h4>Comments </h4><dl><a name="928882"> </a><p></p><dt>This call is a convenient debugging tool for developing Internet applications. It stores a message into the net library's trace buffer, which can later be dumped using the <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code> call. The net library's trace buffer is used to store run-time errors that the net library encounters as well as errors and messages from network interfaces and from applications that use this call. <a name="928886"> </a><p></p><dt>The <code>formatStr</code> parameter is a <code>printf</code> style format string which supports the following format specifiers:<a name="928887"> </a><p></p><dt>%d, %i, %u, %x, %s, %c <a name="928888"> </a><p></p><dt>but it does <strong>not</strong> support field widths, leading 0's etc. <a name="928889"> </a><p></p><dt>Note that the <code>netTracingAppMsgs</code> bit of the <code>netSettingTraceBits</code> setting must be set using the call <code>NetLibSettingSet(...netSettingTraceBits...)</code>. Otherwise, this routine will do nothing. </dl><a name="928890"> </a><h4>See Also </h4><dl><a name="928900"> </a><p></p><dt><code><a href="NetLibrary.html#928902"></code>NetLibTracePutS<code></a></code>, <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code>, <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code> </dl></dl></dl><a name="928902"> </a><br> <br> <br><h3> NetLibTracePutS</h3><dl><dl><a name="928903"> </a><h4>Purpose </h4><dl><a name="928904"> </a><p></p><dt>Store debugging information in the net library's trace buffer. </dl><a name="928905"> </a><h4>Prototype </h4><dl><a name="928907"> </a><dt><code>Err NetLibTracePutS (UInt16&nbsp;libRefnum, Char&nbsp;*strP)</code></dl></dl><dl><a name="928908"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928909"> </a><CODE>-&gt; <code>libRefNum</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>Reference number of the net library.<br></TD></TR></TABLE><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928910"> </a><CODE>-&gt; <code>strP</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>String to store in the trace buffer.<br></TD></TR></TABLE></dl><dl><a name="928911"> </a><h4>Result </h4><dl><a name="928913"> </a><p></p><dt>Returns 0 upon success or <code>netErrNotOpen</code> if the net library has not been opened. </dl></dl><dl><a name="928914"> </a><h4> Sockets Equivalent</h4><dl><a name="928915"> </a><p></p><dt>None</dl><a name="928916"> </a><h4>Comments </h4><dl><a name="928917"> </a><p></p><dt>This call is a convenient debugging tool for developing Internet applications. It will store a message into the net library's trace buffer which can later be dumped using the <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code> call. The net library's trace buffer is used to store run-time errors that the net library encounters as well as errors and messages from network interfaces and from applications that use this call. <a name="928921"> </a><p></p><dt>Note the <code>netTracingAppMsgs</code> bit of the <code>netSettingTraceBits</code> setting must be set using the <code>NetLibSettingSet(...netSettingTraceBits...)</code> call or this routine will do nothing. </dl><a name="928922"> </a><h4>See Also </h4><dl><a name="928932"> </a><p></p><dt><code><a href="NetLibrary.html#928866"></code>NetLibTracePrintF<code></a></code>, <code><a href="NetLibrary.html#926869"></code>NetLibMaster<code></a></code>, <code><a href="NetLibrary.html#927919"></code>NetLibSettingSet<code></a></code>.</dl></dl></dl><a name="928934"> </a><br> <br> <br><h3> NetNToHL</h3><dl><dl><a name="928935"> </a><h4>Purpose </h4><dl><a name="928936"> </a><p></p><dt>Macro that converts a 32-bit value from network to host byte order.</dl><a name="928937"> </a><h4>Prototype </h4><dl><a name="928939"> </a><dt><code>NetNToHL (x)</code></dl></dl><dl><a name="928940"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928941"> </a><CODE>-&gt; <code>x</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>32-bit value to convert.<br></TD></TR></TABLE></dl><dl><a name="928942"> </a><h4>Result </h4><dl><a name="928943"> </a><p></p><dt>Returns <code>x</code> in host byte order.</dl></dl><dl><a name="928944"> </a><h4> Errors</h4><dl><a name="928945"> </a><p></p><dt>none</dl><a name="928946"> </a><h4> Sockets Equivalent</h4><dl><a name="928947"> </a><p></p><dt><code>ntohl()</code></dl><a name="928948"> </a><h4>See Also </h4><dl><a name="928958"> </a><p></p><dt><code><a href="NetLibrary.html#928960"></code>NetNToHS<code></a></code>, <code><a href="NetLibrary.html#925372"></code>NetHToNL<code></a></code>, <code><a href="NetLibrary.html#925397"></code>NetHToNS<code></a></code> </dl></dl></dl><a name="928960"> </a><br> <br> <br><h3> NetNToHS</h3><dl><dl><a name="928961"> </a><h4>Purpose </h4><dl><a name="928962"> </a><p></p><dt>Macro that converts a 16-bit value from network to host byte order.</dl><a name="928963"> </a><h4>Prototype </h4><dl><a name="928965"> </a><dt><code>NetNToHS (x)</code></dl></dl><dl><a name="928966"> </a><h4>Parameters </h4><TABLE WIDTH=95%><TR><TD WIDTH=5% VALIGN=TOP ALIGN=RIGHT>&nbsp</TD><TD WIDTH=30% VALIGN=TOP ALIGN=LEFT><a name="928967"> </a><CODE>-&gt; <code>x</code></CODE><br></TD><TD WIDTH=* VALIGN=TOP ALIGN=LEFT>16-bit value to convert.<br></TD></TR></TABLE></dl><dl><a name="928968"> </a><h4>Result </h4><dl><a name="928969"> </a><p></p><dt>Returns <code>x</code> in host byte order.</dl></dl><dl><a name="928970"> </a><h4> Errors</h4><dl><a name="928971"> </a><p></p><dt>None</dl><a name="928972"> </a><h4> Sockets Equivalent</h4><dl><a name="928973"> </a><p></p><dt><code>ntohs()</code></dl><a name="928974"> </a><h4>See Also </h4><dl><a name="928984"> </a><p></p><dt><code><a href="NetLibrary.html#925372"></code>NetHToNL<code></a></code>, <code><a href="NetLibrary.html#928934"></code>NetNToHL<code></a></code>, <code><a href="NetLibrary.html#925397"></code>NetHToNS<code></a></code><dl><a name="929001"> </a><p></p><dt><strong></strong></dl></dl></dl></dl><hr><br><center><B>Palm OS SDK Reference</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="ModemManager.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="ReferenceTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="ReferenceIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="NetworkUtils.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 56 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:28:59 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/NetLibrary.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:02 GMT -->
</html>