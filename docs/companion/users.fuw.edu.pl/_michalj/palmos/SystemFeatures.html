<html>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SystemFeatures.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:13 GMT -->
<head><title>Palm System Features</title></head><body bgcolor="#ffffff"><TABLE WIDTH="100%">  <TR>    <TD WIDTH=25%><a href="FilesAndDatabases.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=25%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=25%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=25%><a href="SerialCommunication.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>  </TR></TABLE><br><center><B>Palm OS Programmer's Companion</B></center><hr><br><a name="924905"> </a><h1><IMG SRC="images/PCPplain.gif" ALT="Palm Logo" WIDTH="45" HEIGHT="44"> <a name="924903"> </a>8 Palm System Features</h1><dl><a name="924906"> </a><p></p><dt>In this chapter, you learn how to work with the features that the Palm OS<sup>&#174;</sup> system provides, such as sound, alarms, and floating-point operations. Most parts of the Palm OS are controlled by a manager, which is a group of functions that work together to implement a certain functionality. As a rule, all functions that belong to one manager use the same prefix and work together to implement a certain aspect of functionality. <a name="924908"> </a><p></p><dt>This chapter discusses these topics: <ul type="SQUARE"><a name="924912"> </a><br><li><a href="SystemFeatures.html#924958">Alarms</a> <br><a name="924916"> </a><br><li><a href="SystemFeatures.html#925109">Features</a> <br><a name="927534"> </a><br><li><a href="SystemFeatures.html#927535">Notifications</a><br><a name="924924"> </a><br><li><a href="SystemFeatures.html#925262">Sound</a> <br><a name="924928"> </a><br><li><a href="SystemFeatures.html#925607">System Boot and Reset</a> <br><a name="924932"> </a><br><li><a href="SystemFeatures.html#925641">Hardware Interaction</a><br><a name="924936"> </a><br><li><a href="SystemFeatures.html#925705">The Microkernel</a><br><a name="924944"> </a><br><li><a href="SystemFeatures.html#925728">Retrieving the ROM Serial Number</a> <br><a name="924948"> </a><br><li><a href="SystemFeatures.html#925774">Time</a> <br><a name="924952"> </a><br><li><a href="SystemFeatures.html#925845">Floating-Point</a> <br><a name="924956"> </a><br><li><a href="SystemFeatures.html#925865">Summary of System Features</a><br></ul></dl><a name="924958"> </a><h2> Alarms</h2><dl><a name="924960"> </a><p></p><dt>The Palm OS alarm manager provides support for setting real-time alarms, for performing some periodic activity, or for displaying a reminder. The alarm manager:<ul type="SQUARE"><a name="924961"> </a><br><li>Works closely with the time manager to handle real-time alarms.<br><a name="924962"> </a><br><li>Sends launch codes to applications that set a specific time alarm to inform the application the alarm is due.<br><a name="924963"> </a><br><li>Handles alarms by application in a two cycle operation<br><p></p><ul type="CIRCLE"><a name="924964"> </a><li>First, it notifies each application that the alarm has occurred.<a name="924965"> </a><li>Second, it allows each application to display some UI.</ul><a name="924966"> </a><br><li>Allows only one alarm to be set per application.<br></ul><a name="924967"> </a><p></p><dt>However, the alarm manager:<ul type="SQUARE"><a name="924969"> </a><br><li>Doesn't provide reminder dialog boxes.<br><a name="924971"> </a><br><li>Doesn't play the alarm sound.<br></ul><a name="924972"> </a><p></p><dt>This section looks in some detail at how the alarm manager and applications interact when processing an alarm. It covers:<ul type="SQUARE"><a name="924976"> </a><br><li><a href="SystemFeatures.html#924986">Setting an Alarm</a><br><a name="924980"> </a><br><li><a href="SystemFeatures.html#925045">Alarm Scenario</a><br><a name="924984"> </a><br><li><a href="SystemFeatures.html#925078">Setting a Procedure Alarm</a><br></ul></dl><a name="924986"> </a><h3> Setting an Alarm</h3><dl><a name="924987"> </a><p></p><dt>The most common use of the alarm manager is to set a real-time alarm within an application. Often, you set this type of alarm because you want to inform the user of an event. For example, the Datebook application sets alarms to inform users of their appointments. <a name="924988"> </a><p></p><dt>Implementing such an alarm is a two step process. First, use the function <code><a href="AlarmManager.html#924970"></code>AlmSetAlarm<code></a></code> to set the alarm. Specify when the alarm should trigger and which application should be informed at that time. <a name="924996"> </a><p></p><dt><a href="SystemFeatures.html#924998">Listing 8.1</a> shows how the Datebook application sets an alarm. </dl><a name="924998"> </a><h4>Listing 8.1	 Setting an alarm</h4><a name="924999"> </a><hr><code>static void SetTimeOfNextAlarm (UInt32 alarmTime, UInt32 ref)</code><br><a name="925000"> </a><code>{</code><br><a name="925001"> </a><code>&nbsp&nbsp&nbsp UInt16 cardNo;</code><br><a name="925002"> </a><code>&nbsp&nbsp&nbsp LocalID dbID;</code><br><a name="925003"> </a><code>&nbsp&nbsp&nbsp DmSearchStateType searchInfo;</code><br><a name="925004"> </a><code></code><br><a name="925005"> </a><code>&nbsp&nbsp&nbsp DmGetNextDatabaseByTypeCreator (true, &amp;searchInfo, </code><br><a name="925006"> </a><code>&nbsp&nbsp&nbsp 	 sysFileTApplication, sysFileCDatebook, true, &amp;cardNo, &amp;dbID);</code><br><a name="925007"> </a><code></code><br><a name="925008"> </a><code>&nbsp&nbsp&nbsp AlmSetAlarm (cardNo, dbID, ref, alarmTime, true);</code><br><a name="925009"> </a><code>}</code><br><hr><br><dl><a name="925010"> </a><p></p><dt>Second, have your <code>PilotMain</code> function respond to the launch codes <code><a href="AppLaunchCodes.html#925171"></code>sysAppLaunchCmdAlarmTriggered<code></a></code> and <code><a href="AppLaunchCodes.html#925209"></code>sysAppLaunchCmdDisplayAlarm<code></a></code>. <a name="925019"> </a><p></p><dt>When an alarm is triggered, the alarm manager notifies each application that set an alarm for that time via the <code>sysAppLaunchCmdAlarmTriggered</code> launch code. After each application has processed this launch code, the alarm manager sends each application <code>sysAppLaunchCmdDisplayAlarm</code> so that the application can display the alarm. The section <a href="SystemFeatures.html#925045">"Alarm Scenario"</a> gives more information about when these launch codes are received and what actions your application might take. For a specific example of responding to these launch codes, see the Datebook sample code. <a name="925023"> </a><p></p><dt>It's important to note the following:<ul type="SQUARE"><a name="925024"> </a><br><li>An application can have only one alarm pending at a time. If you call <code>AlmSetAlarm</code> and then call it again before the first alarm has triggered, the alarm manager replaces the first alarm with the second alarm. You can use the <a href="AlarmManager.html#924926">AlmGetAlarm</a> function to find out if the application has any alarms pending. <br><a name="925029"> </a><br><li>You do not have access to global variables or code outside segment 0 (in a multi-segment application) when you respond to the launch codes. <code>AlmSetAlarm</code> takes a <code>UInt32</code> parameter that you can use to pass a specific value so that you have access to it when the alarm triggers. (This is the <code>ref</code> parameter shown in <a href="SystemFeatures.html#924998">Listing 8.1</a>.) The parameter blocks for both launch codes provide access to this reference parameter. If the reference parameter isn't sufficient, you can define an application feature. See the section <a href="SystemFeatures.html#925109">"Features"</a> in this chapter. <br><a name="925037"> </a><br><li>The database ID that you pass to <code>AlmSetAlarm</code> is the local ID of the <strong>application</strong> (the <code>prc</code> file), not of the record database that the application accesses. You use record database's local ID more frequently than you do the application's local ID, so this is a common mistake to make. <br><a name="925038"> </a><br><li>In <code>AlmSetAlarm</code>, the alarm time is given as the number of seconds since 1/1/1904. If you need to convert a conventional date and time value to the number of seconds since 1/1/1904, use <code><a href="DateAndTimeManager.html#925124"></code>TimDateTimeToSeconds<code></a></code>. <br><a name="925043"> </a><br><li>If you want to clear a pending alarm, call <code>AlmSetAlarm</code> with 0 specified for the alarm seconds parameter. <br></ul></dl><a name="925045"> </a><h3> Alarm Scenario</h3><dl><a name="925046"> </a><p></p><dt>Here's how an application and the alarm manager typically interact when processing an alarm:</dl>  <a name="925050"> </a><font face="">The application sets an alarm using <code><a href="AlarmManager.html#924970"></code>AlmSetAlarm<code></a></code>. </font>  <a name="925051"> </a><font face="">The alarm manager adds the new alarm to its alarm queue. The alarm queue contains all alarm requests. Triggered alarms are queued up until the alarm manager can send the launch code to the application that created the alarm. However, if the alarm queue becomes full, the oldest entry that has been both triggered and notified is deleted to make room for a new alarm.</font>  <a name="925052"> </a><font face="">When the alarm time is reached, the alarm manager searches the alarm queue for the first application that set an alarm for this alarm time.</font>  <a name="925053"> </a><font face="">The alarm manager sends this application the <code><a href="AppLaunchCodes.html#925171"></code>sysAppLaunchCmdAlarmTriggered<code></a></code> launch code.</font>  <a name="925058"> </a><font face="">The application can now:</font><p></p><ul type="CIRCLE"><a name="925059"> </a><li>Set the next alarm.<a name="925060"> </a><li>Play a short sound.<a name="925061"> </a><li>Perform some quick maintenance activity. </ul>  <a name="925062"> </a><font face="">The application should not perform any lengthy tasks in response to <code>sysAppLaunchCmdAlarmTriggered</code> because doing so will delay other applications from receiving alarms that are set to trigger at the same time. </font>  <a name="925063"> </a><font face="">If this alarm requires no further processing, the application should set the <code>purgeAlarm</code> field in the launch code's parameter block to <code>true</code> before returning. Doing so removes the alarm from the queue, which means it won't receive the <code>sysAppLaunchCmdDisplayAlarm</code> launch code.</font>  <a name="925064"> </a><font face="">The alarm manager finds in the alarm queue the next application that set an alarm and repeats steps 2 and 3. </font>  <a name="925065"> </a><font face="">This process is repeated until no more applications are found with this alarm time.</font>  <a name="925066"> </a><font face="">The alarm manager then finds once again the first application in the alarm queue who set an alarm for this alarm time and sends this application the launch code <code><a href="AppLaunchCodes.html#925209"></code>sysAppLaunchCmdDisplayAlarm<code></a></code>.</font>  <a name="925071"> </a><font face="">The application can now:</font><p></p><ul type="CIRCLE"><a name="925072"> </a><li>Display a dialog box.<a name="925073"> </a><li>Display some other type of reminder.</ul>  <a name="925074"> </a><font face="">The alarm manager processes the alarm queue for the next application that set an alarm for the alarm being triggered and step 6 and 7 are repeated. </font>  <a name="925075"> </a><font face="">This process is repeated until no more applications are found with this alarm time.</font>  <a name="925076"> </a><font face="">If a new alarm time is triggered while an older alarm is still being displayed, all applications with alarms scheduled for this second alarm time are sent the <code>sysAppLaunchCmdAlarmTriggered</code> launch code, but the display cycle for the second set of alarms is postponed until all earlier alarms have finished displaying.</font><a name="925078"> </a><h3> Setting a Procedure Alarm</h3><dl><a name="925080"> </a><p></p><dt>Beginning with Palm OS version 3.2, the system supports setting procedure alarms in addition to the application-based alarms described in the previous sections. The differences between a procedure alarm and an application-based alarm are:<ul type="SQUARE"><a name="925081"> </a><br><li>When you set a procedure alarm, you specify a pointer to a function that should be called when the alarm triggers instead of an application that should be notified. <br><a name="925082"> </a><br><li>When the alarm triggers, the alarm manager calls the specified procedure directly instead of using launch codes. <br><a name="925083"> </a><br><li>If the system is in sleep mode, the alarm triggers without causing the LCD to light up. <br></ul><a name="925084"> </a><p></p><dt>You might use procedure alarms if:<ul type="SQUARE"><a name="925085"> </a><br><li>You want to perform a background task that is completely hidden from the user. <br><a name="925086"> </a><br><li>You are writing a shared library and want to implement an alarm within that library. <br></ul><a name="925091"> </a><p></p><dt>To set a procedure alarm, you call <code><a href="AlarmManager.html#925011"></code>AlmSetProcAlarm<code></a></code> instead of <code>AlmSetAlarm</code>. (Similarly, you use the <code><a href="AlarmManager.html#924945"></code>AlmGetProcAlarm<code></a></code> function instead of <code>AlmGetAlarm</code> to see if any alarms are pending for this procedure.) <a name="925096"> </a><p></p><dt><code>AlmSetProcAlarm</code> is currently implemented as a macro that calls <code>AlmSetAlarm</code> using a special value for the card number parameter to notify the alarm manager that this is a procedure alarm. Instead of specifying the application's local ID and card number, you specify a function pointer. The other rules for <code>AlmSetAlarm</code> still apply. Notably, a given function can only have one alarm pending at a time, and you can clear any pending alarm by passing 0 for the alarm time. <a name="925097"> </a><p></p><dt>When the alarm triggers, the alarm manager calls the function you specified. The function should have the prototype:<dl><a name="925098"> </a><br><code>void <em>myAlarmFunc</em> (UInt16&nbsp;almProcCmd, SysAlarmTriggeredParamType&nbsp;*paramP)</code><br><a name="925099"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>The function pointer must remain valid from the time <code>AlmSetProcAlarm</code> is called to the time the alarm is triggered. If the procedure is in a shared library, you must keep the library open. If the procedure is in a separately loaded code resource, the resource must remain locked until the alarm fires. When you close a library or unlock a resource, you must remove any pending alarms. If you don't, the system will crash when the alarm is triggered. <br><hr><br></blockquote><dl><a name="925100"> </a><p></p><dt>The first parameter to your function specifies why the alarm manager has called the function. Currently, the alarm manager calls the function in two instances:<ul type="SQUARE"><a name="925101"> </a><br><li>The alarm has triggered.<br><a name="925102"> </a><br><li>The user has changed the system time, so the alarm time should be adjusted. <br></ul><a name="925103"> </a><p></p><dt>The second parameter is the same structure that is passed with the <code><a href="AppLaunchCodes.html#925171"></code>sysAppLaunchCmdAlarmTriggered<code></a></code> launch code. It provides access to the reference parameter specified when the alarm was set, the time specified when the alarm was set, and the <code>purgeAlarm</code> field, which specifies if the alarm should be removed from the queue. In the case of procedure alarms, the alarm should always be removed from the queue. The system sets the <code>purgeAlarm</code> value to <code>true</code> after calling your function. </dl></dl></dl><a name="925109"> </a><h2> Features</h2><dl><a name="925112"> </a><p></p><dt>A <strong><em>feature</strong></em> is a 32-bit value that has special meaning to both the feature publisher and to users of that feature. Features can be published by the system or by applications. <a name="925113"> </a><p></p><dt>Each feature is identified by a feature creator and a feature number: <ul type="SQUARE"><a name="925114"> </a><br><li>The feature creator is a unique creator registered with Palm Computing<sup>&#174;</sup>. You usually use the creator type of the application that publishes the feature. <br><a name="925115"> </a><br><li>The feature number is any 16-bit value used to distinguish between different features of a particular creator.<br></ul><a name="925116"> </a><p></p><dt>Once a feature is published, it remains present until it is explicitly unregistered or the device is reset. A feature published by an application sticks around even after the application quits.<a name="925117"> </a><p></p><dt>This section introduces the feature manager by discussing these topics: <ul type="SQUARE"><a name="925121"> </a><br><li><a href="SystemFeatures.html#925135">The System Version Feature</a><br><a name="925125"> </a><br><li><a href="SystemFeatures.html#925184">Application-Defined Features</a><br><a name="925129"> </a><br><li><a href="SystemFeatures.html#925189">Using the Feature Manager</a><br><a name="925133"> </a><br><li><a href="SystemFeatures.html#925210">Feature Memory</a><br></ul></dl><a name="925135"> </a><h3> The System Version Feature</h3><dl><a name="925137"> </a><p></p><dt>An example for a feature is the system version. This feature is published by the system and contains a 32-bit representation of the system version. The system version has a feature creator of <code>sysFtrCreator</code> and a feature number of <code>sysFtrNumROMVersion</code>). Currently, the different versions of the system software have the following numbers:<p><a name="925169"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><td><a name="925142"> </a>0x01003001</td><td><a name="925144"> </a>Palm OS 1.0</td></tr><tr><td><a name="925146"> </a>0x02003000</td><td><a name="925148"> </a>Palm OS 2.0</td></tr><tr><td><a name="925150"> </a>0x03003000</td><td><a name="925152"> </a>Palm OS 3.0</td></tr><tr><td><a name="925154"> </a>0x03103000</td><td><a name="925156"> </a>Palm OS 3.1</td></tr><tr><td><a name="925158"> </a>0x03103000</td><td><a name="925160"> </a>Palm OS 3.1</td></tr><tr><td><a name="925162"> </a>0x03103000</td><td><a name="925164"> </a>Palm OS 3.1</td></tr><tr><td><a name="925166"> </a>0x03203000</td><td><a name="925168"> </a>Palm OS 3.2</td></tr><tr><td><a name="934685"> </a>0x03503000</td><td><a name="934687"> </a>Palm OS 3.5</td></tr></table><table><tr><td></table></div></p><a name="925170"> </a><p></p><dt>Any application can find out the system version by looking for this feature. For example:<dl><a name="925171"> </a><br><code>// See if we're on ROM version 2.0 or later.</code><br></dl><dl><a name="925172"> </a><code>FtrGet(sysFtrCreator, sysFtrNumROMVersion, </code><br><a name="925173"> </a><code>&nbsp&nbsp&nbsp 	 &amp;romVersion);</code><br><a name="925174"> </a><code>if (romVersion &gt;= 0x02000000) {</code><br><a name="925175"> </a><code>&nbsp&nbsp&nbsp ....</code><br><a name="925176"> </a><code>}</code><br><dl><a name="925178"> </a><p></p><dt>Other system features are defined in <code>SystemMgr.h</code>. System features are stored in a feature table in the ROM. (In Palm OS 3.1 and higher, the contents of this table are copied into the RAM feature table at system startup.) Checking for the presence of system features allows an application to be compatible with multiple versions of the system by refining its behavior depending on which capabilities are present or not. Future hardware platforms may lack some capabilities present in the first platform, so checking the system version feature is important. <a name="925179"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>For best results, we recommend that you check for specific features rather than relying on the system version number to determine if a specific API is available. For more details on checking for features, see the appendix <a href="CompatibilityApdx.html#483126">Compatibility Guide</a> in <em>Palm OS SDK Reference</em>.<br><hr><br></blockquote></dl></dl></dl><a name="925184"> </a><h3> Application-Defined Features</h3><dl><a name="925186"> </a><p></p><dt>Applications may find the feature manager useful for their own private use. For example, an application may want to publish a feature that contains a pointer to some private data it needs for processing launch codes. Because an application's global data is not generally available while it processes launch codes, using the feature manager is usually the easiest way for an application to get to its data. <a name="925187"> </a><p></p><dt>The feature manager maintains one feature table in the RAM as well as the feature table in the ROM. Application-defined features are stored in the RAM feature table. </dl><a name="925189"> </a><h3> Using the Feature Manager</h3><dl><a name="925194"> </a><p></p><dt>To check whether a particular feature is present, call <code><a href="FeatureManager.html#924918"></code>FtrGet<code></a></code> and pass it the feature creator and feature number. If the feature exists, <code>FtrGet</code> returns the 32-bit value of the feature. If the feature doesn't exist, an error code is returned.<a name="925195"> </a><p></p><dt>To publish a new feature or change the value of an existing one, call <a href="FeatureManager.html#925063">FtrSet</a> and pass the feature creator, number, and the 32-bit value of the feature. A published feature remains available until it is explicitly removed by a call to <code><a href="FeatureManager.html#925092"></code>FtrUnregister<code></a></code> or until the system resets; simply quitting an application doesn't remove a feature published by that application. <a name="925204"> </a><p></p><dt>Call <code>FtrUnregister</code> to remove features that were created by calling <code>FtrSet</code>.<a name="925205"> </a><p></p><dt>You can get a complete list of all published features by calling <code><a href="FeatureManager.html#924939"></code>FtrGetByIndex<code></a></code> repeatedly. Passing an index value starting at 0 to <code>FtrGetByIndex</code> and incrementing repeatedly by 1 eventually returns all available features. <code>FtrGetByIndex</code> accepts a parameter that specifies whether to search the ROM feature table or RAM feature table. Note that in Palm OS version 3.1 and higher, the contents of the ROM table are copied into the RAM table at system startup; thus the RAM table serves the entire system. </dl><a name="925210"> </a><h3> Feature Memory</h3><dl><a name="925212"> </a><p></p><dt>Palm OS 3.1 adds support for <strong>feature memory</strong>. Feature memory provides quick, efficient access to data that persists between invocations of an application. The values stored in feature memory persist until the device is reset or until you explicitly free the memory. Feature memory is memory allocated from the storage heap. Thus, you write to feature memory using <code><a href="DataAndResourceManager.html#927456"></code>DmWrite<code></a></code>, which means that writing to feature memory is no faster than writing to a database. However, feature memory can provide more efficient access to that data in certain circumstances.<a name="925221"> </a><p></p><dt>To allocate a chunk of feature memory, call <code><a href="FeatureManager.html#924984"></code>FtrPtrNew<code></a></code>, specifying a feature creator, a feature number, the number of bytes to allocate, and a location where the feature manager can return a pointer to the newly allocated memory chunk. For example:<dl><a name="925222"> </a><br><code>FtrPtrNew(appCreator, <br>	 	 myFtrMemFtr, 32, &amp;ftrMem);</code><br><dl><a name="933797"> </a><p></p><dt>Elsewhere in your application, you can obtain the pointer to the feature memory chunk using <code><a href="FeatureManager.html#924918"></code>FtrGet<code></a></code>. <a name="933802"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>Starting with Palm OS 3.5 <code>FtrPtrNew</code> allows allocating chunks larger than 64k. Do keep in mind standard issues with allocating large chunks of memory: there might not be enough contiguous space, and it can impact system performance. <hr><br></blockquote><a name="933803"> </a><p></p><dt>Feature memory is considered a performance optimization. The conditions under which you'd use it are not common, and you probably won't find them in a typical application. You use feature memory in code that: <ul type="SQUARE"><a name="925229"> </a><br><li>Is executed infrequently<br><a name="925230"> </a><br><li>Does not have access to global variables<br><a name="925231"> </a><br><li>Needs access to data whose contents change infrequently and that cannot be stored in a 32-bit feature value <br></ul><a name="925232"> </a><p></p><dt>For example, suppose you've written a function that is called in response to a launch code, and you expect to receive this launch code frequently. Suppose that function needs access to the application's preferences database. At the start of the function, you'd need to open the database and read the data from it. If the function is called frequently, opening the database each time can be a drain on performance. Instead, you can allocate a chunk of feature memory and write the values you need to that chunk. Because the chunk persists until the device is reset, you only need to open the database once. <a href="SystemFeatures.html#925237">Listing 8.2</a> illustrates this example.</dl></dl></dl><a name="925237"> </a><h4>Listing 8.2	 Using feature memory </h4><a name="925238"> </a><hr><code>MyAppPreferencesType prefs; </code><br><a name="925239"> </a><code></code><br><a name="925240"> </a><code>if (FtrGet(appCreator, myPrefFtr, (UInt32*)&amp;prefs) != 0) {</code><br><a name="925241"> </a><code></code><br><a name="925242"> </a><code>&nbsp&nbsp&nbsp // Feature memory doesn't exist, so allocate it.</code><br><a name="925243"> </a><code>&nbsp&nbsp&nbsp FtrPtrNew(appCreator, myPrefFtr, 32, &amp;thePref);</code><br><a name="925244"> </a><code></code><br><a name="925245"> </a><code>&nbsp&nbsp&nbsp // Load the preferences database. </code><br><a name="925246"> </a><code>&nbsp&nbsp&nbsp PrefGetAppPreferences (appCreator, prefID, &amp;prefs, </code><br><a name="925247"> </a><code>&nbsp&nbsp&nbsp 	 sizeof(prefs), true);</code><br><a name="925248"> </a><code></code><br><a name="925249"> </a><code>&nbsp&nbsp&nbsp // Write it to feature memory. </code><br><a name="925250"> </a><code>&nbsp&nbsp&nbsp DmWrite(thePref, 0, &amp;prefs, sizeof(prefs));</code><br><a name="925251"> </a><code>}</code><br><a name="925252"> </a><code>// Now prefs is guaranteed to be defined.</code><br><hr><br><dl><a name="925253"> </a><p></p><dt>Another potential use of feature memory is to "publish" data from your application or library to other applications when that data doesn't fit in a normal 32-bit feature value. For example, suppose you are writing a communications library and you want to publish an icon that client applications can use to draw the current connection state. The library can use <code>FtrPtrNew</code> to allocate a feature memory chunk and store an icon representing the current state in that location. Applications can then use <code>FtrGet</code> to access the icon and pass the result to <code>WinDrawBitmap</code> to display the connection state on the screen. </dl><a name="927535"> </a><h2> Notifications</h2><dl><a name="927672"> </a><p></p><dt>On systems where the <a href="CompatibilityApdx.html#499271">Notification Feature Set</a> is present, your application can receive <strong>notifications</strong> when certain system-level events or application-level events occur. Notifications are similar to application launch codes, but differ from them in two important ways: <ul type="SQUARE"><a name="927550"> </a><br><li>Notifications can be sent to any code resource, such as a shared library or a system extension (for example, a hack installed with the HackMaster program). Launch codes can only be sent to applications. Any code resource that is registered to receive a notification is called a <strong>notification client</strong>. <br><a name="927551"> </a><br><li>Notifications are only sent to applications or code resources that have specifically registered to receive them, making them more efficient than launch codes. Many launch codes are sent to all installed applications to give each application a chance to respond. <br></ul><a name="928230"> </a><p></p><dt>The Palm OS system and the built-in applications send notifications when certain events occur. See the chapter <a href="NotifyMgr.html#926122">"Notification Manager" </a> in the <em>Palm OS SDK Reference</em> for a complete list. (The notification manager broadcasts the notifications and maintains a list of clients for each notification). <a name="928169"> </a><p></p><dt>It's also possible for your application to create and broadcast its own notifications. However, doing so is rare. It's more likely that you'll want to register to receive the predefined notifications. <a name="929709"> </a><p></p><dt>Three general types of event flow are possible using the notification manager:<ul type="SQUARE"><a name="927553"> </a><br><li>Single consumer <br><dl><a name="928088"> </a><p></p><dt>Each client is notified that the event has occurred and handles it in its own way without modifying any information in the parameter block. </dl><a name="927554"> </a><br><li>Collaborative<br><dl><a name="928100"> </a><p></p><dt>The notification's parameter block contains a <code>handled</code> flag. Clients can set this flag to communicate to other clients that the event has been handled, while still allowing them to receive the notification. An example of this is the <code>sysNotifyAntennaRaisedEvent</code> for Palm VII<sup>&#153;</sup> series devices. A client might decide to handle the antenna key down event and in this case, sets <code>handled</code> to <code>true</code> to inform other clients that the event has been handled. </dl><a name="927555"> </a><br><li>Collective<br><dl><a name="929790"> </a><p></p><dt>Each client can add information to the notification's parameter block, allowing the data to be accumulated for all clients. This style of notification could be used, for example, to build a menu dynamically by letting each client add its own menu text. The <code>sysNotifyMenuCmdBarOpenEvent</code> is similar to this style of notification. </dl></ul></dl><a name="929792"> </a><h3> Registering for a Notification</h3><dl><a name="927557"> </a><p></p><dt>To receive notification that an event has occurred, you must register for it using the <code><a href="NotifyMgr.html#926525"></code>SysNotifyRegister<code></a></code> function. Once you register for a notification, you remain registered until the system is reset or until you explicitly unregister for this notification using <code><a href="NotifyMgr.html#926589"></code>SysNotifyUnregister<code></a></code>.<a name="927558"> </a><p></p><dt>To register an application for the HotSync<sup>&#174;</sup> notification, you'd use a function call similar to the one in <a href="SystemFeatures.html#928311">Listing 8.3</a>.</dl><a name="928311"> </a><h4>Listing 8.3	 Registering an application for a notification</h4><a name="928324"> </a><hr><code>SysNotifyRegister(myCardNo, appDBID, </code><br><a name="928409"> </a><code>&nbsp&nbsp&nbsp sysNotifySyncStartEvent, NULL, </code><br><a name="928410"> </a><code>&nbsp&nbsp&nbsp sysNotifyNormalPriority, myDataP);</code><br><hr><br><dl><a name="927560"> </a><p></p><dt>If you are writing a shared library instead of an application and you want to be notified about the HotSync event, your call to <code>SysNotifyRegister</code> looks slightly different. See <a href="SystemFeatures.html#928551">Listing 8.4</a>.</dl><a name="928551"> </a><h4>Listing 8.4	 Registering a shared library for a notification</h4><a name="928573"> </a><hr><code>SysNotifyRegister(myCardNo, shlibDBID,</code><br><a name="928695"> </a><code>&nbsp&nbsp&nbsp sysNotifySyncStartEvent, SyncNotifyHandler,</code><br><a name="928780"> </a><code>&nbsp&nbsp&nbsp sysNotifyNormalPriority, myDataP);</code><br><hr><br><dl><a name="927562"> </a><p></p><dt>The parameters you pass to the <code>SysNotifyRegister</code> function specify the following:<ul type="SQUARE"><a name="927563"> </a><br><li>The first two parameters are the card number and database ID for the <code>prc</code> file. Be sure you're not passing the local ID of the record database that your application accesses. You use the record database's local ID more frequently than you do the application's local ID, so this is a common mistake to make. <br><a name="927564"> </a><br><li><code>sysNotifySyncStartEvent</code> specifies that you want to be informed when a HotSync operation is about to start. There is also a <code>sysNotifySyncFinishEvent</code> that specifies that a HotSync operation has ended. <br><a name="927565"> </a><br><li>The next parameter specifies how the notification should be received. This is where <a href="SystemFeatures.html#928311">Listing 8.3</a> and <a href="SystemFeatures.html#928551">Listing 8.4</a> differ. <br><dl><a name="927566"> </a><p></p><dt>Applications use <code>NULL</code> for this parameter to specify that they should be notified through the application launch code <code><a href="AppLaunchCodes.html#926527"></code>sysAppLaunchCmdNotify<code></a></code>. As with all other launch codes, the system passes this to the application's <code>PilotMain</code> function. <a name="927567"> </a><p></p><dt>The shared library has no <code>PilotMain</code> function and therefore no way to receive a launch code, so it passes a pointer to a callback routine. Only use a callback routine if your code doesn't have a <code>PilotMain</code>. <a name="930510"> </a><p></p><dt>Note that it's always necessary to pass the card number and database ID of your <code>prc</code> file even if you specify a callback routine. </dl><a name="927568"> </a><br><li><code>sysNotifyNormalPriority</code> means that you don't want your code to receive any special consideration when receiving the notification. Notifications are broadcast synchronously in priority order. The lower the number you specify here, the earlier you receive the notification in the list. <br><dl><a name="930575"> </a><p></p><dt>In virtually all cases, you should use <code>sysNotifyNormalPriority</code>. If you absolutely must ensure that your code is notified in a certain order (either before most notifications or after most notifications), use a value between -15 and +15 for the priority. Using a value in this range ensures that your code won't collide with the system's handling of notifications. </dl><a name="927569"> </a><br><li><code>myDataP</code> is a pointer to any data you need to access in your notification handler routine. As with most launch codes, <code>sysAppLaunchCmdNotify</code> does not provide access to global variables, so you should use this pointer to pass yourself any needed data. <br></ul><a name="927570"> </a><p></p><dt>After you've made the calls shown in <a href="SystemFeatures.html#928311">Listing 8.3</a> and <a href="SystemFeatures.html#928551">Listing 8.4</a> and the system is about to begin a HotSync operation, it broadcasts the <code>sysNotifySyncStartEvent</code> notification to both clients. <a name="927571"> </a><p></p><dt>The application is notified through the <code>sysAppLaunchCmdNotify</code> launch code. This launch code's parameter block is a <code><a href="NotifyMgr.html#926235"></code>SysNotifyParamType<code></a></code> structure containing the notification name, the broadcaster, and a pointer to your specific data (<code>myDataP</code> in the example above). Some notifications contain extra information in a <code>notifyDetailsP</code> field in this structure. The HotSync notifications do not use the <code>notifyDetailsP</code> field. <a name="927572"> </a><p></p><dt>The shared library is notified by a call to its <code>SyncNotifyHandler</code> function. This function is passed the same <code>SysNotifyParamType</code> structure that is passed through the launch code mechanism. <a name="930585"> </a><blockquote><br><hr><br><em><strong>IMPORTANT:  </strong></em>Because the callback pointer is used to directly call the function, the pointer must remain valid from the time <code>SysNotifyRegister</code> is called to the time the notification is broadcast. If the function is in a shared library, you must keep the library open. If the function is in a separately loaded code resource, the resource must remain locked while registered for the notification. When you close a library or unlock a resource, you must first unregister for any notifications. If you don't, the system will crash when the notification is broadcast. <br><hr><br></blockquote></dl><a name="927574"> </a><h3> Writing a Notification Handler</h3><dl><a name="929116"> </a><p></p><dt>The application's response to <code>sysAppLaunchCmdNotify</code> and the shared library's callback function are called <strong>notification handlers</strong>. A notification handler may perform any processing necessary, including displaying a user interface or broadcasting other notifications. <a name="927575"> </a><p></p><dt>When displaying a user interface, consider the possibility that you may be blocking other applications from receiving the notification. For this reason, it's generally not a good idea to display a modal form or do anything else that requires waiting for the user to respond. Also, many of the notifications are broadcast during <code><a href="SystemManager.html#925364"></code>SysHandleEvent<code></a></code>, which means your application event loop may not have progressed to the point where it is possible for you to display a user interface, or you may overflow the stack. <a name="927576"> </a><p></p><dt>If you need to perform some lengthy process in a notification handler, one way to ensure that you aren't blocking other events is to send yourself a deferred notification. For example, <a href="SystemFeatures.html#929624">Listing 8.5</a> shows a notification handler for the <code>sysNotifyTimeChangeEvent</code> notification that performs no work other than setting up a deferred notification (<code>myDeferredNotifyEvent</code>) and scheduling it for broadcast. When the application receives the <code>myDeferredNotifyEvent</code>, it calls the MyNotifyHandler function, which is where the application really handles the time change event.</dl><a name="929624"> </a><h4>Listing 8.5	 Deferring notification within a handler</h4><a name="929301"> </a><hr><code>case sysAppLaunchCmdNotify : </code><br><a name="929302"> </a><code>&nbsp&nbsp&nbsp if (cmdPBP-&gt;notify-&gt;notifyType == <code>sysNotifyTimeChangeEvent</code>) {</code><br><a name="929389"> </a><code>&nbsp&nbsp&nbsp 	 SysNotifyParamType notifyParm;</code><br><a name="929545"> </a><code>&nbsp&nbsp&nbsp 	 MyGlobalsToAccess myData;</code><br><a name="929400"> </a><code></code><br><a name="929548"> </a><code>&nbsp&nbsp&nbsp 	 /* initialize myData here */</code><br><a name="929558"> </a><code></code><br><a name="929574"> </a><code>&nbsp&nbsp&nbsp 	 /* Create the notification block. */</code><br><a name="929363"> </a><code>&nbsp&nbsp&nbsp 	 notifyParam.notifyType = myDeferredNotifyEvent;</code><br><a name="929364"> </a><code>&nbsp&nbsp&nbsp 	 notifyParam.broadcaster = myCreatorID;</code><br><a name="929365"> </a><code>&nbsp&nbsp&nbsp 	 notifyParam.notifyDetailsP= NULL;</code><br><a name="929366"> </a><code>&nbsp&nbsp&nbsp 	 notifyParam.handled = false;</code><br><a name="929443"> </a><code></code><br><a name="929448"> </a><code>&nbsp&nbsp&nbsp 	 /* Register for my notification */</code><br><a name="929454"> </a><code>&nbsp&nbsp&nbsp 	 SysNotifyRegister(myCardNo, appDBID, myDeferredNotifyEvent, <br>	 	 	 NULL, sysNotifyNormalPriority, &amp;myData);</code><br><a name="929533"> </a><code></code><br><a name="929544"> </a><code>&nbsp&nbsp&nbsp 	 /* Broadcast the notification */</code><br><a name="927581"> </a><code>&nbsp&nbsp&nbsp 	 SysNotifyBroadcastDeferred(&amp;notifyParam, NULL);</code><br><a name="929607"> </a><code></code><br><a name="929588"> </a><code>&nbsp&nbsp&nbsp } else if (cmdPBP-&gt;notify-&gt;notifyType == myDeferredNotifyEvent)</code><br><a name="927583"> </a><code>&nbsp&nbsp&nbsp 	 MyNotifyHandler(cmdPBP-&gt;notify);</code><br><a name="927584"> </a><code>break;</code><br><hr><br><dl><a name="927585"> </a><p></p><dt>The <code><a href="NotifyMgr.html#926492"></code>SysNotifyBroadcastDeferred<code></a></code> function broadcasts the specified notification to all interested parties; however, it waits to do so until the current event has completed processing. Thus, by using a separate deferred notification, you can be sure that all other clients have had a chance to respond to the first notification. <a name="927586"> </a><p></p><dt>There are two functions that broadcast notifications: <code><a href="NotifyMgr.html#926461"></code>SysNotifyBroadcast<code></a></code>, which immediately broadcasts the notification, and <code>SysNotifyBroadcastDeferred</code>, which waits until the next time <code><a href="SystemEventManager.html#925143"></code>EvtGetEvent<code></a></code> is called. Notification handlers should use <code>SysNotifyBroadcastDeferred</code> to avoid the possibility of overflowing the notification stack. <a name="927587"> </a><p></p><dt>A special case of dealing with lengthy computations in a notification handler occurs when the system is being put to sleep. See <a href="SystemFeatures.html#927588">"Sleep and Wake Notifications"</a> below. </dl><a name="927588"> </a><h3> Sleep and Wake Notifications</h3><dl><a name="927589"> </a><p></p><dt>Several notifications are broadcast at various stages when the system goes to sleep and when the system wakes up. These are: <ul type="SQUARE"><a name="927590"> </a><br><li><code>sysNotifySleepRequestEvent</code> <br><a name="927591"> </a><br><li><code>sysNotifySleepNotifyEvent</code> <br><a name="927592"> </a><br><li><code>sysNotifyEarlyWakeupEvent</code> <br><a name="927593"> </a><br><li><code>sysNotifyLateWakeupEvent</code> <br></ul><a name="927594"> </a><p></p><dt>These notifications are <strong>not</strong> guaranteed to be broadcast. For example, if the system goes to sleep because the user removes the batteries, sleep notifications are not sent. Thus, these notifications are unsuitable for applications where external hardware must be shut off to conserve power before the system goes to sleep. <a name="930151"> </a><p></p><dt>If you want to know when the system is going to sleep because you have a small amount of cleanup that should occur beforehand, then register for <code>sysNotifySleepNotifyEvent</code>. <a name="930085"> </a><p></p><dt>It is recommended that you not perform any sort of prolonged activity, such as displaying an alert panel that requests confirmation, in response to a sleep notification. If you do, the alert might be displayed long enough to trigger another auto-off event, which could be detrimental to other handlers of the sleep notify event. <a name="930120"> </a><p></p><dt>In a few instances, you might need to prevent the system from going to sleep. For example, your code might be in the middle of performing some lengthy computation or in the middle of attempting a network connection. If so, register for the <code>sysNotifySleepRequestEvent</code> instead. This notification informs all clients that the system might go to sleep. If necessary, your handler can delay the sleep request by doing the following:<dl><a name="927596"> </a><br><code>notify-&gt;notifyDetailsP-&gt;deferSleep++;</code><br><dl><a name="927597"> </a><p></p><dt>The system checks the <code>deferSleep</code> value when each notification handler returns. If it is nonzero, it cancels the sleep event. <a name="930195"> </a><p></p><dt>After you defer sleep, your code is free to finish what it was doing. When it is finished, you must allow the system to continue with the sleep event. To do so, create a <code><a href="EventRef.html#925881"></code>keyDownEvent<code></a></code> with the <code>resumeSleepChr</code> and the command key bit set (to signal that the character is virtual) and add it to the event queue. When the system receives this event, it will again broadcast the <code>sysNotifySleepRequestEvent</code> to all clients. If <code>deferSleep</code> is 0 after all clients return, then the system knows it is safe to go to sleep, and it broadcasts the <code>sysNotifySleepNotifyEvent</code> to all of its clients. <a name="930280"> </a><p></p><dt>Notice that you may potentially receive the <code>sysNotifySleepRequestEvent</code> many times before the system actually goes to sleep, but you receive the <code>sysNotifySleepNotifyEvent</code> exactly once. <a name="927600"> </a><p></p><dt>During a wake-up event, the other two notifications listed above are broadcast. The <code>sysNotifyEarlyWakeupEvent</code> is broadcast very early on in the wakeup process, generally before the screen has turned on. At this stage, it is not guaranteed that the system will fully wake up. It may simply handle an alarm or a battery charger event and go back to sleep. Most applications that need notification of a wakeup event will probably want to register for <code>sysNotifyLateWakeupEvent</code> instead. At this stage, the screen has been turned on and the system is guaranteed to fully wake up. </dl></dl></dl><a name="925262"> </a><h2> Sound</h2><dl><a name="925265"> </a><p></p><dt>The Palm Computing platform device has primitive sound generation. A square wave is generated directly from the 68328's PWM circuitry. There is frequency, duration, and volume control. Additionally, Palm OS 3.0 and higher support creating and playing standard MIDI sounds.<a name="925266"> </a><p></p><dt>The Palm OS sound manager provides an extendable API for playing custom sounds and system sounds, and for controlling default sound settings. Although the sound API accommodates multichannel design, the system provides only a single sound channel at present.<a name="925267"> </a><p></p><dt>The sound hardware can play only one simple tone at a time through an onboard piezoelectric speaker. Note that for a particular amplitude level, the Palm III<sup>&#153;</sup> device is slightly louder than its predecessors. <a name="925272"> </a><p></p><dt>Single tones can be played by the <a href="SoundManager.html#925313">SndDoCmd</a> function and system sounds are played by the <a href="SoundManager.html#925520">SndPlaySystemSound</a> function. The end-user can control the amplitude of alarm sounds, game sounds, and system sounds by means of the Preferences application. System-supplied sounds include the Information, Warning, Error, Startup, Alarm, Confirmation, and Click sounds.<a name="925283"> </a><p></p><dt>Palm OS 3.0 introduces support for Standard MIDI Files (SMFs), format 0. An SMF is a note-by-note description of a tune--Palm OS doesn't support sampled sound, multiple voices, or complex "instruments." You can download the SMF format specification from the <code>http://www.midi.org</code> Web site. <a name="925284"> </a><p></p><dt>The alarm sounds used in the built-in Date Book application are SMFs stored in the System MIDI Sounds database and can be played by the <a href="SoundManager.html#925365">SndPlaySmf</a> function.<a name="925289"> </a><p></p><dt>All SMF records in the System MIDI Sounds database are available to the user. Developers can add their own alarm SMFs to this database as a way to add variety and personalization to their devices. You can use the <code>sysFileTMidi</code> file type and <code>sysFileCSystem </code>creator to open this database.<a name="925290"> </a><p></p><dt>Each record in the database is a single SMF, with a header structure containing the user-visible name. The record includes a song header, then a track header, followed by any number of events. The system only recognizes the <code>keyDown</code>, <code>keyUp</code> and <code>tempo</code> events in a single track; other commands which might be in the SMF are ignored. For more information, see the following:<ul type="SQUARE"><a name="925294"> </a><br><li><a href="SystemFeatures.html#925370">Adding a Standard MIDI File to a Database</a> in this chapter. <br><a name="925298"> </a><br><li><a href="SoundManager.html#924957">SndCallbackInfoType</a> in the <em>Palm OS SDK Reference</em>. <br><a name="925302"> </a><br><li><a href="SoundManager.html#925116">SndMidiRecHdrType</a> in the <em>Palm OS SDK Reference</em>. <br></ul><a name="925303"> </a><p></p><dt>You can use standard MIDI tools to create SMF blocks on desktop computers, or you can write code to create them on the Palm OS device. The sample code project "RockMusic," particularly the routines in the <code>MakeSMF.c</code> file, can be helpful to see how to create an SMF programmatically.<a name="925304"> </a><p></p><dt>Previous versions of Palm OS don't support SMFs or asynchronous notes; don't use the new routines or commands when the <code>FtrGet</code> function returns a system version of less than <code>0x03000000</code>. Doing so will crash your application. See the section <a href="SystemFeatures.html#925135">"The System Version Feature"</a> for more information.</dl><a name="925308"> </a><h3> Synchronous and Asynchronous Sound</h3><dl><a name="925313"> </a><p></p><dt>The <a href="SoundManager.html#925313">SndDoCmd</a> function executes synchronously or asynchronously according to the operation it is to perform. The <code>sndCmdNoteOn</code> and <code>sndCmdFrqOn</code> operations execute asynchronously; that is, they are non-blocking and can be interrupted by another sound command. In contrast, the <code>sndCmdFreqDurationAmp</code> operation is synchronous and blocking (it cannot be interrupted). <a name="925319"> </a><p></p><dt>The <a href="SoundManager.html#925365">SndPlaySmf</a> function is also synchronous and blocking; however, the Sound Manager polls the key queue periodically during playback and halts playback in progress if it finds events generated by user interaction with the screen, digitizer, or hardware-based buttons. Optionally, the caller can override this default behavior to specify that the <a href="SoundManager.html#925365">SndPlaySmf</a><code> </code>function play the SMF to completion without being interrupted by user events.</dl><a name="925323"> </a><h3> Using the Sound Manager</h3><dl><a name="925324"> </a><p></p><dt>Before playing custom sounds that require a volume (amplitude) setting, your code needs to discover the user's current volume settings. To do so in Palm OS 3.X, pass one of the <code>prefSysSoundVolume</code>, <code>prefGameSoundVolume</code>, or <code>prefAlarmSoundVolume </code>selectors to the <code><a href="Preferences.html#924972"></code>PrefGetPreference<code></a></code> function. <a name="925335"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>See <a href="SystemFeatures.html#925489">"Sound Preferences Compatibility Information"</a> for important information regarding the correct use of sound preferences in various versions of Palm OS.<hr><br></blockquote><a name="925336"> </a><p></p><dt>You can pass the returned amplitude information to the <a href="SoundManager.html#925365">SndPlaySmf</a> function as one element of a <a href="SoundManager.html#925219">SndSmfOptionsType</a><code> </code>parameter block. Alternatively, you can pass amplitude information to the <a href="SoundManager.html#925313">SndDoCmd</a> function as an element of a <a href="SoundManager.html#925062">SndCommandType</a><code> </code>parameter block. <a name="925357"> </a><p></p><dt>To execute a sound manager command, pass to the <a href="SoundManager.html#925313">SndDoCmd</a> function a sound channel pointer (presently, only <code>NULL</code> is supported and maps to the shared channel), a pointer to a structure of <code>SndCommandType</code>, and a flag indicating whether the command should be performed asynchronously. <a name="925358"> </a><p></p><dt>To play SMFs, call the <code>SndPlaySMF</code> function. This function, which is new in Palm OS 3.0, is used by the built in Date Book application to play alarm sounds. <a name="925359"> </a><p></p><dt>To play single notes, you can use either of the <code>SndPlaySMF</code> or <code>SndDoCmd</code> functions. Of course, you can use the <code>SndPlaySMF</code> function to play a single MIDI note from an SMF. You can also use the <code>SndDoCmd</code> function to play a single MIDI note by passing the <code>sndCmdNoteOn</code> command selector to this function. To specify by frequency the note to be played, pass the <code>sndCmdFrqOn</code> command selector to the <code>SndDoCmd</code> function.You can pass the <code>sndCmdQuiet</code> selector to this function to stop playback of the current note.<a name="925360"> </a><p></p><dt>The system provides no specialized API for playing game sounds or alarm sounds. When an alarm triggers, the application that set the alarm must use the standard Sound Manager API to play the sound associated with that alarm. Similarly, game sounds are implemented by the game developer using any appropriate element of the Sound Manager API. Games should observe the <code>prefGameSoundVolume </code>setting, as described in the section "<a href="SystemFeatures.html#925489">Sound Preferences Compatibility Information</a>."<a name="925364"> </a><p></p><dt>To play a default system sound, such as a click or an error beep, pass the appropriate system sound ID to the <a href="SoundManager.html#925520">SndPlaySystemSound</a> function, which will play that sound at the volume level specified by the user's system sound preference. For the complete list of system sound IDs, see the <code>SoundMgr.h</code> file provided by the Palm OS SDK.</dl><a name="925370"> </a><h4> Adding a Standard MIDI File to a Database</h4><dl><a name="925371"> </a><p></p><dt>To add a format 0 standard MIDI file to the system MIDI database, you can use code similar to the <code>AddSmfToDatabase</code> example function shown in the following code listing. This function returns 0 if successful, and returns a non-zero value otherwise. To use a different database, pass different creator and type values to the <code><a href="DataAndResourceManager.html#926762"></code>DmOpenDatabaseByTypeCreator<code></a></code> function. </dl><a name="925376"> </a><h4>Listing 8.6	 AddSmfToDatabase</h4><a name="925377"> </a><hr><code>// Useful structure field offset macro</code><br><a name="925378"> </a><code>#define prvFieldOffset(type, field) ((UInt32)(&amp;((type*)0)-&gt;field))</code><br><a name="925379"> </a><code></code><br><a name="925380"> </a><code>// returns 0 for success, nonzero for error</code><br><a name="925381"> </a><code>Int16 AddSmfToDatabase(MemHandle smfH, Char* trackName)</code><br><a name="925382"> </a><code>{</code><br><a name="925383"> </a><code>&nbsp&nbsp&nbsp Err	 	 	 	 	 err = 0;</code><br><a name="925384"> </a><code>&nbsp&nbsp&nbsp DmOpenRef	 	 	 	 	 dbP;</code><br><a name="925385"> </a><code>&nbsp&nbsp&nbsp UInt16*	 	 	 	 	 recIndex;</code><br><a name="925386"> </a><code>&nbsp&nbsp&nbsp MemHandle	 	 	 	 	 recH;</code><br><a name="925387"> </a><code>&nbsp&nbsp&nbsp UInt8*	 	 	 	 	 recP;</code><br><a name="925388"> </a><code>&nbsp&nbsp&nbsp UInt8*	 	 	 	 	 smfP;</code><br><a name="925389"> </a><code>&nbsp&nbsp&nbsp UInt32	 	 	 	 	 bMidiOffset;</code><br><a name="925390"> </a><code>&nbsp&nbsp&nbsp UInt32	 	 	 	 	 dwSmfSize;</code><br><a name="925391"> </a><code>&nbsp&nbsp&nbsp SndMidiRecHdrType	 	 	 	 	 	 	 	 	 recHdr;</code><br><a name="925392"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925393"> </a><code>&nbsp&nbsp&nbsp bMidiOffset = sizeof(SndMidiRecHdrType) + <br>	 	 	 	 	 	 	 	 StrLen(trackName) + 1;</code><br><a name="925394"> </a><code>&nbsp&nbsp&nbsp dwSmfSize = MemHandleSize(smfH);</code><br><a name="925395"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925396"> </a><code>&nbsp&nbsp&nbsp recHdr.signature = sndMidiRecSignature;</code><br><a name="925397"> </a><code>&nbsp&nbsp&nbsp recHdr.reserved = 0;</code><br><a name="925398"> </a><code>&nbsp&nbsp&nbsp recHdr.bDataOffset = bMidiOffset;</code><br><a name="925399"> </a><code></code><br><a name="925400"> </a><code>&nbsp&nbsp&nbsp dbP = DmOpenDatabaseByTypeCreator(sysFileTMidi, sysFileCSystem,<br>	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 dmModeReadWrite | dmModeExclusive);</code><br><a name="925401"> </a><code>&nbsp&nbsp&nbsp if (!dbP)</code><br><a name="925402"> </a><code>&nbsp&nbsp&nbsp 	 return 1;</code><br><a name="925403"> </a><code></code><br><a name="925404"> </a><code>&nbsp&nbsp&nbsp // Allocate a new record for the midi resource</code><br><a name="925405"> </a><code>&nbsp&nbsp&nbsp recIndex = dmMaxRecordIndex;</code><br><a name="925406"> </a><code>&nbsp&nbsp&nbsp recH = DmNewRecord(dbP, &amp;recIndex, dwSmfSize + bMidiOffset);</code><br><a name="925407"> </a><code>&nbsp&nbsp&nbsp if ( !recH )</code><br><a name="925408"> </a><code>&nbsp&nbsp&nbsp 	 return 2;</code><br><a name="925409"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925410"> </a><code>&nbsp&nbsp&nbsp // Lock down the source SMF and target record and copy the data</code><br><a name="925411"> </a><code>&nbsp&nbsp&nbsp smfP = MemHandleLock(smfH);</code><br><a name="925412"> </a><code>&nbsp&nbsp&nbsp recP = MemHandleLock(recH);</code><br><a name="925413"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925414"> </a><code>&nbsp&nbsp&nbsp err = DmWrite(recP, 0, &amp;recHdr, sizeof(recHdr));</code><br><a name="925415"> </a><code>&nbsp&nbsp&nbsp if (!err) err = DmStrCopy(recP, prvFieldOffset(SndMidiRecType,<br>	 	 	 name), trackName);</code><br><a name="925416"> </a><code>&nbsp&nbsp&nbsp if (!err) err = DmWrite(recP, bMidiOffset, smfP, dwSmfSize);</code><br><a name="925417"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925418"> </a><code>&nbsp&nbsp&nbsp // Unlock the pointers</code><br><a name="925419"> </a><code>&nbsp&nbsp&nbsp MemHandleUnlock(smfH);</code><br><a name="925420"> </a><code>&nbsp&nbsp&nbsp MemHandleUnlock(recH);</code><br><a name="925421"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925422"> </a><code>&nbsp&nbsp&nbsp //Because DmNewRecord marks the new record as busy, <br>	 // we must call DmReleaseRecord before closing the database</code><br><a name="925423"> </a><code>&nbsp&nbsp&nbsp DmReleaseRecord(dbP, recIndex, 1);</code><br><a name="925424"> </a><code><br>	 DmCloseDatabase(dbP);</code><br><a name="925425"> </a><code></code><br><a name="925426"> </a><code>&nbsp&nbsp&nbsp return err;</code><br><a name="925427"> </a><code>}</code><br><hr><br><a name="925428"> </a><h4> Saving References to Standard MIDI Files</h4><dl><a name="925430"> </a><p></p><dt>To save a reference to a SMF stored in a particular database, save its record ID and the name of the database in which it is stored. Do not store the database ID between invocations of your application, because various events, such as a HotSync, can invalidate database IDs. Using an invalid database ID can crash your application. </dl><a name="925431"> </a><h4> Retrieving a Standard MIDI File From a Database</h4><dl><a name="925432"> </a><p></p><dt>Standard MIDI Files (SMFs) are stored as individual records in a MIDI record database--one SMF per record. Palm OS defines the database type <code>sysFileTMidi</code> for MIDI record databases. The system MIDI database, with type <code>sysFileTMidi</code> and creator <code>sysFileCSystem</code>, holds multiple system alarm sounds. In addition, your applications can create their own private MIDI databases of type <code>sysFileTMidi</code> and your own creator.<a name="925433"> </a><p></p><dt>To obtain a particular SMF, you need to identify the database in which it resides and the specific database record which holds the SMF data. The database record itself is always identified by record ID. The MIDI database in which it resides may be identified by name or by database ID. If you know the creator of the SMF, you can use the <a href="SoundManager.html#925275">SndCreateMidiList</a> utility function to retrieve this information. Alternatively, you can use the Data Manager record API functions to iterate through MIDI database records manually in search of this information.<a name="925438"> </a><p></p><dt>The <code>SndCreateMidiList</code> utility function retrieves information about Standard Midi Files from one or more MIDI databases. This information is returned as a table of entries. Each entry contains the name of an SMF; its unique record ID; and the database ID and card number of the record database in which it resides.<a name="925439"> </a><p></p><dt>Once you have the appropriate identifiers for the record and the database in which it resides, you need to open the MIDI database. If you have identified the database by type and creator, pass the <code>sysFileTMidi</code> type and an appropriate creator value to the <a href="DataAndResourceManager.html#926762">DmOpenDatabaseByTypeCreator</a> function. For example, to retrieve a SMF from the system MIDI database, pass type <code>sysFileTMidi</code> and creator <code>sysFileCSystem</code>. The <code>DmOpenDatabaseByTypeCreator </code>function returns a reference to the open database. <a name="925443"> </a><p></p><dt>If you have identified the database by name, rather than by creator, you'll need to discover its database ID in order to open it. The <a href="DataAndResourceManager.html#925838">DmFindDatabase</a> function returns the database ID for a database specified by name and card number. You can pass the returned ID to the <a href="DataAndResourceManager.html#926691">DmOpenDatabase</a> function to open the database and obtain a reference to it. <a name="925452"> </a><p></p><dt>Once you have opened the MIDI database, call <a href="DataAndResourceManager.html#925865">DmFindRecordByID</a> to get the index of the SMF record. To retrieve the record itself, pass this index value to either of the functions <a href="DataAndResourceManager.html#926888">DmQueryRecord</a> or <a href="DataAndResourceManager.html#926284">DmGetRecord</a>. When you intend to modify the record, use the <code>DmGetRecord</code> function--it marks the record as busy. When you intend to use the record in read-only fashion, use the <code>DmQueryRecord</code> function --it does not mark the record as busy. You must lock the handle returned by either of these functions before making further use of it. <a name="925469"> </a><p></p><dt>To lock the database record's handle, pass it to the <a href="MemoryManager.html#925048">MemHandleLock</a> function, which returns a pointer to the locked record holding the SMF data. You can pass this pointer to the <a href="SoundManager.html#925365">SndPlaySmf</a> function in the <code>smfP</code> parameter to play the MIDI file. <a name="925474"> </a><p></p><dt>When you've finished using the record, unlock the pointer to it by calling the <a href="MemoryManager.html#925756">MemPtrUnlock</a> function. If you've used <code>DmGetRecord</code> to open the record for editing, you must call <a href="DataAndResourceManager.html#926964">DmReleaseRecord</a> to make the record available once again to other callers. If you used <code>DmQueryRecord </code>to open the record for read-only use, you need not call <code>DmReleaseRecord</code>. <a name="925487"> </a><p></p><dt>Finally, close the database by calling the <a href="DataAndResourceManager.html#925393">DmCloseDatabase</a> function.</dl><a name="925489"> </a><h3> Sound Preferences Compatibility Information</h3><dl><a name="925490"> </a><p></p><dt>The sound preferences implementation and API varies slightly among versions 1.0, 2.0, and 3.X of Palm OS. This section describes how to use sound preferences correctly for various versions of Palm OS. <a name="925491"> </a><p></p><dt>Because versions 2.0 and 3.X of Palm OS provide backward compatibility with previous sound preference mechanisms, applications written for an earlier version of the sound preferences API will get correct sound preference information from newer versions of Palm OS. However, it is strongly recommended that new applications use the latest API. </dl><a name="925492"> </a><h4> Using Sound Preferences on All Palm OS Devices</h4><dl><a name="925493"> </a><p></p><dt>Because the user chooses sound preference settings, your application should respect them and adhere to their values. Further, you should always treat sound preferences as read-only values.<a name="925494"> </a><p></p><dt>At reset time, the sound manager reads stored preference values and caches them for use at run time. The user interface controls update both the stored preference values and the sound manager's cached values. <a name="925499"> </a><p></p><dt>The <a href="Preferences.html#925102">PrefSetPreference</a> function writes to stored preference values without affecting cached values. New values are read at the next system reset. The system-use-only <code>SndSetDefaultVolume </code>function updates cached values but not stored preferences. Applications should avoid modifying stored preferences or cached values in favor of respecting the user's choices for preferences.</dl><a name="925503"> </a><h4> Using Palm OS 1.0 Sound Preferences</h4><dl><a name="925504"> </a><p></p><dt>To read sound preference values in version 1.0 of Palm OS, call the <a href="Preferences.html#925007">PrefGetPreferences</a> function to obtain the data structure shown in <a href="SystemFeatures.html#925516">Listing 8.7</a>. This <code>SystemPreferencesTypeV10 </code>structure holds the current values of all system-wide preferences. You must extract from this structure the values of the sysSoundLevel and alarmSoundLevel fields. These values are the only sound preference information that Palm OS version 1.0 provides. <a name="925513"> </a><p></p><dt>Each of these fields holds a value of either <code>slOn</code> (on) or <code>slOff</code> (off). Your code must interpret the values read from these fields as an indication of whether those volumes should be on or off, then map them to appropriate amplitude values to pass to Sound Manager functions: map the <code>slOn</code> selector to the <code>sndMaxAmp</code> constant (defined in <code>SoundMgr.h</code>) and map the <code>slOff</code> selector to the value <code>0</code> (zero). </dl><a name="925516"> </a><h4>Listing 8.7	 SystemPreferencesTypeV10 data structure</h4><a name="925517"> </a><hr><code>typedef struct {</code><br><a name="925518"> </a><code>&nbsp&nbsp&nbsp UInt16 version;	 	 	 	 	 	 	 // Version of preference info</code><br><a name="925519"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925520"> </a><code>&nbsp&nbsp&nbsp // International preferences</code><br><a name="925521"> </a><code>&nbsp&nbsp&nbsp CountryType country;	 	 	 	 	 // Country the device is in</code><br><a name="925522"> </a><code>&nbsp&nbsp&nbsp DateFormatType dateFormat;	 	 	 // Format to display date in</code><br><a name="925523"> </a><code>&nbsp&nbsp&nbsp DateFormatType longDateFormat;	 // Format to display date in</code><br><a name="925524"> </a><code>&nbsp&nbsp&nbsp UInt8 weekStartDay;	 	 	 	 	 // Sunday or Monday</code><br><a name="925525"> </a><code>&nbsp&nbsp&nbsp TimeFormatType timeFormat;	 	 	 // Format to display time in</code><br><a name="925526"> </a><code>&nbsp&nbsp&nbsp NumberFormatType numberFormat;	 // Format to display numbers in</code><br><a name="925527"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925528"> </a><code>&nbsp&nbsp&nbsp // system preferences</code><br><a name="925529"> </a><code>&nbsp&nbsp&nbsp UInt8 autoOffDuration;	 	 	 	 // Time period before shutting off</code><br><a name="925530"> </a><code>&nbsp&nbsp&nbsp SoundLevelTypeV20 sysSoundLevel;	 	 //	 error beeps</code><br><a name="925531"> </a><code>&nbsp&nbsp&nbsp SoundLevelTypeV20 alarmSoundLevel;	 //	 alarm only</code><br><a name="925532"> </a><code>&nbsp&nbsp&nbsp Boolean hideSecretRecords;	 	 	 // True to not display records with</code><br><a name="925533"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 	 	 	 	 	 	 	 	 // their secret bit attribute set</code><br><a name="925534"> </a><code>&nbsp&nbsp&nbsp Boolean deviceLocked;	 	 	 	 	 	 	 	 	 	 	 // Device locked until the system</code><br><a name="925535"> </a><code>&nbsp&nbsp&nbsp 	 	 	 	 	 	 	 	 	 	 	 // password is entered</code><br><a name="925536"> </a><code>&nbsp&nbsp&nbsp UInt16	 	 sysPrefFlags;	 	 	 	 // Miscellaneous system pref flags copied into<br>	 	 	 	 	 	 	 	 	  // the global GSysPrefFlags at boot time.</code><br><a name="925537"> </a><code>&nbsp&nbsp&nbsp SysBatteryKind sysBatteryKind;	 <br>	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 // The type of batteries installed.<br>	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 // This is copied into the globals<br>	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 // GSysbatteryKind at boot time.</code><br><a name="925538"> </a><code>&nbsp&nbsp&nbsp </code><br><a name="925539"> </a><code>&nbsp&nbsp&nbsp } SystemPreferencesTypeV10;</code><br><hr><br><a name="925541"> </a><h4> Using Palm OS 2.0 Sound Preferences</h4><dl><a name="925542"> </a><p></p><dt>Version 2.0 of Palm OS introduces a new API for retrieving individual preference values from the system. You can pass any of the selectors <code>prefSysSoundLevelV20</code>, <code>prefGameSoundLevelV20</code>, or <code>prefAlarmSoundLevelV20</code> to the <a href="Preferences.html#924972">PrefGetPreference</a> function to retrieve individual amplitude preference values for alarm sounds, game sounds, or for overall (system) sound amplitude. As in Palm OS 1.0, each of these settings holds values of either <code>slOn</code> (on) or <code>slOff</code> (off), as defined in the Preferences.h file. Your code must interpret the values read from these fields as an indication of whether those volumes should be on or off, then map them to appropriate amplitude values to pass to Sound Manager functions: map the <code>slOn</code> selector to the <code>sndMaxAmp</code> constant (defined in <code>SoundMgr.h</code> file) and map the <code>slOff</code> selector to the value <code>0</code> (zero). <a name="925550"> </a><p></p><dt>For a complete listing of selectors you can pass to the <code>PrefGetPreference</code> function, see the <code>Preferences.h</code> file. </dl><a name="925551"> </a><h4> Using Palm OS 3.X Sound Preferences</h4><dl><a name="925552"> </a><p></p><dt>Palm OS version 3.X enhances the resolution of sound preference settings by providing discrete amplitude levels for games, alarms, and the system overall. As usual, do not set preferences yourself, but treat them as read-only values indicating the proper volume level for your application to use. <a name="925553"> </a><p></p><dt>Palm OS 3.X defines the new sound amplitude selectors <code>prefSysSoundVolume</code>, <code>prefGameSoundVolume</code>, and <code>prefAlarmSoundVolume</code> for use with the <a href="Preferences.html#924972">PrefGetPreference</a><code> </code>function. The values this function returns for these selectors are actual amplitude settings that may be passed directly to Sound Manager functions. <a name="925561"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>The amplitude selectors used in previous versions of Palm OS (all ending with the <code>Level</code> suffix, such as <code>prefGameSoundLevel</code>) are obsoleted in version 3.0 of Palm OS and replaced by new selectors. The old selectors remain available in Palm OS 3.X to ensure backward compatibility and are suffixed <code>V20</code> (for example, <code>prefGameSoundLevelV20</code>). <hr><br></blockquote></dl><a name="925563"> </a><h4> Ensuring Sound Preferences Compatibility</h4><dl><a name="925564"> </a><p></p><dt>For greatest compatibility with multiple versions of the sound preferences mechanism, your application should condition its sound preference code according to the version of Palm OS on which it is running. See <a href="SystemFeatures.html#925135">"The System Version Feature"</a> for more information.<a name="925568"> </a><p></p><dt>When your application is launched, it should retrieve the system version number and save the results in its global variables (or equivalent structure) for use elsewhere. If the major version number is 3 (three) or greater, then use the 3.0 mechanism for obtaining sound amplitude preferences, since this reflects the user's selection most accurately. If the major version number is 2 (two), then use the 2.0 mechanism described in "<a href="SystemFeatures.html#925541">Using Palm OS 2.0 Sound Preferences</a>." If it is 1 (one), then use the 1.0 mechanism described in "<a href="SystemFeatures.html#925503">Using Palm OS 1.0 Sound Preferences</a>."<a name="925575"> </a><p></p><dt>Avoid calling new APIs (including new selectors) when running on older versions of Palm OS that do not implement them. In particular, note that violating any of the following conditions will cause your application to crash:<ul type="SQUARE"><a name="925580"> </a><br><li>Do not call either of the <a href="SoundManager.html#925365">SndPlaySmf</a> or <a href="SoundManager.html#925275">SndCreateMidiList</a> functions on versions of Palm OS prior to 3.0. <br><a name="925585"> </a><br><li>Do not pass any selector other than <code>sndCmdFreqDurationAmp</code> to the <a href="SoundManager.html#925313">SndDoCmd</a><code> </code>function on versions of Palm OS prior to 3.0. <br></ul></dl><a name="925607"> </a><h2> System Boot and Reset</h2><dl><a name="925610"> </a><p></p><dt>Any reset is normally performed by sticking a bent-open paper clip or a large embroidery needle into the small hole in the back of the device. This hole, known as the "reset switch" is above and to the right of the serial number sticker (on Palm III devices). Depending on additional keys held down, the reset behavior varies, as follows:</dl><a name="925611"> </a><h3> Soft Reset</h3><dl><a name="925613"> </a><p></p><dt>A soft reset clears all of the dynamic heap (Heap 0, Card 0). The storage heaps remain untouched. The operating system restarts from scratch with a new stack, new global variables, restarted drivers, and a reset communication port. All applications on the device receive a <code><a href="AppLaunchCodes.html#925479"></code>sysAppLaunchCmdSystemReset<code></a></code> launch code. </dl><a name="925619"> </a><h3> Soft Reset + Up Arrow</h3><dl><a name="925621"> </a><p></p><dt>Holding the up-arrow down while pressing the reset switch with a paper clip causes the same soft reset logic with the following two exceptions:<ul type="SQUARE"><a name="925622"> </a><br><li>The <code>sysAppLaunchCmdSystemReset</code> launch code is not sent to applications. This is useful if there is an application on the device that crashes upon receiving this launch code (not uncommon) and therefore prevents the system from booting. <br><a name="925624"> </a><br><li>The OS won't load any system patches during startup. This is useful if you have to delete or replace a system patch database. If the system patches are loaded and therefore open, they cannot be replaced or deleted from the system. <br></ul></dl><a name="925625"> </a><h3> Hard Reset</h3><dl><a name="925627"> </a><p></p><dt>A hard reset is performed by pressing the reset switch with a paper clip while holding down the power key. This has all the effects of the soft reset. In addition, the storage heaps are erased. As a result, all programs, data, patches, user information, etc. are lost. A confirmation message is displayed asking the user to confirm the deletion of all data. <a name="925629"> </a><p></p><dt>The <code>sysAppLaunchCmdSystemReset</code> launch code is sent to the applications at this time. If the user selected the "Delete all data" option, the digitizer calibration screen comes up first. The default databases for the four main applications is copied out of the ROM. <a name="925631"> </a><p></p><dt>If you hold down the up arrow key when the "Delete all data" message is displayed, and then press the other four application buttons while still holding the up arrow key, the system is booted without reading the default databases for the four main applications out of ROM. </dl><a name="925632"> </a><h3> System Reset Calls</h3><dl><a name="925633"> </a><p></p><dt>The system manager provides support for booting the Palm OS device. It calls <code><a href="SystemManager.html#925597"></code>SysReset<code></a></code> to reset the device. This call does a soft reset and has the same effect as pressing the reset switch on the unit. <strong><em>Normally applications should not use this call.</strong></em> <a name="925638"> </a><p></p><dt><code>SysReset</code> is used, for example, by the Sync application. When the user copies an extension onto the Palm OS device, the Sync application automatically resets the device after the sync is completed to allow the extension to install itself. <a name="925639"> </a><p></p><dt>The <code>SysColdBoot</code> call is similar, but even more dangerous. It performs a hard reset that clears all user storage RAM on the device, destroying all user data. </dl><a name="925641"> </a><h2> Hardware Interaction</h2><dl><a name="925644"> </a><p></p><dt>Palm OS differs from a traditional desktop system in that it's never really turned off. Power is constantly supplied to essential subsystems and the on/off key is merely a way of bringing the device in or out of low-power mode. The obvious effect of pressing the on/off key is that the LCD turns on or off. When the user presses the power key to turn the device off, the LCD is disabled, which makes it appear as if power to the entire unit is turned off. In fact, the memory system, real-time clock, and the interrupt generation circuitry are still running, though they are consuming little current. <a name="925645"> </a><p></p><dt>This section looks at Palm OS power management, discussing the following topics:<ul type="SQUARE"><a name="925649"> </a><br><li><a href="SystemFeatures.html#925659">Palm OS Power Modes</a><br><a name="925653"> </a><br><li><a href="SystemFeatures.html#925677">Guidelines for Application Developers</a><br><a name="925657"> </a><br><li><a href="SystemFeatures.html#925690">Power Management Calls</a><br></ul></dl><a name="925659"> </a><h3> Palm OS Power Modes</h3><dl><a name="925661"> </a><p></p><dt>To minimize power consumption, the operating system dynamically switches between three different modes of operation: sleep mode, doze mode, and running mode. The system manager controls transitions between different power modes and provides an API for controlling some aspects of the power management. <ul type="SQUARE"><a name="925664"> </a><br><li>In <strong>sleep mode</strong>, the device looks like it's turned off: the display is blank, the digitizer is inactive, and the main clock is stopped. The only circuits still active are the real-time clock and interrupt generation circuitry. <br><dl><a name="925665"> </a><p></p><dt>The device enters this mode when there is no user activity for a number of minutes or when the user presses the off button. The device comes out of sleep mode only when there is an interrupt, for example, when the user presses a button. <a name="925666"> </a><p></p><dt>To enter sleep mode, the system puts as many peripherals as possible into low-power mode and sets up the hardware so that an interrupt from any hard key or the real-time clock wakes up the system. When the system gets one of these interrupts while in sleep mode, it quickly checks that the battery is strong enough to complete the wake-up and then takes each of the peripherals, for example, the LCD, serial port, and timers, out of low-power mode. </dl><a name="925668"> </a><br><li>In<strong><em> </strong></em><strong>doze mode</strong>, the main clock is running, the device appears to be turned on, the LCD is on, and the processor's clock is running but it's not executing instructions (that is, it's halted). When the processor receives an interrupt, it comes out of halt and starts processing the interrupt. <br><dl><a name="925669"> </a><p></p><dt>The device enters this mode whenever it's on but has no user input to process.<a name="925670"> </a><p></p><dt>The system can come out of doze mode much faster than it can come out of sleep mode since none of the peripherals need to be woken up. In fact, it takes no longer to come out of doze mode than to process an interrupt. Usually, when the system appears on, it is actually in doze mode and goes into running mode only for short periods of time to process an interrupt or respond to user input like a pen tap or key press. </dl><a name="925672"> </a><br><li>In <strong>running mode</strong>, the processor is actually executing instructions. <br><dl><a name="925673"> </a><p></p><dt>The device enters this mode when it detects user input (like a tap on the screen) while in doze mode or when it detects an interrupt while in doze or sleep mode. The device stays in running mode only as long as it takes to process the user input (most likely less than a second), then it immediately reenters doze mode. A typical application puts the system into running mode only about 5% of the time. </dl></ul><a name="925675"> </a><p></p><dt>To maximize battery life, the processor on the Palm Computing platform device is kept out of running mode as much as possible. Any interrupt generated on the device must therefore be capable of "waking" up the processor. The processor can receive interrupts from the serial port, the hard buttons on the case, the button on the cradle, the programmable timer, the memory module slot, the real-time clock (for alarms), the low-battery detector, and any built-in peripherals such as a pager or modem. </dl><a name="925677"> </a><h3> Guidelines for Application Developers</h3><dl><a name="925679"> </a><p></p><dt>Normally, applications don't need to be aware of power management except for a few simple guidelines. When an application calls <a href="SystemEventManager.html#925143">EvtGetEvent</a> to ask the system for the next event to process, the system automatically puts itself into doze mode until there is an event to process. As long as an application uses <code>EvtGetEvent</code>, power management occurs automatically. If there has been no user input for the amount of time determined by the current setting of the auto-off preference, the system automatically enters sleep mode without intervention from the application.<a name="925684"> </a><p></p><dt>Applications should avoid providing their own delay loops. Instead, they should use <a href="SystemManager.html#925663">SysTaskDelay</a>, which puts the system into doze mode during the delay to conserve as much power as possible. If an application needs to perform periodic work, it can pass a time out to <code>EvtGetEvent</code>; this forces the unit to wake up out of doze mode and to return to the application when the time out expires, even if there is no event to process. Using these mechanisms provides the longest possible battery life.</dl><a name="925690"> </a><h3> Power Management Calls</h3><dl><a name="925691"> </a><p></p><dt>The system calls <code>SysSleep</code> to put itself immediately into low-power sleep mode. Normally, the system puts itself to sleep when there has been no user activity for the minimum auto-off time or when the user presses the power key. <a name="925696"> </a><p></p><dt>The <a href="SystemManager.html#925613">SysSetAutoOffTime</a> routine changes the auto-off time value. This routine is normally used by the system only during boot, and by the Preferences application. The Preferences application saves the user preference for the auto-off time in a preferences database, and the system initializes the auto-off time to the value saved in the preferences database during boot. While the auto-off feature can be disabled entirely by calling <code>SysSetAutoOffTime</code> with a time-out of 0, doing this depletes the battery. <a name="925698"> </a><p></p><dt>The current battery level and other information can be obtained through the <a href="SystemManager.html#924986">SysBatteryInfo</a> routine. This call returns information about the battery, including the current battery voltage in hundredths of a volt, the warning thresholds for the low-battery alerts, the battery type, and whether external power is applied to the unit. This call can also change the battery warning thresholds and battery type. </dl><a name="925705"> </a><h2> The Microkernel</h2><dl><a name="925707"> </a><p></p><dt>Palm OS has a preemptive multitasking kernel that provides basic task management.<a name="925708"> </a><p></p><dt>Most applications don't need the microkernel services because they are handled automatically by the system. This functionality is provided mainly for internal use by the system software or for certain special purpose applications. <a name="925709"> </a><p></p><dt>In this version of the Palm OS, there is only one user interface application running at a time. The User Interface Application Shell (UIAS) is responsible for managing the current user-interface application. The UIAS launches the current user-interface application as a subroutine and doesn't get control back until that application quits. When control returns to the UIAS, the UIAS immediately launches the next application as another subroutine. See <a href="SystemFeatures.html#925690">"Power Management Calls"</a> for more information. <a name="925715"> </a><p></p><dt>Usually, the UIAS is the only task running. Occasionally though, an application launches another task as a part of its normal operation. One example of this is the Sync application, which launches a second task to handle the serial communication with the desktop. The Sync application creates a second task dedicated to the serial communication and gives this task a lower priority than the main user-interface task. The result is optimal performance over the serial port without a delay in response to the user-interface controls. <a name="925717"> </a><p></p><dt>Normally, there is no user interaction during a sync, so that the serial communication task gets all of the processor's time. However, if the user does tap on the screen, for example, to cancel the sync, the user-interface task immediately processes the tap, since it has a higher priority. Alternatively, the Sync application could have been written to use just one task, but then it would have to periodically poll for user input during the serial communication, which would hamper performance and user-interface response time.<a name="925720"> </a><blockquote><hr><strong>NOTE: &nbsp</strong><p></p>Only system software can launch a separate task. The multi-tasking API is not available to developer applications.<hr><br></blockquote></dl><a name="925728"> </a><h2> Retrieving the ROM Serial Number</h2><dl><a name="925729"> </a><p></p><dt>Some Palm devices, beginning with the Palm III product, hold a 12-digit serial number that identifies the device uniquely. (Earlier devices do not have this identifier.) The serial number is held in a displayable text buffer with no null terminator. The user can view the serial number in the <a href="UserInterface.html#926561">Application Launcher</a> application. (The pop-up version of the Launcher does not display the serial number.) The Application Launcher also displays to the user a checksum digit that you can use to validate user entry of the serial number. <a name="925733"> </a><p></p><dt>To retrieve the ROM serial number programmatically, pass the <code>sysROMTokenSnum</code> selector to the <a href="SystemManager.html#925264">SysGetROMToken</a><code> </code>function. If the <a href="SystemManager.html#925264">SysGetROMToken</a><code> </code>function returns an error, or if the returned pointer to the buffer is <code>NULL</code>, or if the first byte of the text buffer is <code>0xFF</code>, then no serial number is available.<a name="925743"> </a><p></p><dt>The <code>DrawSerialNumOrMessage</code> function shown in <a href="SystemFeatures.html#925746">Listing 8.8</a> retrieves the ROM serial number, calculates the checksum, and draws both on the screen at a specified location. If the device has no serial number, this function draws a message you specify. This function accepts as its input a pair of coordinates at which it draws output, and a pointer to the message it draws when a serial number is not available. <a name="935591"> </a><p></p><dt></dl><a name="925746"> </a><h4>Listing 8.8	 DrawSerialNumOrMessage</h4><a name="925747"> </a><hr><code>static void DrawSerialNumOrMessage(Int16&nbsp;x, Int16&nbsp;y, Char* noNumberMessage)</code><br><a name="925748"> </a><code>{</code><br><a name="932092"> </a><code>    Char* bufP;</code><br><a name="932093"> </a><code>    UInt16* bufLen;</code><br><a name="932094"> </a><code>    Err retval;</code><br><a name="925752"> </a><code>    Int16   count;</code><br><a name="925753"> </a><code>    UInt8    checkSum;</code><br><a name="925754"> </a><code>    Char    checksumStr[2];        <br>	 	 // holds the dash and the checksum digit</code><br><a name="925755"> </a><code></code><br><a name="925756"> </a><code>    retval = SysGetROMToken (0, sysROMTokenSnum, <br>	 	 	 	 	 	 	 	 	 	 	 	 	 	 (UInt8**) &amp;bufP, &amp;bufLen);</code><br><a name="925757"> </a><code>    if ((!retval) &amp;&amp; (bufP) &amp;&amp; ((UInt8) *bufP != 0xFF)) {  <br>	 	 // there's a valid serial number!</code><br><a name="925758"> </a><code>&nbsp&nbsp&nbsp 	 // Calculate the checksum:  Start with zero, add each digit,<br>	 	 // then rotate the result one bit to the left and repeat.</code><br><a name="925759"> </a><code>        checkSum = 0;</code><br><a name="925760"> </a><code>        for (count=0; count&lt;bufLen; count++) {</code><br><a name="925761"> </a><code>            checkSum += bufP[count];</code><br><a name="925762"> </a><code>            checkSum = (checkSum&lt;&lt;1) | ((checkSum &amp; 0x80) &gt;&gt; 7);</code><br><a name="925763"> </a><code>            }</code><br><a name="925764"> </a><code>&nbsp&nbsp&nbsp 	 // Add the two hex digits (nibbles) together, +2 <br>	 	 // (range: 2 - 31 ==&gt; 2-9, A-W)</code><br><a name="925765"> </a><code>&nbsp&nbsp&nbsp 	 // By adding 2 to the result before converting to ascii,<br>	 	 // we eliminate the numbers 0 and 1, which can be<br>	 	 // difficult to distinguish from the letters O and I.<br>	 	 checkSum = ((checkSum&gt;&gt;4) &amp; 0x0F) + (checkSum &amp; 0x0F) + 2;</code><br><a name="925766"> </a><code></code><br><a name="925767"> </a><code>&nbsp&nbsp&nbsp 	 // draw the serial number and find out how wide it was<br>	 	 WinDrawChars(bufP, bufLen, x, y);<br>	 	 x += FntCharsWidth(bufP, bufLen);</code><br><a name="925768"> </a><code></code><br><a name="925769"> </a><code>&nbsp&nbsp&nbsp 	 // draw the dash and the checksum digit right after it<br>	 	 checksumStr[0] = '-';<br>	 	 checksumStr[1] = <br>	 	 	 	 ((checkSum &lt; 10) ? (checkSum +'0'):(checkSum -10 +'A'));<br>	 	 WinDrawChars (checksumStr, 2, x, y);<br>	 	 }</code><br><a name="925770"> </a><code>    else // there's no serial number<br>	 	 // draw a status message if the caller provided one<br>	 	 if (noNumberMessage)<br>	 	 	 WinDrawChars(noNumberMessage, StrLen(noNumberMessage),x, y);</code><br><a name="925772"> </a><code>}</code><br><hr><br><a name="925774"> </a><h2> Time</h2><dl><a name="925779"> </a><p></p><dt>The Palm Computing platform device has a real-time clock and programmable timer as part of the 68328 processor. The real-time clock maintains the current time even when the system is in sleep mode (turned off). It's capable of generating an interrupt to wake the device when an alarm is set by the user. The programmable timer is used to generate the system tick count interrupts (100 times/second) while the processor is in doze or running mode. The system tick interrupts are required for periodic activity such as polling the digitizer for user input, key debouncing, etc.<a name="925785"> </a><p></p><dt>The date and time manager (called time manager in this chapter) provides access to both the 1-second and 0.01-second timing resources on the Palm OS device. <ul type="SQUARE"><a name="925788"> </a><br><li>The <em>1-second timer</em> keeps track of the real-time clock (date and time), even when the unit is in sleep mode. <br><a name="925791"> </a><br><li>The <em>0.01-second timer</em>, also referred to as the <strong>system ticks</strong>, can be used for finer timing tasks. This timer is not updated when the unit is in sleep mode and is reset to 0 each time the unit resets.<br></ul><a name="925792"> </a><p></p><dt>The basic time-manager API provides support for setting and getting the real-time clock in seconds and for getting the current system ticks value (but not for setting it). The system manager provides more advanced functionality for setting up a timer task that executes periodically or in a given number of system ticks.<a name="925793"> </a><p></p><dt>This section discusses the following topics: <ul type="SQUARE"><a name="925797"> </a><br><li><a href="SystemFeatures.html#925803">Using Real-Time Clock Functions</a><br><a name="925801"> </a><br><li><a href="SystemFeatures.html#925823">Using System Ticks Functions</a><br></ul></dl><a name="925803"> </a><h3> Using Real-Time Clock Functions</h3><dl><a name="925805"> </a><p></p><dt>The real-time clock functions of the time manager include <a href="DateAndTimeManager.html#925185">TimSetSeconds</a> and <code><a href="DateAndTimeManager.html#925140"></code>TimGetSeconds<code></a></code>. Real time on the Palm OS device is measured in seconds from midnight, Jan. 1, 1904. Call <code><a href="DateAndTimeManager.html#925168"></code>TimSecondsToDateTime<code></a></code> and <a href="DateAndTimeManager.html#925124">TimDateTimeToSeconds</a> to convert between seconds and a structure specifying year, month, day, hour, minute, and second.</dl><a name="925823"> </a><h3> Using System Ticks Functions</h3><dl><a name="925824"> </a><p></p><dt>The Palm OS device maintains a tick count that starts at 0 when the device is reset. This tick increments <ul type="SQUARE"><a name="925826"> </a><br><li>100 times per second when running on the Palm OS device<br><a name="925827"> </a><br><li>60 times per second when running on the Macintosh under the Simulator<br></ul><a name="925830"> </a><p></p><dt>For tick-based timing purposes, applications should use the macro <code><a href="SystemManager.html#925683"></code>SysTicksPerSecond<code></a></code>, which is conditionally compiled for different platforms. Use the function <a href="DateAndTimeManager.html#925156">TimGetTicks</a> to read the current tick count.<a name="925839"> </a><p></p><dt>Although the <code>TimGetTicks</code> function could be used in a loop to implement a delay, it is recommended that applications use the <code><a href="SystemManager.html#925663"></code>SysTaskDelay<code></a></code> function instead. The <code>SysTaskDelay</code> function automatically puts the unit into low-power mode during the delay. Using <code>TimGetTicks</code> in a loop consumes much more current.</dl><a name="925845"> </a><h2> Floating-Point</h2><dl><a name="925847"> </a><p></p><dt>Palm OS 1.0 provided 16-bit floating point arithmetic. Instead of using standard mathematical symbols, you called functions like <code>FplAdd</code>, <code>FplSub</code>, and so on. <a name="925848"> </a><p></p><dt>Palm OS 2.0 and later implements floating point arithmetic differently than Palm OS 1.0 did. The floating-point library in OS versions 2.0 and later provides 32-bit and 64-bit floating point arithmetic. </dl><a name="925850"> </a><h3> Using Floating Point Arithmetic</h3><dl><a name="925851"> </a><p></p><dt>To take advantage of the floating-point library, applications can now use the mathematical symbols + - * /instead of using functions like <code>FplAdd</code>, <code>FplSub</code>, etc.<a name="925852"> </a><p></p><dt>When compiling the application, you have to link in the floating point library under certain circumstances. Choose from one of these options:<ul type="SQUARE"><a name="925853"> </a><br><li><strong>Simulator application or application for 1.0 device</strong> -- link in the floating point library explicitly. <br><dl><a name="925854"> </a><p></p><dt>This library adds approximately 8KB to the size of your prc file. The library provides 32-bit and 64-bit floating-point arithmetic. The original Palm OS <code>Fpl</code> functions provided only 16-bit floating-point arithmetic. Linking in the library explicitly won't cause problems when you compile for a 2.0 or later device.</dl><a name="925855"> </a><br><li><strong>2.0 or later Palm OS device</strong>--It's not necessary to link in the library.<br><dl><a name="925856"> </a><p></p><dt>The compiler generates trap calls to equivalent floating-point functionality in the system ROM.</dl></ul><a name="925857"> </a><p></p><dt>There are control panel settings in the IDE which let you select the appropriate floating-point model.<a name="925858"> </a><p></p><dt>Floating-point functionality is identical in either method. </dl><a name="925859"> </a><h3> Using 1.0 Floating-Point Functionality</h3><dl><a name="925863"> </a><p></p><dt>The original <code>Fpl</code> calls (documented in the chapter <a href="FloatManager.html#924905">"Float Manager"</a> in the <em>Palm OS SDK Reference</em>) are still available. They may be useful for applications that don't need high precision, don't want to incur the size penalty of the float library, and want to run on 1.0 devices only. To get 1.0 behavior, use the 1.0 calls (<code>FplAdd</code>, etc.) and don't link in the library. </dl><a name="925865"> </a><h2> Summary of System Features</h2><p><a name="925888"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925869"> </a><strong>Alarm Manager Functions</strong></th><th><a name="925871"> </a><strong></strong></th></tr><tr><td><a name="925876"> </a><a href="AlarmManager.html#924970">AlmSetAlarm</a><br><a href="AlarmManager.html#925011">AlmSetProcAlarm</a></td><td><a name="925884"> </a><a href="AlarmManager.html#924926">AlmGetAlarm</a><br><a href="AlarmManager.html#924945">AlmGetProcAlarm</a></td></tr></table><table><tr><td></table></div></p><p><a name="926136"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925892"> </a><strong>Feature Manager Functions</strong></th><th><a name="925894"> </a><strong></strong></th></tr><tr><td colspan=1 rowspan=2><a name="925899"> </a><a href="FeatureManager.html#924918">FtrGet</a><br><a href="FeatureManager.html#925063">FtrSet</a><br><a href="FeatureManager.html#924984">FtrPtrNew</a><br><a href="FeatureManager.html#925030">FtrPtrResize</a></td><td colspan=1 rowspan=2><a name="925913"> </a><a href="FeatureManager.html#924939">FtrGetByIndex</a><br><a href="FeatureManager.html#925092">FtrUnregister</a><br><a href="FeatureManager.html#924961">FtrPtrFree</a></td></tr><tr></tr></table><table><tr><td></table></div></p><p><a name="929904"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th colspan=2 rowspan=1><a name="929912"> </a><strong>Notification Manager Functions</strong></th></tr><tr><td><a name="929916"> </a><a href="NotifyMgr.html#926525">SysNotifyRegister</a> <br><a href="NotifyMgr.html#926461">SysNotifyBroadcast</a> </td><td><a name="929918"> </a><a href="NotifyMgr.html#926589">SysNotifyUnregister</a> <br><a href="NotifyMgr.html#926492">SysNotifyBroadcastDeferred</a> </td></tr></table><table><tr><td></table></div></p><p><a name="929909"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925926"> </a><strong>Sound Manager Functions</strong></th><th><a name="925928"> </a><strong></strong></th></tr><tr><td colspan=1 rowspan=3><a name="925933"> </a><a href="SoundManager.html#925275">SndCreateMidiList</a><br><a href="SoundManager.html#925350">SndGetDefaultVolume</a><br><a href="SoundManager.html#925520">SndPlaySystemSound</a></td><td colspan=1 rowspan=3><a name="925944"> </a><a href="SoundManager.html#925313">SndDoCmd</a><br><a href="SoundManager.html#925365">SndPlaySmf</a><br><a href="SoundManager.html#925479">SndPlaySmfResource</a></td></tr><tr></tr><tr></tr></table><table><tr><td></table></div></p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="925962"> </a><strong>System Manager Functions</strong></th><th><a name="925964"> </a><strong></strong></th></tr><tr><td><a name="925966"> </a><strong>Launching Applications</strong></td><td><a name="925968"> </a></td></tr><tr><td><a name="925973"> </a><a href="SystemManager.html#924917">SysAppLaunch</a><br><a href="SystemManager.html#925101">SysBroadcastActionCode</a></td><td><a name="925981"> </a><a href="SystemManager.html#925699">SysUIAppSwitch</a></td></tr><tr><td><a name="925986"> </a><strong>System Dialogs</strong></td><td><a name="925988"> </a></td></tr><tr><td><a name="925993"> </a><a href="SystemManager.html#933939">SysGraffitiReferenceDialog</a><br><a href="SystemManager.html#925470">SysKeyboardDialogV10</a></td><td><a name="926001"> </a><a href="SystemManager.html#925446">SysKeyboardDialog</a></td></tr><tr><td><a name="926003"> </a><strong>Power Management</strong></td><td><a name="926005"> </a></td></tr><tr><td><a name="926010"> </a><a href="SystemManager.html#924986">SysBatteryInfo</a><br><a href="SystemManager.html#925613">SysSetAutoOffTime</a></td><td><a name="926018"> </a><a href="SystemManager.html#925024">SysBatteryInfoV20</a><br><a href="SystemManager.html#925663">SysTaskDelay</a></td></tr><tr><td><a name="926023"> </a><strong>System Management</strong></td><td><a name="926025"> </a></td></tr><tr><td><a name="926030"> </a><a href="SystemManager.html#925491">SysLibFind</a><br><a href="SystemManager.html#925584">SysRandom</a><br><a href="SystemManager.html#925341">SysGremlins</a></td><td><a name="926041"> </a><a href="SystemManager.html#925509">SysLibLoad</a><br><a href="SystemManager.html#925597">SysReset</a></td></tr><tr><td colspan=2 rowspan=1><a name="926046"> </a><strong>Working With Strings and Resources</strong></td></tr><tr><td><a name="926053"> </a><a href="SystemManager.html#925061">SysBinarySearch</a><br><a href="SystemManager.html#925553">SysQSort</a><br><a href="SystemManager.html#925157">SysCreatePanelList</a><br><a href="SystemManager.html#925229">SysFormPointerArrayToStrings</a></td><td><a name="926067"> </a><a href="SystemManager.html#925388">SysInsertionSort</a><br><a href="SystemManager.html#925125">SysCopyStringResource</a><br><a href="SystemManager.html#925643">SysStringByIndex</a></td></tr><tr><td><a name="926078"> </a><strong>Database Support</strong></td><td><a name="926080"> </a></td></tr><tr><td><a name="926085"> </a><a href="SystemManager.html#925137">SysCreateDataBaseList</a></td><td><a name="926090"> </a><a href="SystemManager.html#925175">SysCurAppDatabase</a></td></tr><tr><td><a name="926092"> </a><strong>Error Handling</strong></td><td><a name="926094"> </a></td></tr><tr><td><a name="926099"> </a><a href="SystemManager.html#925196">SysErrString</a></td><td><a name="926104"> </a></td></tr><tr><td><a name="926106"> </a><strong>Event Handling</strong></td><td><a name="926108"> </a></td></tr><tr><td><a name="926113"> </a><a href="SystemManager.html#925364">SysHandleEvent</a></td><td><a name="926115"> </a></td></tr><tr><td><a name="926117"> </a><strong>System Information</strong></td><td><a name="926119"> </a></td></tr><tr><td><a name="926124"> </a><a href="SystemManager.html#925243">SysGetOSVersionString</a><br><a href="SystemManager.html#925264">SysGetROMToken</a></td><td><a name="926132"> </a><a href="SystemManager.html#925291">SysGetStackInfo</a><br><a href="SystemManager.html#925683">SysTicksPerSecond</a></td></tr></table><table><tr><td></table></div></p><p><a name="926243"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="926140"> </a><strong>Time Manager Functions</strong></th><th><a name="926142"> </a><strong></strong></th></tr><tr><td colspan=2 rowspan=1><a name="926144"> </a><strong>Allowing User to Change Date and Time</strong></td></tr><tr><td><a name="926151"> </a><a href="DateAndTimeSelector.html#924913">DayHandleEvent</a><br><a href="DateAndTimeSelector.html#924943">SelectDay</a></td><td><a name="926159"> </a><a href="DateAndTimeSelector.html#925014">SelectTimeV33</a><br><a href="DateAndTimeSelector.html#924970">SelectDayV10</a></td></tr><tr><td><a name="926164"> </a><strong>Changing the Date</strong></td><td><a name="926166"> </a></td></tr><tr><td><a name="926171"> </a><a href="DateAndTimeManager.html#924952">DateAdjust</a><br><a href="DateAndTimeManager.html#925185">TimSetSeconds</a></td><td><a name="926179"> </a><a href="DateAndTimeManager.html#925104">TimAdjust</a></td></tr><tr><td><a name="926181"> </a><strong>Converting to Date Format</strong></td><td><a name="926183"> </a></td></tr><tr><td><a name="926188"> </a><a href="DateAndTimeManager.html#924968">DateDaysToDate</a><br><a href="DateAndTimeManager.html#925168">TimSecondsToDateTime</a></td><td><a name="926196"> </a><a href="DateAndTimeManager.html#924988">DateSecondsToDate</a></td></tr><tr><td colspan=2 rowspan=1><a name="926198"> </a><strong>Converting Dates to Other Formats</strong></td></tr><tr><td><a name="926205"> </a><a href="DateAndTimeManager.html#925000">DateToAscii</a><br><a href="DateAndTimeManager.html#925025">DateToDays</a><br><a href="DateAndTimeManager.html#925140">TimGetSeconds</a><br><a href="DateAndTimeManager.html#925156">TimGetTicks</a></td><td><a name="926219"> </a><a href="DateAndTimeManager.html#925201">TimeToAscii</a><br><a href="DateAndTimeManager.html#925044">DateToDOWDMFormat</a><br><a href="DateAndTimeManager.html#925124">TimDateTimeToSeconds</a><br></td></tr><tr><td><a name="926227"> </a><strong>Date Information</strong></td><td><a name="926229"> </a></td></tr><tr><td><a name="926234"> </a><a href="DateAndTimeManager.html#925066">DayOfMonth</a><br><a href="DateAndTimeManager.html#925092">DaysInMonth</a></td><td><a name="926242"> </a><a href="DateAndTimeManager.html#925079">DayOfWeek</a></td></tr></table><table><tr><td></table></div></p><p><a name="926309"> </a> </p><p><div> <table border="3"><caption><B></B></caption><tr><th><a name="926246"> </a><strong>Float Manager Functions</strong></th><th><a name="926248"> </a><strong></strong></th></tr><tr><td colspan=1 rowspan=6><a name="926253"> </a><a href="FloatManager.html#924914">FplAdd</a><br><a href="FloatManager.html#924948">FplBase10Info</a><br><a href="FloatManager.html#924984">FplFloatToLong</a><br><a href="FloatManager.html#925022">FplFree</a><br><a href="FloatManager.html#925057">FplInit</a><br><a href="FloatManager.html#925088">FplMul</a></td><td colspan=1 rowspan=6><a name="926273"> </a><a href="FloatManager.html#924930">FplAToF</a><br><a href="FloatManager.html#924968">FplDiv</a><br><a href="FloatManager.html#925003">FplFloatToULong</a><br><a href="FloatManager.html#925040">FplFToA</a><br><a href="FloatManager.html#925077">FplLongToFloat</a><br><a href="FloatManager.html#925104">FplSub</a></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr></table><table><tr><td></table></div></p><p><a name="926332"> </a> <strong></strong></p><hr><br><center><B>Palm OS Programmer's Companion</B></center><br><TABLE WIDTH="100%">  <TR>    <TD WIDTH=10%>&nbsp</TD>    <TD WIDTH=20%><a href="FilesAndDatabases.html"><IMG SRC="images/prev.html" BORDER=0 ALT="Previous Page"></TD>    <TD WIDTH=20%><a href="CompanionTOC.html"><IMG SRC="images/content.gif" BORDER=0 ALT="Table of Contents"></TD>    <TD WIDTH=20%><a href="CompanionIX.html"><IMG SRC="images/index.gif" BORDER=0 ALT="Index"></TD>    <TD WIDTH=20%><a href="SerialCommunication.html"><IMG SRC="images/next.html" BORDER=0 ALT="Next Page"></TD>    <TD WIDTH=10%>&nbsp</TD>  </TR></TABLE><br><small><em>This is page 77 of 85 in this book</em></small><hr><br><address><a href="http://www.palmos.com/dev/">Palm Computing Platform Development Zone</a></address><i>Copyright &#169; 2000, Palm, Inc.   All rightsreserved.</i><!-- This file was created with Quadralay WebWorks Publisher 5.0.2 --><!-- --><!-- For more information on how this document, and how the rest of --><!-- this server was created, email devsupp@palm.com --><!-- --><!-- Last updated: 03/27/00 21:29:42 --></body>
<!-- Mirrored from users.fuw.edu.pl/~michalj/palmos/SystemFeatures.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 17 Feb 2015 19:10:13 GMT -->
</html>